<#@ include file="WAQS.Specifications.Dependences.ttinclude"#>
<#@ template language="C#" hostspecific="true"#>
<#@ output extension=".txt"#>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="System.Collections"#>
<#@ import namespace="System"#>
<#@ import namespace="System.Collections.Concurrent"#>
<#@ import namespace="System.Collections.Generic"#>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq"#>
<#@ import namespace="System.Text"#>
<#@ import namespace="System.Text.RegularExpressions"#>
<#@ import namespace="System.Threading.Tasks"#>
<#+
// Copyright (c) Matthieu MEZIL.  All rights reserved.

public static IEnumerable<EnvDTE.Project> GetProjects(ITextTemplatingEngineHost host)
{
    var serviceProvider = (IServiceProvider)host;
    var dte = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));
    var projects = dte.Solution.Projects.OfType<object>().ToList();
    while (projects.Count != 0)
    {
        var projectsValue = projects.ToList();
        projects.Clear();
        foreach (var item in projectsValue)
        {
            if (item != null)
            { 
                var project = item as EnvDTE.Project;
                if (project != null) 
                {
                    if (project.Properties == null) // unload project in a folder
                        continue;
                    if (project.FullName.EndsWith(".csproj"))
                        yield return project;
                    else if (project.ProjectItems != null)
                        projects.AddRange(project.ProjectItems.OfType<object>());
                }
                else 
                { 
                    var projectItem = item as EnvDTE.ProjectItem;
                    if (projectItem != null)
                    {
                        if (projectItem.SubProject != null)
                            projects.Add(projectItem.SubProject);
                        if (projectItem.ProjectItems != null)
                            projects.AddRange(projectItem.ProjectItems.OfType<object>());
                    }
                }                
            }
        }
    }
}

public static IEnumerable<EnvDTE.ProjectItem> GetAllCsItems(EnvDTE.Project parent)
{
    if (parent != null)
        foreach (EnvDTE.ProjectItem value in parent.ProjectItems)
        {
            if (! value.Name.EndsWith(".tt"))
            {
                if (value.Name.EndsWith(".cs"))
                    yield return value;
                else if (value != parent && value.Name != null)
                {
                    foreach (var item in GetAllCsItems(value))
                        yield return item;
                    foreach (var item in GetAllCsItems(value.SubProject))
                        yield return item;
                }
            }
        }
}
public static IEnumerable<EnvDTE.ProjectItem> GetAllCsItems(EnvDTE.ProjectItem parent)
{
    if (parent != null)
        foreach (EnvDTE.ProjectItem value in parent.ProjectItems)
        {
            if (! value.Name.EndsWith(".tt"))
            {
                if (value.Name.EndsWith(".cs"))
                    yield return value;
                else if (value != parent && value.Name != null)
                {
                    foreach (var item in GetAllCsItems(value))
                        yield return item;
                    foreach (var item in GetAllCsItems(value.SubProject))
                        yield return item;
                }
            }
        }
}

public class SpecificationsElements
{
    public enum Type
    {
        Server,
        UnitTest,
        Client
    }

    public enum MethodAnalizing
    {
        Method,
        Signature,
        None
    }

    private SpecificationsElements(Dictionary<string, object> cache)
    {
        Usings = new Dictionary<string, List<string>>();
        Solution = (ISolution)cache["Solution"];
        GetMethods = (Dictionary<string, List<MethodDeclarationSyntax>>)cache["GetMethods"];
        ValidateMethods = (Dictionary<string, List<MethodDeclarationSyntax>>)cache["ValidateMethods"];
        ServiceMethods = (List<MethodDeclarationSyntax>)cache["ServiceMethods"];
        AllServiceMethods = (List<MethodDeclarationSyntax>)cache["AllServiceMethods"];
        SubMethods = (List<MethodDeclarationSyntax>)cache["SubMethods"];
        Methods = (List<MethodDeclarationSyntax>)cache["Methods"];
        var metadata = (Dictionary<string, List<Dictionary<string, object>>>)cache["Metadata"];
        Metadata = new Dictionary<string, List<WAQSMetadata>>();
        var metadataValues = new Dictionary<int, WAQSMetadata>();
        foreach (var m in metadata)
            Metadata.Add(m.Key, m.Value.Select(m2 => 
                {
                    var mValue = WAQSMetadata.Get(m2);
                    metadataValues.Add((int)m2["HashCode"], mValue);
                    return mValue;
                }).ToList());
        ExtensionMethods = (List<MethodDeclarationSyntax>)cache["ExtensionMethods"];
        NonExtensionMethods = (List<MethodDeclarationSyntax>)cache["NonExtensionMethods"];
        NonEntitiesExtensionMethods = (List<MethodDeclarationSyntax>)cache["NonEntitiesExtensionMethods"];
        ServiceProperties = (List<PropertySymbol>)cache["ServiceProperties"];
        var methodsDependentProperties = (Dictionary<MethodDeclarationSyntax, List<List<Dictionary<string, object>>>>)cache["MethodsDependentProperties"];
        MethodsDependentProperties = new Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>>();
        foreach (var mdp in methodsDependentProperties)
            MethodsDependentProperties.Add(mdp.Key, mdp.Value == null ? null : mdp.Value.Select(mdps => mdps.Select(PropertySymbolInfo.Get).ToList()).ToList());
        var methodsDependentPropertiesLast = (Dictionary<MethodDeclarationSyntax, List<List<Dictionary<string, object>>>>)cache["MethodsDependentPropertiesLast"];
        MethodsDependentPropertiesLast = new Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>>();
        foreach (var mdp in methodsDependentPropertiesLast)
            MethodsDependentPropertiesLast.Add(mdp.Key, mdp.Value == null ? null : mdp.Value.Select(mdps => mdps.Select(PropertySymbolInfo.Get).ToList()).ToList());
        SemanticModelPerMethods = (ConcurrentDictionary<MethodDeclarationSyntax, ISemanticModel>)cache["SemanticModelPerMethods"];
        MethodPerMethodSymbols = (ConcurrentDictionary<string, MethodDeclarationSyntax>)cache["MethodPerMethodSymbols"];
        MethodSymbolPerMethods = (ConcurrentDictionary<MethodDeclarationSyntax, MethodSymbol>)cache["MethodSymbolPerMethods"];
        CompilationUnitPerClass = (Dictionary<string, List<CompilationUnitSyntax>>)cache["CompilationUnitPerClass"];
        var semanticModelPerMetadata = (Dictionary<Dictionary<string, object>, ISemanticModel>)cache["SemanticModelPerMetadata"];
        SemanticModelPerMetadata = new Dictionary<WAQSMetadata, ISemanticModel>();
        foreach (var smpm in semanticModelPerMetadata)
            SemanticModelPerMetadata.Add(metadataValues[(int)smpm.Key["HashCode"]], smpm.Value);
        InterfacesPerClasses = (Dictionary<string, List<NamedTypeSymbol>>)cache["InterfacesPerClasses"];
        ClassesPerInterfaces = (Dictionary<string, List<string>>)cache["ClassesPerInterfaces"];
        ClassTypesPerInterfaces = (Dictionary<string, List<NamedTypeSymbol>>)cache["ClassTypesPerInterfaces"];
        TypeSymbols = (Dictionary<string, TypeSymbol>)cache["TypeSymbols"];
        Documents = (List<IDocument>)cache["Documents"];
        CompilationUnitSyntaxes = (List<CompilationUnitSyntax>)cache["CompilationUnitSyntaxes"];
        SemanticModelPerCompilationUnits = (Dictionary<CompilationUnitSyntax, ISemanticModel>)cache["SemanticModelPerCompilationUnits"];
        SpecificationsNamespaces = (List<string>)cache["SpecificationsNamespaces"];
        SpecificationsTypes = (List<TypeSymbol>)cache["SpecificationsTypes"];
        _servicePropertiesStrings = (List<string>)cache["_servicePropertiesStrings"];
        var classes = (List<Dictionary<string, object>>)cache["_classes"];
        _classes = new List<ClassNames>();
        foreach (var cn in classes)
            _classes.Add(ClassNames.Get(cn));
        _extensionMethodsPerTypes = (Dictionary<string, List<MethodDeclarationSyntax>>)cache["_extensionMethodsPerTypes"];
        _nonValidationExtensionMethodsPerTypes = (Dictionary<string, List<MethodDeclarationSyntax>>)cache["_nonValidationExtensionMethodsPerTypes"];
        _getMethodSymbols = (HashSet<MethodSymbol>)cache["_getMethodSymbols"];
        _allValidateMethods = (HashSet<MethodDeclarationSyntax>)cache["_allValidateMethods"];
        _abstractMethods = (HashSet<MethodDeclarationSyntax>)cache["_abstractMethods"];
        _virtualMethods = (HashSet<MethodDeclarationSyntax>)cache["_virtualMethods"];
        _overrideMethods = (HashSet<MethodDeclarationSyntax>)cache["_overrideMethods"];
        _customMethods = (HashSet<MethodDeclarationSyntax>)cache["_customMethods"];
        _validateFuncMethods = (HashSet<MethodDeclarationSyntax>)cache["_validateFuncMethods"];
        _useServiceProperty = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_useServiceProperty"];
        _isApplicableOnClient = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isApplicableOnClient"];
        _isExposedAsService = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isExposedAsService"];
        _isDefineMethod = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isDefineMethod"];
        _isGetMethod = (ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, Tuple<string, bool>>)cache["_isGetMethod"];
        _isValidateMethod = (ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, Tuple<string, bool>>)cache["_isValidateMethod"];
        _isServiceMethod = (ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool>)cache["_isServiceMethod"];
        _isSubMethod = (ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool>)cache["_isSubMethod"];
        var overridenMethods = (Dictionary<MethodDeclarationSyntax, List<Dictionary<string, object>>>)cache["_overridenMethods"];
        foreach (var om in overridenMethods)
            _overridenMethods.TryAdd(om.Key, om.Value.Select(MethodWithDepth.Get).ToList());
        _isModeOnInsert = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isModeOnInsert"];
        _isModeOnUpdate = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isModeOnUpdate"];
        _isModeOnDelete = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isModeOnDelete"];
        _isValidatableOnInsertOutsideTransaction = (ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool>)cache["_isValidatableOnInsertOutsideTransaction"];
        _isCriticityError = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isCriticityError"];
        _isValidatedInTransaction = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isValidatedInTransaction"];
        _dependentNavigationProperties = (ConcurrentDictionary<MethodDeclarationSyntax, List<NavigationProperty>>)cache["_dependentNavigationProperties"];
        _equivalentMethods = (ConcurrentDictionary<MethodSymbol, MethodSymbol>)cache["_equivalentMethods"];
        _typeSymbolPerTypes = (ConcurrentDictionary<TypeSyntax, TypeSymbol>)cache["_typeSymbolPerTypes"];
        ServerFxDALInterfacesNamespace = (string)cache["ServerFxDALInterfacesNamespace"];
        ServerFxServiceInterfacesNamespace = (string)cache["ServerFxServiceInterfacesNamespace"];
        ServerFxSpecificationsNamespace = (string)cache["ServerFxSpecificationsNamespace"];
    }

    public static SpecificationsElements Get(ITextTemplatingEngineHost host, SpecificationPath[] specificationPathes, SpecificationPath entitiesPath, string serverFxSpecificationsNamespace, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, string entitiesNamespace, EdmxElements edmxElements, SpecificationsElements.Type type, bool dal = false, bool service = false, Func<ITypeSymbol, string> getNamespaceFromTypeSymbol = null, Func<IMethodSymbol, string> getNamespaceFromMethodSymbol = null, bool isInterface = false)
    {
        var sb = new StringBuilder();
        var lastWriteTime = new FileInfo(edmxElements.EdmxPath).LastWriteTime;
        sb.Append(Path.GetFullPath(host.ResolvePath(edmxElements.EdmxPath)));
        if (entitiesPath != null)
        {
            var entitiesPathCsproj = Path.GetFullPath(host.ResolvePath(entitiesPath.Csproj));
            var project = GetProjects(host).First(p => p.FullName == entitiesPathCsproj);
            var entitiesPathFolder = host.ResolvePath(entitiesPath.Folder);
            sb.Append(entitiesPathFolder);
            foreach (var file in GetAllCsItems(project).Select(i => (string)i.Properties.OfType<EnvDTE.Property>().First(p => p.Name == "LocalPath").Value))
            {
                sb.Append(file);
                var lastWriteTimeLoop = new FileInfo(file).LastWriteTime;
                if (lastWriteTimeLoop > lastWriteTime)
                    lastWriteTime = lastWriteTimeLoop;
            }
        }
        foreach (var specificationPath in specificationPathes)
        {
            var specificationPathFolder = Path.GetFullPath(host.ResolvePath(specificationPath.Folder));
            sb.Append(specificationPathFolder);
            foreach (var file in Directory.GetFiles(host.ResolvePath(specificationPathFolder)).Where(f => f.EndsWith(".cs")))
            {
                sb.Append(file);
                var lastWriteTimeLoop = new FileInfo(file).LastWriteTime;
                if (lastWriteTimeLoop > lastWriteTime)
                    lastWriteTime = lastWriteTimeLoop;
            }
        }
        string cacheKey = sb.ToString();
        SpecificationsElements value;
        var cache = System.AppDomain.CurrentDomain.GetData(cacheKey) as Dictionary<string, object>;
        if (cache != null && (DateTime)cache["LastWriteTime"] == lastWriteTime)
        {
            value = new SpecificationsElements(cache);
            value.Init(type, dal, service, isInterface, entitiesNamespace, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol);
            return value;
        }
        ISolution solution = null;
        IProject entitiesProject = null;
        List<IDocument> entitiesDocuments = null;
        var specificationDocuments = new Dictionary<IDocument, Compilation>();
        if (specificationPathes.Length != 0 && entitiesPath != null)
        {
            var entitiesSlnFilePath = Path.GetFullPath(host.ResolvePath(entitiesPath.Sln));
            var entitiesSolution = LoadSolution(entitiesSlnFilePath, host);
            var entitiesProjectPath = Path.GetFullPath(host.ResolvePath(entitiesPath.Csproj));
            entitiesProject = entitiesSolution.Projects.FirstOrDefault(p => Path.GetFullPath(p.FilePath) == entitiesProjectPath);
            if (entitiesProject == null)
                goto EntitiesDocumentsNull;
            var entitiesFolderPath = entitiesPath.Folder;
            entitiesFolderPath = Path.GetFullPath(host.ResolvePath(entitiesFolderPath));
            entitiesDocuments = entitiesProject.Documents.Where(d => Path.GetFullPath(d.FilePath).StartsWith(entitiesFolderPath)).ToList();
        }
        foreach (var specificationPath in specificationPathes)
        {
            var specificationSlnFilePath = Path.GetFullPath(host.ResolvePath(specificationPath.Sln));
            solution = LoadSolution(specificationSlnFilePath, host);
            var specificationProjectPath = Path.GetFullPath(host.ResolvePath(specificationPath.Csproj));
            var project = solution.Projects.FirstOrDefault(p => Path.GetFullPath(p.FilePath) == specificationProjectPath);
            var specificationFolderPath = specificationPath.Folder;
            specificationFolderPath = Path.GetFullPath(host.ResolvePath(specificationFolderPath));
            var compilation = GetCompilation(project);
            foreach (var document in project.Documents.Where(d => Path.GetFullPath(d.FilePath).StartsWith(specificationFolderPath) && ! Path.GetFullPath(d.FilePath).EndsWith(".Designer.cs")))
                specificationDocuments.Add(document, compilation);
        }
EntitiesDocumentsNull:
        value = new SpecificationsElements(host, specificationPathes, entitiesPath, serverFxSpecificationsNamespace, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, entitiesNamespace, edmxElements, type, dal, service, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol, isInterface, solution, entitiesProject, entitiesDocuments, specificationDocuments);
        Cache(cacheKey, value, lastWriteTime);
        return value;
    }
    private static void Cache(string cacheKey, SpecificationsElements value, DateTime lastWriteTime)
    {
        var cache = new Dictionary<string, object>();
        cache.Add("LastWriteTime", lastWriteTime);
        cache.Add("Solution", value.Solution);
        cache.Add("GetMethods", value.GetMethods);
        cache.Add("ValidateMethods", value.ValidateMethods);
        cache.Add("ServiceMethods", value.ServiceMethods);
        cache.Add("AllServiceMethods", value.AllServiceMethods);
        cache.Add("SubMethods", value.SubMethods);
        cache.Add("Methods", value.Methods);
        var metadata = new Dictionary<string, List<Dictionary<string, object>>>();
        foreach (var m in value.Metadata)
            metadata.Add(m.Key, m.Value.Select(wm => wm.ToCache()).ToList());
        cache.Add("Metadata", metadata);
        cache.Add("ExtensionMethods", value.ExtensionMethods);
        cache.Add("NonExtensionMethods", value.NonExtensionMethods);
        cache.Add("NonEntitiesExtensionMethods", value.NonEntitiesExtensionMethods);
        cache.Add("ServiceProperties", value.ServiceProperties);
        var methodsDependentProperties = new Dictionary<MethodDeclarationSyntax, List<List<Dictionary<string, object>>>>();
        foreach (var mdp in value.MethodsDependentProperties)
            methodsDependentProperties.Add(mdp.Key, mdp.Value == null ? null : mdp.Value.Select(mdps => mdps.Select(mdp2 => mdp2.ToCache()).ToList()).ToList());
        cache.Add("MethodsDependentProperties", methodsDependentProperties);
        var methodsDependentPropertiesLast = new Dictionary<MethodDeclarationSyntax, List<List<Dictionary<string, object>>>>();
        foreach (var mdp in value.MethodsDependentPropertiesLast)
            methodsDependentPropertiesLast.Add(mdp.Key, mdp.Value == null ? null : mdp.Value.Select(mdps => mdps.Select(mdp2 => mdp2.ToCache()).ToList()).ToList());
        cache.Add("MethodsDependentPropertiesLast", methodsDependentPropertiesLast);
        cache.Add("SemanticModelPerMethods", value.SemanticModelPerMethods);
        cache.Add("MethodPerMethodSymbols", value.MethodPerMethodSymbols);
        cache.Add("MethodSymbolPerMethods", value.MethodSymbolPerMethods);
        cache.Add("CompilationUnitPerClass", value.CompilationUnitPerClass);
        var semanticModelPerMetadata = new Dictionary<Dictionary<string, object>, ISemanticModel>();
        foreach (var smpm in value.SemanticModelPerMetadata)
            semanticModelPerMetadata.Add(smpm.Key.ToCache(), smpm.Value);
        cache.Add("SemanticModelPerMetadata", semanticModelPerMetadata);
        cache.Add("Usings", value.Usings);
        cache.Add("InterfacesPerClasses", value.InterfacesPerClasses);
        cache.Add("ClassesPerInterfaces", value.ClassesPerInterfaces);
        cache.Add("ClassTypesPerInterfaces", value.ClassTypesPerInterfaces);
        cache.Add("TypeSymbols", value.TypeSymbols);
        cache.Add("Documents", value.Documents);
        cache.Add("CompilationUnitSyntaxes", value.CompilationUnitSyntaxes);
        cache.Add("SemanticModelPerCompilationUnits", value.SemanticModelPerCompilationUnits);
        cache.Add("SpecificationsNamespaces", value.SpecificationsNamespaces);
        cache.Add("SpecificationsTypes", value.SpecificationsTypes);
        cache.Add("InterfaceSpecifications", value.InterfaceSpecifications);
        cache.Add("InterfaceExtensionMethods", value.InterfaceExtensionMethods);
        cache.Add("_servicePropertiesStrings", value._servicePropertiesStrings);
        cache.Add("_classes", value._classes.Select(c => c.ToCache()).ToList());
        cache.Add("_extensionMethodsPerTypes", value._extensionMethodsPerTypes);
        cache.Add("_nonValidationExtensionMethodsPerTypes", value._nonValidationExtensionMethodsPerTypes);
        cache.Add("_getMethodSymbols", value._getMethodSymbols);
        cache.Add("_allValidateMethods", value._allValidateMethods);
        cache.Add("_abstractMethods", value._abstractMethods);
        cache.Add("_virtualMethods", value._virtualMethods);
        cache.Add("_overrideMethods", value._overrideMethods);
        cache.Add("_customMethods", value._customMethods);
        cache.Add("_validateFuncMethods", value._validateFuncMethods);
        cache.Add("_useServiceProperty", value._useServiceProperty);
        cache.Add("_isApplicableOnClient", value._isApplicableOnClient);
        cache.Add("_isExposedAsService", value._isExposedAsService);
        cache.Add("_isDefineMethod", value._isDefineMethod);
        cache.Add("_isGetMethod", value._isGetMethod);
        cache.Add("_isValidateMethod", value._isValidateMethod);
        cache.Add("_isServiceMethod", value._isServiceMethod);
        cache.Add("_isSubMethod", value._isSubMethod);
        var overridenMethods = new Dictionary<MethodDeclarationSyntax, List<Dictionary<string, object>>>();
        foreach (var om in value._overridenMethods)
            overridenMethods.Add(om.Key, om.Value.Select(mwd => mwd.ToCache()).ToList());
        cache.Add("_overridenMethods", overridenMethods);
        cache.Add("_isModeOnInsert", value._isModeOnInsert);
        cache.Add("_isModeOnUpdate", value._isModeOnUpdate);
        cache.Add("_isModeOnDelete", value._isModeOnDelete);
        cache.Add("_isValidatableOnInsertOutsideTransaction", value._isValidatableOnInsertOutsideTransaction);
        cache.Add("_isCriticityError", value._isCriticityError);
        cache.Add("_isValidatedInTransaction", value._isValidatedInTransaction);
        cache.Add("_dependentNavigationProperties", value._dependentNavigationProperties);
        cache.Add("_equivalentMethods", value._equivalentMethods);
        cache.Add("_typeSymbolPerTypes", value._typeSymbolPerTypes);
        cache.Add("ServerFxDALInterfacesNamespace", value.ServerFxDALInterfacesNamespace);
        cache.Add("ServerFxServiceInterfacesNamespace", value.ServerFxServiceInterfacesNamespace);
        cache.Add("ServerFxSpecificationsNamespace", value.ServerFxSpecificationsNamespace);
        System.AppDomain.CurrentDomain.SetData(cacheKey, cache);
    }
    private SpecificationsElements(ITextTemplatingEngineHost host, SpecificationPath[] specificationPathes, SpecificationPath entitiesPath, string serverFxSpecificationsNamespace, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, string entitiesNamespace, EdmxElements edmxElements, SpecificationsElements.Type type, bool dal, bool service, Func<ITypeSymbol, string> getNamespaceFromTypeSymbol, Func<IMethodSymbol, string> getNamespaceFromMethodSymbol, bool isInterface, ISolution solution, IProject entitiesProject, List<IDocument> entitiesDocuments, Dictionary<IDocument, Compilation> specificationDocuments)
    {
        ServerFxDALInterfacesNamespace = serverFxDALInterfacesNamespace;
        ServerFxServiceInterfacesNamespace = serverFxServiceInterfacesNamespace;
        Solution = solution;
        _classes = edmxElements.EntityTypes.Select(e => 
            {
                string name = edmxElements.Code.Escape(e);
                return new ClassNames { Name = name, FullName = string.Concat(entitiesNamespace, ".", name) };
            }).ToList();
        ServerFxSpecificationsNamespace = serverFxSpecificationsNamespace;
        GetMethods = new Dictionary<string, List<MethodDeclarationSyntax>>();
        ValidateMethods = new Dictionary<string, List<MethodDeclarationSyntax>>();
        ServiceMethods = new List<MethodDeclarationSyntax>();
        SubMethods = new List<MethodDeclarationSyntax>();
        Metadata = new Dictionary<string, List<WAQSMetadata>>();
        ExtensionMethods = new List<MethodDeclarationSyntax>();
        NonExtensionMethods = new List<MethodDeclarationSyntax>();
        NonEntitiesExtensionMethods = new List<MethodDeclarationSyntax>();
        ServiceProperties = new List<PropertySymbol>();
        SemanticModelPerMethods = new ConcurrentDictionary<MethodDeclarationSyntax, ISemanticModel>();
        MethodPerMethodSymbols = new ConcurrentDictionary<string, MethodDeclarationSyntax>();
        MethodSymbolPerMethods = new ConcurrentDictionary<MethodDeclarationSyntax, MethodSymbol>();
        CompilationUnitPerClass = new Dictionary<string, List<CompilationUnitSyntax>>();
        SemanticModelPerMetadata = new Dictionary<WAQSMetadata, ISemanticModel>();
        Usings = new Dictionary<string, List<string>>();
        MethodsDependentProperties = new Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>>();
        MethodsDependentPropertiesLast = new Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>>();
        InterfacesPerClasses = new Dictionary<string, List<NamedTypeSymbol>>();
        ClassesPerInterfaces = new Dictionary<string, List<string>>();
        ClassTypesPerInterfaces = new Dictionary<string, List<NamedTypeSymbol>>();
        TypeSymbols = new Dictionary<string, TypeSymbol>();
        Documents = new List<IDocument>();
        CompilationUnitSyntaxes = new List<CompilationUnitSyntax>();
        SemanticModelPerCompilationUnits = new Dictionary<CompilationUnitSyntax, ISemanticModel>();
        if (entitiesDocuments == null)
            Methods = new List<MethodDeclarationSyntax>();
        else
        {
            AllServiceMethods = new List<MethodDeclarationSyntax>();
            foreach (var document in entitiesDocuments)
            {
                var documentTree = GetSyntaxTree(document);
                var compilation = GetCompilation(entitiesProject);
                var compilationUnit = (CompilationUnitSyntax)documentTree.GetRoot();
                var semanticModel = compilation.GetSemanticModel(documentTree);
                foreach (var classDeclaration in new ClassesVisitor().Visit(compilationUnit))
                {
                    string className = classDeclaration.Identifier.ValueText;
                    if (edmxElements.EdmTypes.Any(e => edmxElements.Code.Escape(e) == className) && !InterfacesPerClasses.ContainsKey(className))
                    {
                        var typeSymbol = (TypeSymbol)semanticModel.GetDeclaredSymbol(classDeclaration);
                        if (! TypeSymbols.ContainsKey(typeSymbol.Name))
                            TypeSymbols.Add(typeSymbol.Name, typeSymbol);
                        var interfaces = typeSymbol.Interfaces.ToList();
                        InterfacesPerClasses.Add(className, interfaces);
                        foreach (var @interface in interfaces)
                        {
                            List<string> classes;
                            string interfaceName = @interface.ToString();
                            if (! ClassesPerInterfaces.TryGetValue(interfaceName, out classes))
                                ClassesPerInterfaces.Add(interfaceName, classes = new List<string>());
                            if (! classes.Contains(className))
                                classes.Add(className);

                            List<NamedTypeSymbol> classTypes;
                            if (! ClassTypesPerInterfaces.TryGetValue(interfaceName, out classTypes))
                                ClassTypesPerInterfaces.Add(interfaceName, @classTypes = new List<NamedTypeSymbol>());
                            var classType = (NamedTypeSymbol)semanticModel.GetDeclaredSymbol(classDeclaration);
                            if (! classTypes.Contains(classType))
                                classTypes.Add(classType);
                        }
                    }
                }
            }
            SpecificationsNamespaces = new List<string>();
            SpecificationsTypes = new List<TypeSymbol>();
            var definePropertyDependencesMethods = new List<MethodDeclarationSyntax>();
            foreach (var specificationDocument in specificationDocuments)
            {
                var compilation = specificationDocument.Value;
                var document = specificationDocument.Key;
                var documentTree = GetSyntaxTree(document);
                var compilationUnit = (CompilationUnitSyntax)documentTree.GetRoot();
                var semanticModel = compilation.GetSemanticModel(documentTree);
                Documents.Add(document);
                CompilationUnitSyntaxes.Add(compilationUnit);
                SemanticModelPerCompilationUnits.Add(compilationUnit, semanticModel);
                var specificationVisitor = new EntitiesSpecificationVisitor(this, semanticModel, edmxElements, entitiesNamespace);
                specificationVisitor.Visit(compilationUnit);
                foreach (var specificationGetMethodsPerClass in specificationVisitor.GetMethods)
                {
                    foreach (var method in specificationGetMethodsPerClass.Value)
                    {
                        ExtensionMethods.Add(method);
                        GetAndAddMethodSymbol(method, semanticModel);
                    }
                    List<CompilationUnitSyntax> compilationUnits;
                    if (! CompilationUnitPerClass.TryGetValue(specificationGetMethodsPerClass.Key, out compilationUnits))
                        CompilationUnitPerClass.Add(specificationGetMethodsPerClass.Key, compilationUnits = new List<CompilationUnitSyntax>());
                    if (! compilationUnits.Contains(compilationUnit))
                        compilationUnits.Add(compilationUnit);

                    List<MethodDeclarationSyntax> methods;
                    if (GetMethods.TryGetValue(specificationGetMethodsPerClass.Key, out methods))
                        methods.AddRange(specificationGetMethodsPerClass.Value);
                    else
                        GetMethods.Add(specificationGetMethodsPerClass.Key, specificationGetMethodsPerClass.Value);
                }
                foreach (var specificationValidateMethodsPerClass in specificationVisitor.ValidateMethods)
                {
                    foreach (var method in specificationValidateMethodsPerClass.Value)
                    {
                        ExtensionMethods.Add(method);
                        GetAndAddMethodSymbol(method, semanticModel);
                    }
                    List<CompilationUnitSyntax> compilationUnits;
                    if (! CompilationUnitPerClass.TryGetValue(specificationValidateMethodsPerClass.Key, out compilationUnits))
                        CompilationUnitPerClass.Add(specificationValidateMethodsPerClass.Key, compilationUnits = new List<CompilationUnitSyntax>());
                    if (! compilationUnits.Contains(compilationUnit))
                        compilationUnits.Add(compilationUnit);

                    List<MethodDeclarationSyntax> methods;
                    if (ValidateMethods.TryGetValue(specificationValidateMethodsPerClass.Key, out methods))
                        methods.AddRange(specificationValidateMethodsPerClass.Value);
                    else
                        ValidateMethods.Add(specificationValidateMethodsPerClass.Key, specificationValidateMethodsPerClass.Value);
                }
                foreach (var waqsMetadata in specificationVisitor.WAQSMetadata)
                {
                    List<WAQSMetadata> metadata;
                    if (Metadata.TryGetValue(waqsMetadata.Key, out metadata))
                        metadata.AddRange(waqsMetadata.Value);
                    else
                        Metadata.Add(waqsMetadata.Key, waqsMetadata.Value);
                    foreach (var m in waqsMetadata.Value)
                        SemanticModelPerMetadata.Add(m, semanticModel);
                }
                foreach (var method in specificationVisitor.ServiceMethods)
                {
                    var methodSymbol = GetAndAddMethodSymbol(method, semanticModel);
                    if (methodSymbol.IsExtensionMethod)
                    {
                        ExtensionMethods.Add(method);
                        List<CompilationUnitSyntax> compilationUnits;
                        var extensionTypeName = methodSymbol.Parameters[0].Type.Name;
                        if (edmxElements.EdmTypes.Any(et => edmxElements.Code.Escape(et) == extensionTypeName))
                        {
                            if (! CompilationUnitPerClass.TryGetValue(extensionTypeName, out compilationUnits))
                                CompilationUnitPerClass.Add(extensionTypeName, compilationUnits = new List<CompilationUnitSyntax>());
                            if (! compilationUnits.Contains(compilationUnit))
                                compilationUnits.Add(compilationUnit);
                        }
                        else
                        {
                            List<string> classes;
                            if (ClassesPerInterfaces.TryGetValue(extensionTypeName, out classes))
                                foreach (var className in classes)
                                {
                                    if (! CompilationUnitPerClass.TryGetValue(className, out compilationUnits))
                                        CompilationUnitPerClass.Add(className, compilationUnits = new List<CompilationUnitSyntax>());
                                    if (! compilationUnits.Contains(compilationUnit))
                                        compilationUnits.Add(compilationUnit);
                                }
                            else if (methodSymbol.Parameters.Any() && ! (edmxElements.EdmTypes.Any(et => methodSymbol.Parameters[0].Type.ToString() == string.Concat(entitiesNamespace, ".", edmxElements.Code.Escape(et)) || ClassesPerInterfaces.Keys.Contains(methodSymbol.Parameters[0].Type.ToString()))))
                                NonEntitiesExtensionMethods.Add(method);
                        }
                    }
                    else
                        NonExtensionMethods.Add(method);
                    ServiceMethods.Add(method);
                }
                foreach (var method in specificationVisitor.SubMethods)
                {
                    var methodSymbol = GetAndAddMethodSymbol(method, semanticModel);
                    if (methodSymbol.IsExtensionMethod)
                    {
                        ExtensionMethods.Add(method);
                        List<CompilationUnitSyntax> compilationUnits;
                        var extensionTypeName = methodSymbol.Parameters[0].Type.Name;
                        if (edmxElements.EdmTypes.Any(et => edmxElements.Code.Escape(et) == extensionTypeName))
                        {
                            if (! CompilationUnitPerClass.TryGetValue(extensionTypeName, out compilationUnits))
                                CompilationUnitPerClass.Add(extensionTypeName, compilationUnits = new List<CompilationUnitSyntax>());
                            if (! compilationUnits.Contains(compilationUnit))
                                compilationUnits.Add(compilationUnit);
                        }
                        else
                        {
                            List<string> classes;
                            if (ClassesPerInterfaces.TryGetValue(methodSymbol.Parameters[0].Type.ToString(), out classes))
                                foreach (var className in classes)
                                {
                                    if (! CompilationUnitPerClass.TryGetValue(className, out compilationUnits))
                                        CompilationUnitPerClass.Add(className, compilationUnits = new List<CompilationUnitSyntax>());
                                    if (! compilationUnits.Contains(compilationUnit))
                                        compilationUnits.Add(compilationUnit);
                                }
                            else
                                NonEntitiesExtensionMethods.Add(method);
                        }
                    }
                    else
                        NonExtensionMethods.Add(method);
                    SubMethods.Add(method);
                }
                foreach (var definePropertyDependencesMethod in specificationVisitor.DefinePropertyDependencesMethods)
                {
                    definePropertyDependencesMethods.Add(definePropertyDependencesMethod);
                    SemanticModelPerMethods.TryAdd(definePropertyDependencesMethod, semanticModel);
                }
                foreach (var property in specificationVisitor.ServiceProperties)
                    ServiceProperties.Add((PropertySymbol)semanticModel.GetDeclaredSymbol(property));
            }

            Methods = GetMethods.SelectMany(ms => ms.Value).Union(ServiceMethods).Union(SubMethods).Union(ValidateMethods.SelectMany(ms => ms.Value)).ToList();
            foreach (var m in Methods)
            {
                if (m.ParameterList.Parameters.Any())
                {
                    var definePropertyDependencesMethod = definePropertyDependencesMethods.FirstOrDefault(m2 => m2.Identifier.ValueText == string.Concat("Define", m.Identifier.ValueText, "PropertyDependences"));
                    if (definePropertyDependencesMethod == null)
                    {
                        var semanticModel = SemanticModelPerMethods[m];
                        var methodSymbol = MethodSymbolPerMethods[m];
                        GetMembersVisitor.Reset();
                        if (HasContextOrServiceAsParameter(methodSymbol))
                        {
                            MethodsDependentProperties.Add(m, null);
                            MethodsDependentPropertiesLast.Add(m, null);
                        }
                        else
                        {
                            var membersVisitor = new GetMembersVisitor(semanticModel, this, methodSymbol, methodSymbol.Parameters[0].Name, serverFxDALInterfacesNamespace, SemanticModelPerMethods, MethodPerMethodSymbols, GetMethods, ExtensionMethods);
                            membersVisitor.Visit(m.Body);
                            {
                                MethodsDependentProperties.Add(m, membersVisitor.GetProperties());
                                MethodsDependentPropertiesLast.Add(m, membersVisitor.GetReturnProperties());
                            }
                        }
                    }
                    else
                    {
                        var semanticModel = SemanticModelPerMethods[definePropertyDependencesMethod];
                        var definePropertyDependencesMethodVisitor = new DefinePropertyDependencesMethodVisitor(this, semanticModel);
                        definePropertyDependencesMethodVisitor.Visit(definePropertyDependencesMethod);
                        MethodsDependentProperties.Add(m, definePropertyDependencesMethodVisitor.Properties);
                    }
                }
                else
                {
                    MethodsDependentProperties.Add(m, new List<List<PropertySymbolInfo>>());
                    MethodsDependentPropertiesLast.Add(m, new List<List<PropertySymbolInfo>>());
                }
            }
        }
        AllServiceMethods = ServiceMethods.Union(ValidateMethods.SelectMany(kvp => kvp.Value).Where(m => IsExposedAsService(m))).ToList();
        foreach (var metadata in Metadata.SelectMany(kvp => kvp.Value))
            if (metadata.LambdaExpression != null)
            {
                var semanticModel = SemanticModelPerMetadata[metadata];
                var methodSymbol = (MethodSymbol)semanticModel.GetSymbolInfo(metadata.LambdaExpression).Symbol;
                GetMembersVisitor.Reset();
                var membersVisitor = new GetMembersVisitor(semanticModel, this, methodSymbol, methodSymbol.Parameters[0].Name, serverFxDALInterfacesNamespace, SemanticModelPerMethods, MethodPerMethodSymbols, GetMethods, ExtensionMethods);
                membersVisitor.Visit(metadata.LambdaExpression.Body);
                metadata.DependentProperties = membersVisitor.GetProperties().Where(d => d[0].Name != metadata.Property).ToList();
            }
            else
                metadata.DependentProperties = new List<List<PropertySymbolInfo>>();
        foreach (var metadata in from m in Metadata.SelectMany(kvp => kvp.Value)
                                 group m by new { PropertyContainingTypeName = m.PropertySymbol.ContainingType.ToString(), m.Property, m.MethodName } into g
                                 where g.Skip(1).Any()
                                 from m2 in g
                                 let minDepth = g.Where(m3 => TypeSymbolHelper.IsInherited(m3.TypeSymbol, m2.TypeSymbol)).Min(m => TypeSymbolHelper.GetTypeInheritanceDepth(m.TypeSymbol))
                                 where TypeSymbolHelper.GetTypeInheritanceDepth(m2.TypeSymbol) != minDepth
                                 select m2)
        metadata.IsOverriden = true;
        Init(type, dal, service, isInterface, entitiesNamespace, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol);
    }

    private void Init(SpecificationsElements.Type type, bool dal, bool service, bool isInterface, string entitiesNamespace, Func<ITypeSymbol, string> getNamespaceFromTypeSymbol, Func<IMethodSymbol, string> getNamespaceFromMethodSymbol)
    {
        Usings = new Dictionary<string, List<string>>();
        foreach (var compilationUnit in CompilationUnitSyntaxes)
            new UsingVisitor(SemanticModelPerCompilationUnits[compilationUnit], this, ServerFxSpecificationsNamespace, ServerFxDALInterfacesNamespace, ServerFxServiceInterfacesNamespace, entitiesNamespace, type, SpecificationsNamespaces, m =>
            {
                ISemanticModel sm;
                if (SemanticModelPerMethods.TryGetValue(m, out sm))
                {
                    switch (type)
                    {
                        case Type.UnitTest:
                        case Type.Server: 
                            return isInterface ? MethodAnalizing.Signature : MethodAnalizing.Method;
                        case Type.Client:
                            if (IsApplicableOnClient(m))
                                return MethodAnalizing.Method;
                            if (m.Modifiers.Any(mo => GetKind(mo) == SyntaxKind.PublicKeyword))
                                return MethodAnalizing.Signature;
                            return MethodAnalizing.None;
                    }
                }
                return MethodAnalizing.Signature;
            }, Usings, dal, service, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol).Visit(compilationUnit);

        InterfaceSpecifications = new List<NamedTypeSymbol>();
        InterfaceExtensionMethods = new Dictionary<string, List<MethodDeclarationSyntax>>();
        foreach (var @interface in InterfacesPerClasses.SelectMany(ipc => ipc.Value.Where(i => ! i.GetAttributes().Any(a => a.ToString() == ServerFxSpecificationsNamespace + ".IEntityAttribute"))).GroupBy(i => i.ToString()))
        {
            var extensionMethods = ExtensionMethods.Where(m => MethodSymbolPerMethods[m].Parameters[0].Type.ToString () == @interface.Key).ToList();
            if (extensionMethods.Any())
            {
                InterfaceSpecifications.Add(@interface.First());
                InterfaceExtensionMethods.Add(@interface.Key, type == Type.Client ? extensionMethods.Where(m => IsApplicableOnClient(m)).ToList() : extensionMethods);
            }
        }
    }

    public static SpecificationsElements Get(ITextTemplatingEngineHost host, SpecificationPath[] dtoPathes, SpecificationPath[] specificationPathes, IEnumerable<TypeSymbol> dtoTypes, string dtoNamespace, string serverFxSpecificationsNamespace, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, SpecificationsElements.Type type, Func<ITypeSymbol, string> getNamespaceFromTypeSymbol = null, Func<IMethodSymbol, string> getNamespaceFromMethodSymbol = null)
    {
        var sb = new StringBuilder();
        var lastWriteTime = DateTime.MinValue;
        foreach (var dtoPath in dtoPathes)
        {
            var dtoPathFolder = Path.GetFullPath(host.ResolvePath(dtoPath.Folder));
            sb.Append(dtoPathFolder);
            foreach (var file in Directory.GetFiles(dtoPathFolder).Where(f => f.EndsWith(".cs")))
            {
                sb.Append(file);
                var lastWriteTimeLoop = new FileInfo(file).LastWriteTime;
                if (lastWriteTimeLoop > lastWriteTime)
                    lastWriteTime = lastWriteTimeLoop;
            }
        }
        foreach (var specificationPath in specificationPathes)
        {
            var specificationPathFolder = Path.GetFullPath(host.ResolvePath(specificationPath.Folder));
            sb.Append(specificationPathFolder);
            foreach (var file in Directory.GetFiles(specificationPathFolder).Where(f => f.EndsWith(".cs")))
            {
                sb.Append(file);
                var lastWriteTimeLoop = new FileInfo(file).LastWriteTime;
                if (lastWriteTimeLoop > lastWriteTime)
                    lastWriteTime = lastWriteTimeLoop;
            }
        }
        string cacheKey = sb.ToString();
        var cache = System.AppDomain.CurrentDomain.GetData(cacheKey) as Dictionary<string, object>;
        SpecificationsElements value;
        if (cache != null && (DateTime)cache["LastWriteTime"] == lastWriteTime)
        {
            value = new SpecificationsElements(cache);
            value.SetUsings(type, dtoNamespace, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol);
            return value;
        }
        var specificationDocuments = new Dictionary<IDocument, Compilation>();
        ISolution solution = null;
        foreach (var specificationPath in specificationPathes)
        {
            var specificationSlnFilePath = specificationPath.Sln;
            solution = LoadSolution(Path.GetFullPath(host.ResolvePath(specificationSlnFilePath)), host);
            var specificationProjectPath = Path.GetFullPath(host.ResolvePath(specificationPath.Csproj));
            var project = solution.Projects.FirstOrDefault(p => Path.GetFullPath(p.FilePath) == specificationProjectPath);
            var specificationFolderPath = specificationPath.Folder;
            specificationFolderPath = Path.GetFullPath(host.ResolvePath(specificationFolderPath));
            var compilation = GetCompilation(project);
            foreach (var document in project.Documents.Where(d => Path.GetFullPath(d.FilePath).StartsWith(specificationFolderPath) && ! Path.GetFullPath(d.FilePath).EndsWith(".Designer.cs")))
                specificationDocuments.Add(document, compilation);
        }
        value = new SpecificationsElements(host, specificationPathes, dtoTypes, dtoNamespace, serverFxSpecificationsNamespace, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, type, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol, solution, specificationDocuments);
        Cache(cacheKey, value, lastWriteTime);
        return value;
    }
    private SpecificationsElements(ITextTemplatingEngineHost host, SpecificationPath[] specificationPathes, IEnumerable<TypeSymbol> dtoTypes, string dtoNamespace, string serverFxSpecificationsNamespace, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, SpecificationsElements.Type type, Func<ITypeSymbol, string> getNamespaceFromTypeSymbol, Func<IMethodSymbol, string> getNamespaceFromMethodSymbol, ISolution solution, Dictionary<IDocument, Compilation> specificationDocuments)
    {
        ServerFxDALInterfacesNamespace = serverFxDALInterfacesNamespace;
        ServerFxServiceInterfacesNamespace = serverFxServiceInterfacesNamespace;
        Solution = solution;
        _classes = dtoTypes.Select(dto => new ClassNames { Name = dto.Name, FullName = dto.ToString() }).ToList();
        ServerFxSpecificationsNamespace = serverFxSpecificationsNamespace;
        GetMethods = new Dictionary<string, List<MethodDeclarationSyntax>>();
        ValidateMethods = new Dictionary<string, List<MethodDeclarationSyntax>>();
        ServiceMethods = new List<MethodDeclarationSyntax>();
        SubMethods = new List<MethodDeclarationSyntax>();
        Metadata = new Dictionary<string, List<WAQSMetadata>>();
        ExtensionMethods = new List<MethodDeclarationSyntax>();
        NonExtensionMethods = new List<MethodDeclarationSyntax>();
        ServiceProperties = new List<PropertySymbol>();
        SemanticModelPerMethods = new ConcurrentDictionary<MethodDeclarationSyntax, ISemanticModel>();
        MethodPerMethodSymbols = new ConcurrentDictionary<string, MethodDeclarationSyntax>();
        MethodSymbolPerMethods = new ConcurrentDictionary<MethodDeclarationSyntax, MethodSymbol>();
        CompilationUnitPerClass = new Dictionary<string, List<CompilationUnitSyntax>>();
        SemanticModelPerMetadata = new Dictionary<WAQSMetadata, ISemanticModel>();
        Usings = new Dictionary<string, List<string>>();
        MethodsDependentProperties = new Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>>();
        MethodsDependentPropertiesLast = new Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>>();
        InterfacesPerClasses = new Dictionary<string, List<NamedTypeSymbol>>();
        ClassesPerInterfaces = new Dictionary<string, List<string>>();
        ClassTypesPerInterfaces = new Dictionary<string, List<NamedTypeSymbol>>();
        TypeSymbols = new Dictionary<string, TypeSymbol>();
        Documents = new List<IDocument>();
        CompilationUnitSyntaxes = new List<CompilationUnitSyntax>();
        SemanticModelPerCompilationUnits = new Dictionary<CompilationUnitSyntax, ISemanticModel>();
        SpecificationsNamespaces = new List<string>();
        SpecificationsTypes = new List<TypeSymbol>();
        if (specificationDocuments.Count != 0)
        {
            foreach (var specificationDocument in specificationDocuments)
            {
                var document = specificationDocument.Key;
                var compilation = specificationDocument.Value;
                var documentTree = GetSyntaxTree(document);
                var compilationUnit = (CompilationUnitSyntax)documentTree.GetRoot();
                var semanticModel = compilation.GetSemanticModel(documentTree);
                Documents.Add(document);
                CompilationUnitSyntaxes.Add(compilationUnit);
                SemanticModelPerCompilationUnits.Add(compilationUnit, semanticModel);
                var specificationVisitor = new DTOSpecificationVisitor(this, semanticModel, dtoTypes, dtoNamespace);
                specificationVisitor.Visit(compilationUnit);
                foreach (var specificationGetMethodsPerClass in specificationVisitor.GetMethods)
                {
                    foreach (var method in specificationGetMethodsPerClass.Value)
                    {
                        ExtensionMethods.Add(method);
                        GetAndAddMethodSymbol(method, semanticModel);
                    }
                    List<CompilationUnitSyntax> compilationUnits;
                    if (! CompilationUnitPerClass.TryGetValue(specificationGetMethodsPerClass.Key, out compilationUnits))
                        CompilationUnitPerClass.Add(specificationGetMethodsPerClass.Key, compilationUnits = new List<CompilationUnitSyntax>());
                    compilationUnits.Add(compilationUnit);

                    List<MethodDeclarationSyntax> methods;
                    if (GetMethods.TryGetValue(specificationGetMethodsPerClass.Key, out methods))
                        methods.AddRange(specificationGetMethodsPerClass.Value);
                    else
                        GetMethods.Add(specificationGetMethodsPerClass.Key, specificationGetMethodsPerClass.Value);
                }
                foreach (var specificationValidateMethodsPerClass in specificationVisitor.ValidateMethods)
                {
                    foreach (var method in specificationValidateMethodsPerClass.Value)
                    {
                        ExtensionMethods.Add(method);
                        GetAndAddMethodSymbol(method, semanticModel);
                    }
                    List<CompilationUnitSyntax> compilationUnits;
                    if (! CompilationUnitPerClass.TryGetValue(specificationValidateMethodsPerClass.Key, out compilationUnits))
                        CompilationUnitPerClass.Add(specificationValidateMethodsPerClass.Key, compilationUnits = new List<CompilationUnitSyntax>());
                    compilationUnits.Add(compilationUnit);

                    List<MethodDeclarationSyntax> methods;
                    if (ValidateMethods.TryGetValue(specificationValidateMethodsPerClass.Key, out methods))
                        methods.AddRange(specificationValidateMethodsPerClass.Value);
                    else
                        ValidateMethods.Add(specificationValidateMethodsPerClass.Key, specificationValidateMethodsPerClass.Value);
                }
                foreach (var method in specificationVisitor.ServiceMethods)
                {
                    var methodSymbol = GetAndAddMethodSymbol(method, semanticModel);
                    if (methodSymbol.IsExtensionMethod)
                    {
                        ExtensionMethods.Add(method);
                        List<CompilationUnitSyntax> compilationUnits;
                        var extensionType = methodSymbol.Parameters[0].Type;
                        if (dtoTypes.Any(t => t.ToString() == extensionType.ToString()))
                        {
                            if (! CompilationUnitPerClass.TryGetValue(extensionType.Name, out compilationUnits))
                                CompilationUnitPerClass.Add(extensionType.Name, compilationUnits = new List<CompilationUnitSyntax>());
                            if (! compilationUnits.Contains(compilationUnit))
                                compilationUnits.Add(compilationUnit);
                        }
                    }
                    else
                        NonExtensionMethods.Add(method);
                    ServiceMethods.Add(method);
                }
                foreach (var method in specificationVisitor.SubMethods)
                {
                    var methodSymbol = GetAndAddMethodSymbol(method, semanticModel);
                    if (methodSymbol.IsExtensionMethod)
                    {
                        ExtensionMethods.Add(method);
                        List<CompilationUnitSyntax> compilationUnits;
                        var extensionType = methodSymbol.Parameters[0].Type;
                        if (dtoTypes.Any(t => t.ToString() == extensionType.ToString()))
                        {
                            if (! CompilationUnitPerClass.TryGetValue(extensionType.Name, out compilationUnits))
                                CompilationUnitPerClass.Add(extensionType.Name, compilationUnits = new List<CompilationUnitSyntax>());
                            if (! compilationUnits.Contains(compilationUnit))
                                compilationUnits.Add(compilationUnit);
                        }
                    }
                    else
                        NonExtensionMethods.Add(method);
                    SubMethods.Add(method);
                }
                SetUsings(type, dtoNamespace, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol);
            }
            Methods = GetMethods.SelectMany(ms => ms.Value).Union(ServiceMethods).Union(SubMethods).Union(ValidateMethods.SelectMany(ms => ms.Value)).ToList();
            foreach (var m in Methods)
            {
                if (m.ParameterList.Parameters.Count == 0)
                {
                    MethodsDependentProperties.Add(m, new List<List<PropertySymbolInfo>>());
                    MethodsDependentPropertiesLast.Add(m, new List<List<PropertySymbolInfo>>());
                }
                else
                {
                    var semanticModel = SemanticModelPerMethods[m];
                    var methodSymbol = MethodSymbolPerMethods[m];
                    var membersVisitor = new GetMembersVisitor(semanticModel, this, methodSymbol, methodSymbol.Parameters[0].Name, serverFxDALInterfacesNamespace, SemanticModelPerMethods, MethodPerMethodSymbols, GetMethods, ExtensionMethods);
                    membersVisitor.Visit(m.Body);
                    MethodsDependentProperties.Add(m, membersVisitor.GetProperties());
                    MethodsDependentPropertiesLast.Add(m, membersVisitor.GetReturnProperties());
                }
            }
        }
        else
            Methods = new List<MethodDeclarationSyntax>();
        AllServiceMethods = ServiceMethods.Union(ValidateMethods.SelectMany(kvp => kvp.Value).Where(m => IsExposedAsService(m))).ToList();
    }

    private void SetUsings(SpecificationsElements.Type type, string dtoNamespace, Func<ITypeSymbol, string> getNamespaceFromTypeSymbol, Func<IMethodSymbol, string> getNamespaceFromMethodSymbol)
    {
        foreach (var semanticModelPerCompilationUnits in SemanticModelPerCompilationUnits)
        {
            var usingVisitor = new UsingVisitor(semanticModelPerCompilationUnits.Value, this, ServerFxSpecificationsNamespace, ServerFxDALInterfacesNamespace, ServerFxServiceInterfacesNamespace, dtoNamespace, type, SpecificationsNamespaces, m => (type != SpecificationsElements.Type.UnitTest ? ! HasContextAsParameter(m) : IsApplicableOnClient(m)) ? MethodAnalizing.Method : MethodAnalizing.None, Usings, false, false, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol);
            usingVisitor.Visit(semanticModelPerCompilationUnits.Key);
        }
    }

    private ConcurrentDictionary<TypeSyntax, TypeSymbol> _typeSymbolPerTypes = new ConcurrentDictionary<TypeSyntax, TypeSymbol>();
    public TypeSymbol GetTypeSymbol(TypeSyntax type, ISemanticModel semanticModel)
    {
        TypeSymbol value;
        if (_typeSymbolPerTypes.TryGetValue(type, out value))
            return value;
        value = semanticModel.GetSymbolInfo(type).Symbol as TypeSymbol;
        if (value != null)
            _typeSymbolPerTypes.TryAdd(type, value);
        return value;
    }

    public bool ReplaceInterface(ref TypeSyntax type, ISemanticModel semanticModel, string defaultEntity = null, bool withInterfaceSpecifications = false)
    {
        try
        {
            var symbol = GetTypeSymbol(type, semanticModel);
            if (symbol == null)
                return false;
            if (symbol.TypeKind == TypeKind.Interface)
            {
                List<string> classes;
                ClassesPerInterfaces.TryGetValue(symbol.ToString(), out classes);
                if (symbol.GetAttributes().Any(a => a.AttributeClass.ToString() == ServerFxSpecificationsNamespace + ".IEntityAttribute")) 
                {
                    if (classes != null && classes.Count == 1)
                    {
                        type = SyntaxFactory.ParseTypeName(classes[0]);
                        return true;
                    }
                    throw new InvalidOperationException();
                }
                if (withInterfaceSpecifications && InterfaceSpecifications != null && InterfaceSpecifications.Any(i => i.ToString() == symbol.ToString()))
                {
                    type = SyntaxFactory.ParseTypeName(symbol.Name + "Specifications");
                    return true;
                }
                if (classes != null)
                {
                    if (classes.Count == 1)
                    {
                        type = SyntaxFactory.ParseTypeName(classes[0]);
                        return true;
                    }
                    if (defaultEntity != null && classes.Any(c => c == defaultEntity))
                    {
                        type = SyntaxFactory.ParseTypeName(defaultEntity);
                        return true;
                    }
                }
            }
            return false;
        }
        catch(Exception)
        {
            return false;
        }
    }
    
    public ISolution Solution { get; private set; }
    public Dictionary<string, List<MethodDeclarationSyntax>> GetMethods { get; private set; }
    public Dictionary<string, List<MethodDeclarationSyntax>> ValidateMethods { get; private set; }
    public List<MethodDeclarationSyntax> ServiceMethods { get; private set; }
    public List<MethodDeclarationSyntax> AllServiceMethods { get; private set; }
    public List<MethodDeclarationSyntax> SubMethods { get; private set; }
    public List<MethodDeclarationSyntax> Methods { get; private set; }
    public Dictionary<string, List<WAQSMetadata>> Metadata { get; private set; } 
    public List<MethodDeclarationSyntax> ExtensionMethods { get; private set; }
    public List<MethodDeclarationSyntax> NonExtensionMethods { get; private set; }
    public List<MethodDeclarationSyntax> NonEntitiesExtensionMethods { get; private set; }
    public List<PropertySymbol> ServiceProperties { get; private set; }
    public Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>> MethodsDependentProperties { get; private set; }
    public Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>> MethodsDependentPropertiesLast { get; private set; }
    public ConcurrentDictionary<MethodDeclarationSyntax, ISemanticModel> SemanticModelPerMethods { get; private set; }
    public ConcurrentDictionary<string, MethodDeclarationSyntax> MethodPerMethodSymbols { get; private set; }
    public ConcurrentDictionary<MethodDeclarationSyntax, MethodSymbol> MethodSymbolPerMethods { get; private set; }
    public Dictionary<string, List<CompilationUnitSyntax>> CompilationUnitPerClass { get; private set; }
    public Dictionary<WAQSMetadata, ISemanticModel> SemanticModelPerMetadata { get; private set; }
    public Dictionary<string, List<string>> Usings { get; private set; }
    public Dictionary<string, List<NamedTypeSymbol>> InterfacesPerClasses { get; private set; }
    public Dictionary<string, List<string>> ClassesPerInterfaces { get; private set; }
    public Dictionary<string, List<NamedTypeSymbol>> ClassTypesPerInterfaces { get; private set; }
    public Dictionary<string, TypeSymbol> TypeSymbols { get; private set; }
    public List<IDocument> Documents { get; private set; }
    public List<CompilationUnitSyntax> CompilationUnitSyntaxes { get; private set; }
    public Dictionary<CompilationUnitSyntax, ISemanticModel> SemanticModelPerCompilationUnits { get; private set; }
    public List<string> SpecificationsNamespaces { get; private set; }
    public List<TypeSymbol> SpecificationsTypes { get; private set; }
    public List<NamedTypeSymbol> InterfaceSpecifications { get; private set; }
    public Dictionary<string, List<MethodDeclarationSyntax>> InterfaceExtensionMethods { get; private set; }

    public MethodSymbol GetAndAddMethodSymbol(MethodDeclarationSyntax method, ISemanticModel semanticModel)
    {
        MethodSymbol methodSymbol;
        if (MethodSymbolPerMethods.TryGetValue(method, out methodSymbol))
            return methodSymbol;
        methodSymbol = (MethodSymbol)semanticModel.GetDeclaredSymbol(method);
        SemanticModelPerMethods.TryAdd(method, semanticModel);
        MethodPerMethodSymbols.TryAdd(methodSymbol.ToString(), method);
        MethodSymbolPerMethods.TryAdd(method, methodSymbol);
        return methodSymbol;
    }

    public IEnumerable<MethodDeclarationSyntax> AllMethods
    {
        get { return ExtensionMethods.Union(NonExtensionMethods); }
    }

    private List<string> _servicePropertiesStrings;
    public List<string> ServicePropertiesStrings 
    { 
        get { return _servicePropertiesStrings ?? (_servicePropertiesStrings = ServiceProperties.Select(sp => sp.ToString()).ToList()); }
    }

    private List<ClassNames> _classes;

    private object _extensionMethodsPerTypesLock = new object();
    private Dictionary<string, List<MethodDeclarationSyntax>> _extensionMethodsPerTypes;
    public Dictionary<string, List<MethodDeclarationSyntax>> ExtensionMethodsPerTypes
    {
        get
        {
            if (_extensionMethodsPerTypes == null)
                lock(_extensionMethodsPerTypesLock)
                {
                    if (_extensionMethodsPerTypes == null)
                    {
                        _extensionMethodsPerTypes = new Dictionary<string, List<MethodDeclarationSyntax>>();
                        foreach (var m in ExtensionMethods)
                        {
                            var methodSymbol = MethodSymbolPerMethods[m];
                            var extensionType = methodSymbol.Parameters[0].Type;
                            var className = new ClassNames { Name = extensionType.Name, FullName = extensionType.ToString() }; // pas si contexte ou service
                            IEnumerable<ClassNames> classesNames;
                            List<NamedTypeSymbol> classes;
                            if (ClassTypesPerInterfaces.TryGetValue(className.FullName, out classes))
                                classesNames = classes.Select(c => new ClassNames { Name = c.Name, FullName = c.ToString() });
                            else
                                classesNames = new ClassNames[] { className };
                            foreach (var @class in classesNames.Intersect(_classes))
                            {
                                List<MethodDeclarationSyntax> methods;
                                if (! _extensionMethodsPerTypes.TryGetValue(@class.Name, out methods))
                                    _extensionMethodsPerTypes.Add(@class.Name, methods = new List<MethodDeclarationSyntax>());
                                methods.Add(m);
                            }                    
                        }
                    }
                }
            return _extensionMethodsPerTypes;
        }
    }

    private object _nonValidationExtensionMethodsPerTypesLock = new object();
    private Dictionary<string, List<MethodDeclarationSyntax>> _nonValidationExtensionMethodsPerTypes;
    public Dictionary<string, List<MethodDeclarationSyntax>> NonValidationExtensionMethodsPerTypes
    {
        get
        {
            if (_nonValidationExtensionMethodsPerTypes == null)
                lock(_nonValidationExtensionMethodsPerTypesLock)
                {
                    if (_nonValidationExtensionMethodsPerTypes == null)
                        _nonValidationExtensionMethodsPerTypes = ExtensionMethodsPerTypes.ToDictionary(ems => ems.Key, ems => 
                        {
                            List<MethodDeclarationSyntax> validateMethods;
                            if (ValidateMethods.TryGetValue(ems.Key, out validateMethods))
                                return ems.Value.Except(validateMethods).ToList();
                            return ems.Value;
                        });
                }
            return _nonValidationExtensionMethodsPerTypes;
        }
    }

    private object _getMethodSymbolsLock = new object();
    private HashSet<MethodSymbol> _getMethodSymbols;
    public HashSet<MethodSymbol> GetMethodsSymbols
    {
        get 
        {
            if (_getMethodSymbols == null)
                lock(_getMethodSymbolsLock)
                {
                    if (_getMethodSymbols == null)
                        _getMethodSymbols = new HashSet<MethodSymbol>(GetMethods.SelectMany(m => m.Value).Select(m => MethodSymbolPerMethods[m]));
                }
            return _getMethodSymbols;
        }
    }

    private object _allValidateMethodsLock = new object();
    private HashSet<MethodDeclarationSyntax> _allValidateMethods;
    public HashSet<MethodDeclarationSyntax> AllValidateMethods
    {
        get 
        {
            if (_allValidateMethods == null)
                lock(_allValidateMethodsLock)
                {
                    if (_allValidateMethods == null)
                        _allValidateMethods = new HashSet<MethodDeclarationSyntax>(ValidateMethods.SelectMany(v => v.Value));
                }
            return _allValidateMethods;
        }
    }

    private object _abstractMethodsLock = new object();
    private HashSet<MethodDeclarationSyntax> _abstractMethods;
    public HashSet<MethodDeclarationSyntax> AbstractMethods
    {
        get 
        {
            if (_abstractMethods == null)
                lock(_abstractMethodsLock)
                {
                    if (_abstractMethods == null)
                        _abstractMethods = new HashSet<MethodDeclarationSyntax>(ExtensionMethods.Where(m => m.AttributeLists.SelectMany(a => a.Attributes).Any(a => SemanticModelPerMethods[m].GetSymbolInfo(a).Symbol.ContainingType.Name == "AbstractAttribute")));
                }
            return _abstractMethods;
        }
    }

    private object _virtualMethodsLock = new object();
    private HashSet<MethodDeclarationSyntax> _virtualMethods;
    public HashSet<MethodDeclarationSyntax> VirtualMethods
    {
        get 
        {
            if (_virtualMethods == null)
                lock(_virtualMethodsLock)
                {
                    if (_virtualMethods == null)
                        _virtualMethods = new HashSet<MethodDeclarationSyntax>(ExtensionMethods.Where(m => m.AttributeLists.SelectMany(a => a.Attributes).Any(a => SemanticModelPerMethods[m].GetSymbolInfo(a).Symbol.ContainingType.Name == "VirtualAttribute")));
                }
            return _virtualMethods;
        }
    }

    private object _overrideMethodsLock = new object();
    private HashSet<MethodDeclarationSyntax> _overrideMethods;
    public HashSet<MethodDeclarationSyntax> OverrideMethods
    {
        get 
        {
            if (_overrideMethods == null)
                lock(_overrideMethodsLock)
                {
                    if (_overrideMethods == null)
                        _overrideMethods = new HashSet<MethodDeclarationSyntax>(ExtensionMethods.Where(m => m.AttributeLists.SelectMany(a => a.Attributes).Any(a => SemanticModelPerMethods[m].GetSymbolInfo(a).Symbol.ContainingType.Name == "OverrideAttribute")));
                }
            return _overrideMethods;
        }
    }

    private object _customMethodsLock = new object();
    private HashSet<MethodDeclarationSyntax> _customMethods;
    public HashSet<MethodDeclarationSyntax> CustomMethods
    {
        get 
        {
            if (_customMethods == null)
                lock(_customMethodsLock)
                {
                    if (_customMethods == null)
                        _customMethods = new HashSet<MethodDeclarationSyntax>(AllMethods.Where(m => m.AttributeLists.SelectMany(a => a.Attributes).Any(a => SemanticModelPerMethods[m].GetSymbolInfo(a).Symbol.ContainingType.Name == "CustomAttribute")));
                }
            return _customMethods;
        }
    }

    private object _validateFuncMethodsLock = new object();
    private HashSet<MethodDeclarationSyntax> _validateFuncMethods;
    public HashSet<MethodDeclarationSyntax> ValidateFuncMethods
    {
        get 
        {
            if (_validateFuncMethods == null)
                lock(_validateFuncMethodsLock)
                {
                    if (_validateFuncMethods == null)
                        _validateFuncMethods = new HashSet<MethodDeclarationSyntax>(AllValidateMethods.Where(m => 
                            {
                                NamedTypeSymbol returnTypeAsNamedTypeSymbol;
                                return (returnTypeAsNamedTypeSymbol = MethodSymbolPerMethods[m].ReturnType as NamedTypeSymbol) != null && returnTypeAsNamedTypeSymbol.ConstructedFrom.ToString() == "System.Func<TResult>";
                            }));
                }
            return _validateFuncMethods;
        }
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _useServiceProperty = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool UseServiceProperty(MethodDeclarationSyntax method)
    {
        bool value;
        if (_useServiceProperty.TryGetValue(method, out value))
            return value;
        value = UseServicePropertyVisitor.UseServiceProperty(method, this);
        _useServiceProperty.TryAdd(method, value);
        return value;
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isApplicableOnClient = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsApplicableOnClient(MethodDeclarationSyntax method)
    {
        bool value;
        if (_isApplicableOnClient.TryGetValue(method, out value))
            return value;
        var semanticModel = SemanticModelPerMethods[method];
        var methodSymbol = MethodSymbolPerMethods[method];
        var unfoundMethods = new List<MethodSymbol>();
        value = ! (IsMarkedAsNotApplicableOnClient(methodSymbol) || ! IsValidatedOnClient(method) && IsValidatedOnServer(method) || UseServiceProperty(method))/* && GetCalledMethods(method, semanticModel, out unfoundMethods).Where(m => ! m.Equals(method)).All(m => IsApplicableOnClient(m)) && ! unfoundMethods.Any(m => IsMarkedAsNotApplicableOnClient(m))*/;
        _isApplicableOnClient.TryAdd(method, value);
        return value;
    }

    private bool IsMarkedAsNotApplicableOnClient(MethodSymbol methodSymbol)
    {
        return methodSymbol.GetAttributes().Any(a => a.AttributeClass.Name == "NotApplicableOnClientAttribute") || HasContextOrServiceAsParameter(methodSymbol);
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isExposedAsService = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsExposedAsService(MethodDeclarationSyntax method)
    {
        bool isExposedAsService;
        if (_isExposedAsService.TryGetValue(method, out isExposedAsService))
            return isExposedAsService;
        var methodSymbol = MethodSymbolPerMethods[method];
        isExposedAsService =  methodSymbol.GetAttributes().Any(a => a.AttributeClass.Name == "ExposeAsServiceAttribute");
        _isExposedAsService.TryAdd(method, isExposedAsService);
        return isExposedAsService;
    }

    private bool IsValidatedOnServer(MethodDeclarationSyntax method)
    {
        if (IsValidateFunc(method))
            return true;
        var semanticModel = SemanticModelPerMethods[method];
        return (HasValidateOnServerAttribute(method)/* || GetCalledMethods(method).Where(m => ! m.Equals(method)).Any(m => ! IsApplicableOnClient(m))*/ || IsExposedAsService(method));
    }

    private bool IsValidatedOnClient(MethodDeclarationSyntax method)
    {
        var methodSymbol = MethodSymbolPerMethods[method];
        return methodSymbol.GetAttributes().Any(a => a.AttributeClass.Name == "ValidateOnClientAttribute") || ! IsValidatedOnServer(method);
    }

    public bool IsValidateFunc(MethodDeclarationSyntax method)
    {
        var methodSymbol = MethodSymbolPerMethods[method];
        NamedTypeSymbol returnTypeAsNamedTypeSymbol;
        return (returnTypeAsNamedTypeSymbol = methodSymbol.ReturnType as NamedTypeSymbol) != null && returnTypeAsNamedTypeSymbol.ConstructedFrom.ToString() == "System.Func<TResult>";
    }

    private bool HasValidateOnServerAttribute(MethodDeclarationSyntax method)
    {
        var methodSymbol = MethodSymbolPerMethods[method];
        return methodSymbol.GetAttributes().Any(a => a.AttributeClass.Name == "ValidateOnServerAttribute");
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isDefineMethod = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsDefineMethod(MethodDeclarationSyntax method, ISemanticModel semanticModel)
    {
        bool isDefineMethod;
        if (_isDefineMethod.TryGetValue(method, out isDefineMethod))
            return isDefineMethod;
        isDefineMethod = IsDefineMethod(GetAndAddMethodSymbol(method, semanticModel));
        _isDefineMethod.TryAdd(method, isDefineMethod);
        return isDefineMethod;
    }
    public bool IsDefineMethod(MethodDeclarationSyntax method, MethodSymbol methodSymbol, ISemanticModel semanticModel)
    {
        bool isDefineMethod;
        if (_isDefineMethod.TryGetValue(method, out isDefineMethod))
            return isDefineMethod;
        isDefineMethod = IsDefineMethod(methodSymbol);
        _isDefineMethod.TryAdd(method, isDefineMethod);
        return isDefineMethod;
    }
    private bool IsDefineMethod(MethodSymbol method)
    {
        return method.IsStatic && method.ReturnsVoid && ! method.Parameters.Any() && Regex.IsMatch(method.Name, "^Define[A-Z]");
    }

    public bool IsGetMethod(MethodDeclarationSyntax node, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace)
    {
        string edmTypeName;
        return IsGetMethod(node, edmxElements, semanticModel, entitiesNamespace, out edmTypeName);
    }
    private bool IsGetMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace)
    {
        string edmTypeName;
        return IsGetMethod(node, method, edmxElements, entitiesNamespace, out edmTypeName);
    }
    public bool IsGetMethod(MethodDeclarationSyntax node, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace, out string edmTypeName, string className = null)
    {
        return IsGetMethod(node, GetAndAddMethodSymbol(node, semanticModel), edmxElements, entitiesNamespace, out edmTypeName, className);
    }
    private bool IsGetMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        string edmTypeName;
        return IsGetMethod(node, method, edmxElements, entitiesNamespace, out edmTypeName, className);
    }
    private ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, Tuple<string, bool>> _isGetMethod = new ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, Tuple<string, bool>>();
    private bool IsGetMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, out string edmTypeName, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        Tuple<string, bool> isGetMethod;
        if (_isGetMethod.TryGetValue(key, out isGetMethod))
        {
            edmTypeName = isGetMethod.Item1;
            return isGetMethod.Item2;
        }
        var value = IsGetMethod(method, edmxElements, entitiesNamespace, out edmTypeName, className);
        _isGetMethod.TryAdd(key, new Tuple<string, bool>(edmTypeName, value));
        return value;
    }
    private bool IsGetMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        string edmTypeName;
        return IsGetMethod(method, edmxElements, entitiesNamespace, out edmTypeName, className);
    }
    private bool IsGetMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, out string edmTypeName, string className = null)
    {
        return IsGetOrValidateMethod(method, edmxElements, entitiesNamespace, out edmTypeName, "^Get[A-Z]", m => ! m.ReturnsVoid, className);
    }
    public bool IsGetMethod(MethodDeclarationSyntax node, IEnumerable<TypeSymbol> types, ISemanticModel semanticModel, string typesNamespace, out string edmTypeName, string className = null)
    {
        return IsGetMethod(node, GetAndAddMethodSymbol(node, semanticModel), types, typesNamespace, out edmTypeName, className);
    }
    private bool IsGetMethod(MethodDeclarationSyntax node, MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, string className = null)
    {
        string typeName;
        return IsGetMethod(node, method, types, typesNamespace, out typeName, className);
    }
    private bool IsGetMethod(MethodDeclarationSyntax node, MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, out string typeName, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        Tuple<string, bool> isGetMethod;
        if (_isGetMethod.TryGetValue(key, out isGetMethod))
        {
            typeName = isGetMethod.Item1;
            return isGetMethod.Item2;
        }
        bool value = IsGetMethod(method, types, typesNamespace, out typeName, className);
        _isGetMethod.TryAdd(key, new Tuple<string, bool>(typeName, value));
        return value;
    }
    private bool IsGetMethod(MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, string className = null)
    {
        string typeName;
        return IsGetMethod(method, types, typesNamespace, out typeName, className);
    }
    private bool IsGetMethod(MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, out string typeName, string className = null)
    {
        return IsGetOrValidateMethod(method, types, typesNamespace, out typeName, "^Get[A-Z]", m => ! m.ReturnsVoid, className);
    }

    private bool IsGetOrValidateMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, out string edmTypeName, string pattern, Predicate<MethodSymbol> additionalPredicate, string className = null)
    {
        return IsGetOrValidateMethod(method, out edmTypeName, pattern, additionalPredicate, () => IsSpecificationMethod(method, edmxElements, entitiesNamespace), methodParameterTypeName => 
            {
                string edmTypeNameValue = null;
                if (edmxElements.EdmTypes.Any(e => string.Concat(entitiesNamespace, ".", edmTypeNameValue = edmxElements.Code.Escape(e)) == methodParameterTypeName))
                    return edmTypeNameValue;
                return null;
            }, className);
    }

    private bool IsGetOrValidateMethod(MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, out string edmTypeName, string pattern, Predicate<MethodSymbol> additionalPredicate, string className = null)
    {
        return IsGetOrValidateMethod(method, out edmTypeName, pattern, additionalPredicate, () => IsSpecificationMethod(method, types, typesNamespace), methodParameterTypeName => 
            {
                var type = types.FirstOrDefault(t => t.ToString() == methodParameterTypeName);
                if (type == null)
                    return null;
                return type.Name;
            });
    }

    private bool IsGetOrValidateMethod(MethodSymbol method, out string edmTypeName, string pattern, Predicate<MethodSymbol> additionalPredicate, Func<bool> isSpecificationMethod, Func<string, string> getClassName, string className = null)
    {
        edmTypeName = null;
        var nonContextParameters = method.Parameters.OfType<ParameterSymbol>().Where(p => ! p.Type.AllInterfaces.Any(i => i.ToString() == ServerFxDALInterfacesNamespace + ".IDataContext"));
        var value = isSpecificationMethod() && Regex.IsMatch(method.Name, pattern) && additionalPredicate(method) && nonContextParameters.Count() == 1 && (className != null || (edmTypeName = getClassName(method.Parameters[0].Type.ToString())) != null) && method.IsExtensionMethod;
        return value;
    }

    private bool IsSpecificationMethod(MethodDeclarationSyntax node, ISemanticModel semanticModel, EdmxElements edmxElements, string entitiesNamespace)
    {
        return IsSpecificationMethod(GetAndAddMethodSymbol(node, semanticModel), edmxElements, entitiesNamespace);
    }
    public bool IsSpecificationMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace)
    {
        return IsSpecificationMethod(method, methodClassName => edmxElements.EdmTypes.Any(e => string.Concat(entitiesNamespace, ".", edmxElements.Code.Escape(e)) == methodClassName));
    }
    public bool IsSpecificationMethod(MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace)
    {
        return IsSpecificationMethod(method, methodClassName => types.Any(t => string.Concat(typesNamespace, ".", t.Name) == methodClassName));
    }
    private bool IsSpecificationMethod(MethodSymbol method, Func<string, bool> isClassMethod)
    {
        if (method.DeclaredAccessibility != RoslynAccessibility.Public)
            return false;
        if (method.IsStatic)
            return true; 
        return isClassMethod(method.ContainingType.ToString());
    }

    public bool IsValidateMethod(MethodDeclarationSyntax node, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace)
    {
        string edmTypeName;
        return IsValidateMethod(node, edmxElements, semanticModel, entitiesNamespace, out edmTypeName);
    }
    private bool IsValidateMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace)
    {
        string edmTypeName;
        return IsValidateMethod(node, method, edmxElements, entitiesNamespace, out edmTypeName);
    }
    public bool IsValidateMethod(MethodDeclarationSyntax node, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace, out string edmTypeName, string className = null)
    {
        return IsValidateMethod(node, GetAndAddMethodSymbol(node, semanticModel), edmxElements, entitiesNamespace, out edmTypeName, className);
    }
    private bool IsValidateMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        string edmTypeName;
        return IsValidateMethod(node, method, edmxElements, entitiesNamespace, out edmTypeName, className);
    }
    private ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, Tuple<string, bool>> _isValidateMethod = new ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, Tuple<string, bool>>();
    private bool IsValidateMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, out string edmTypeName, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        Tuple<string, bool> isValidateMethod;
        if (_isValidateMethod.TryGetValue(key, out isValidateMethod))
        {
            edmTypeName = isValidateMethod.Item1;
            return isValidateMethod.Item2;
        }
        var value = IsValidateMethod(method, edmxElements, entitiesNamespace, out edmTypeName, className);
        _isValidateMethod.TryAdd(key, new Tuple<string, bool>(edmTypeName, value));
        return value;
    }
    private bool IsValidateMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        string edmTypeName;
        return IsValidateMethod(method, edmxElements, entitiesNamespace, out edmTypeName, className);
    }
    private bool IsValidateMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, out string edmTypeName, string className = null)
    {
        return IsGetOrValidateMethod(method, edmxElements, entitiesNamespace, out edmTypeName, "^Validate[A-Z]", m => m.ReturnType.ToString() == ServerFxServiceInterfacesNamespace + ".Error" || m.ReturnType.ToString() == string.Concat("System.Func<", ServerFxServiceInterfacesNamespace, ".Error>"), className);
    }
    public bool IsValidateMethod(MethodDeclarationSyntax node, IEnumerable<TypeSymbol> types, ISemanticModel semanticModel, string typesNamespace, string className = null)
    {
        string edmTypeName;
        return IsValidateMethod(node, GetAndAddMethodSymbol(node, semanticModel), types, typesNamespace, out edmTypeName, className);
    }
    public bool IsValidateMethod(MethodDeclarationSyntax node, IEnumerable<TypeSymbol> types, ISemanticModel semanticModel, string typesNamespace, out string edmTypeName, string className = null)
    {
        return IsValidateMethod(node, GetAndAddMethodSymbol(node, semanticModel), types, typesNamespace, out edmTypeName, className);
    }
    private bool IsValidateMethod(MethodDeclarationSyntax node, MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, string className = null)
    {
        string typeName;
        return IsValidateMethod(node, method, types, typesNamespace, out typeName, className);
    }
    private bool IsValidateMethod(MethodDeclarationSyntax node, MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, out string edmTypeName, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        Tuple<string, bool> isValidateMethod;
        if (_isValidateMethod.TryGetValue(key, out isValidateMethod))
        {
            edmTypeName = isValidateMethod.Item1;
            return isValidateMethod.Item2;
        }
        var value = IsValidateMethod(method, types, typesNamespace, out edmTypeName, className = null);
        _isValidateMethod.TryAdd(key, new Tuple<string, bool>(edmTypeName, value));
        return value;
    }
    private bool IsValidateMethod(MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, string className = null)
    {
        string edmTypeName;
        return IsValidateMethod(method, types, typesNamespace, out edmTypeName, className);
    }
    private bool IsValidateMethod(MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, out string edmTypeName, string className = null)
    {
        return IsGetOrValidateMethod(method, types, typesNamespace, out edmTypeName, "^Validate[A-Z]", m => m.ReturnType.ToString() == ServerFxServiceInterfacesNamespace + ".Error" || m.ReturnType.ToString() == string.Concat("System.Func<", ServerFxServiceInterfacesNamespace, ".Error>"), className);
    }

    public bool IsServiceMethod(MethodDeclarationSyntax node, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace, string className = null)
    {
        return IsServiceMethod(node, GetAndAddMethodSymbol(node, semanticModel), edmxElements, entitiesNamespace, className);
    }
    private ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool> _isServiceMethod = new ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool>();
    private bool IsServiceMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        bool isServiceMethod;
        if (_isServiceMethod.TryGetValue(key, out isServiceMethod))
            return isServiceMethod;
        isServiceMethod = IsServiceMethod(method, edmxElements, entitiesNamespace, className);
        _isServiceMethod.TryAdd(key, isServiceMethod);
        return isServiceMethod;
    }
    private bool IsServiceMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        return IsSpecificationMethod(method, edmxElements, entitiesNamespace) && ! (IsGetMethod(method, edmxElements, entitiesNamespace, className) || IsValidateMethod(method, edmxElements, entitiesNamespace, className) || IsDefineMethod(method));
    }
    public bool IsServiceMethod(MethodDeclarationSyntax node, IEnumerable<TypeSymbol> types, ISemanticModel semanticModel, string typesNamespace, string className = null)
    {
        return IsServiceMethod(node, GetAndAddMethodSymbol(node, semanticModel), types, typesNamespace, className);
    }
    private bool IsServiceMethod(MethodDeclarationSyntax node, MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        bool isServiceMethod;
        if (_isServiceMethod.TryGetValue(key, out isServiceMethod))
            return isServiceMethod;
        isServiceMethod = IsServiceMethod(method, types, typesNamespace, className);
        _isServiceMethod.TryAdd(key, isServiceMethod);
        return isServiceMethod;
    }
    private bool IsServiceMethod(MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, string className = null)
    {
        return IsSpecificationMethod(method, types, typesNamespace) && ! (IsGetMethod(method, types, typesNamespace, className) || IsValidateMethod(method, types, typesNamespace, className));
    }

    public bool IsSubMethod(MethodDeclarationSyntax node, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace, string className = null)
    {
        return IsSubMethod(node, GetAndAddMethodSymbol(node, semanticModel), edmxElements, entitiesNamespace);
    }
    private ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool> _isSubMethod = new ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool>();
    private bool IsSubMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        bool isSubMethod;
        if (_isSubMethod.TryGetValue(key, out isSubMethod))
            return isSubMethod;
        isSubMethod = IsSubMethod(method, edmxElements, entitiesNamespace, className);
        _isSubMethod.TryAdd(key, isSubMethod);
        return isSubMethod;
    }
    private bool IsSubMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        return ! IsSpecificationMethod(method, edmxElements, entitiesNamespace);
    }
    public bool IsSubMethod(MethodDeclarationSyntax node, IEnumerable<TypeSymbol> types, ISemanticModel semanticModel, string typesNamespace, string className = null)
    {
        return IsSubMethod(node, GetAndAddMethodSymbol(node, semanticModel), types, typesNamespace, className);
    }
    private bool IsSubMethod(MethodDeclarationSyntax node, MethodSymbol method, IEnumerable<TypeSymbol> edmTypes, string typesNamespace, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        bool isSubMethod;
        if (_isSubMethod.TryGetValue(key, out isSubMethod))
            return isSubMethod;
        isSubMethod = IsSubMethod(method, edmTypes, typesNamespace, className);
        _isSubMethod.TryAdd(key, isSubMethod);
        return isSubMethod;
    }
    private bool IsSubMethod(MethodSymbol method, IEnumerable<TypeSymbol> edmTypes, string typesNamespace, string className = null)
    {
        return ! (IsSpecificationMethod(method, edmTypes, typesNamespace) || IsDefineMethod(method));
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, List<MethodWithDepth>> _overridenMethods = new ConcurrentDictionary<MethodDeclarationSyntax, List<MethodWithDepth>>();
    public IEnumerable<MethodWithDepth> GetOverridenMethods(MethodDeclarationSyntax method)
    {
        return GetOverridenMethods(method, MethodSymbolPerMethods[method]);
    }
    public IEnumerable<MethodWithDepth> GetOverridenMethods(MethodDeclarationSyntax method, MethodSymbol methodSymbol)
    {
        List<MethodWithDepth> value;
        if (_overridenMethods.TryGetValue(method, out value))
            return value;
        value = new List<MethodWithDepth>();
        string methodSymbolFirstParameterTypeName = methodSymbol.Parameters[0].Type.ToString();
        foreach (var m in ExtensionMethods)
        {
            var mSemanticModel = SemanticModelPerMethods[m];
            MethodSymbol mSymbol;
            if (! (OverrideMethods.Contains(m) && methodSymbol.Name == (mSymbol = MethodSymbolPerMethods[m]).Name && methodSymbol.Parameters.OfType<ParameterSymbol>().Count() == mSymbol.Parameters.OfType<ParameterSymbol>().Count()))
                continue;
            var parameterType = mSymbol.Parameters[0].Type;
            bool ok = false;
            int depth = 1;
            while (parameterType.BaseType != null)
            {
                if (parameterType.ToString() == methodSymbolFirstParameterTypeName)
                {
                    ok = true;
                    break;
                }
                depth ++;
                parameterType = parameterType.BaseType;
            }
            if (! ok)
                continue;
            int parametersCount = methodSymbol.Parameters.OfType<ParameterSymbol>().Count(); 
            for (int i = 1 ; i < parametersCount ; i ++)
                if (mSymbol.Parameters[i].Type.ToString() != methodSymbol.Parameters[i].Type.ToString())
                    continue;
            value.Add(new MethodWithDepth { Method = mSymbol, Depth = depth });
        }
        _overridenMethods.TryAdd(method, value);
        return value;
    }

    public class MethodWithDepth
    {
        public static MethodWithDepth Get(Dictionary<string, object> cache)
        {
            return new MethodWithDepth { Method = (MethodSymbol)cache["Method"], Depth = (int)cache["Depth"] };
        }

        public Dictionary<string, object> ToCache()
        {
            return new Dictionary<string, object>() 
                {
                    { "Method", Method },
                    { "Depth", Depth }
                };
        }

        public MethodSymbol Method { get; set; }
        public int Depth { get; set; }
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isModeOnInsert = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsModeOnInsert(MethodDeclarationSyntax method, ISemanticModel semanticModel)
    {
        bool isModeOnInsert;
        if (_isModeOnInsert.TryGetValue(method, out isModeOnInsert))
            return isModeOnInsert;
        isModeOnInsert = IsMode(method, semanticModel, "OnInsert");
        _isModeOnInsert.TryAdd(method, isModeOnInsert);
        return isModeOnInsert;
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isModeOnUpdate = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsModeOnUpdate(MethodDeclarationSyntax method, ISemanticModel semanticModel)
    {
        bool isModeOnUpdate;
        if (_isModeOnUpdate.TryGetValue(method, out isModeOnUpdate))
            return isModeOnUpdate;
        isModeOnUpdate = IsMode(method, semanticModel, "OnUpdate");
        _isModeOnUpdate.TryAdd(method, isModeOnUpdate);
        return isModeOnUpdate;
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isModeOnDelete = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsModeOnDelete(MethodDeclarationSyntax method, ISemanticModel semanticModel)
    {
        bool isModeOnDelete;
        if (_isModeOnDelete.TryGetValue(method, out isModeOnDelete))
            return isModeOnDelete;
        isModeOnDelete = IsMode(method, semanticModel, "OnDelete");
        _isModeOnDelete.TryAdd(method, isModeOnDelete);
        return isModeOnDelete;
    }

    private bool IsMode(MethodDeclarationSyntax method, ISemanticModel semanticModel, string mode)
    {
        return method.AttributeLists != null && method.AttributeLists.Any(al => al.Attributes.Any(a => a.ArgumentList != null && a.ArgumentList.Arguments.Any(ar => new PartialValidationMode(semanticModel, ServerFxSpecificationsNamespace, mode).Visit(ar))));
    }

    class PartialValidationMode : SyntaxVisitorOfBool
    {
        private ISemanticModel _semanticModel;
        private string _serverFxSpecificationsNamespace;
        private string _mode;

        public PartialValidationMode(ISemanticModel semanticModel, string serverFxSpecificationsNamespace, string mode)
        {
            _semanticModel = semanticModel;
            _serverFxSpecificationsNamespace = serverFxSpecificationsNamespace;
            _mode = mode;
        }

        public override bool Visit(SyntaxNode node)
        {
            return base.Visit(node) || node.ChildNodes().Any(c => Visit(c));
        }

        public override bool VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
        {
            var symbol = _semanticModel.GetSymbolInfo(node).Symbol;
            if (symbol != null && symbol.ToString() == string.Concat(_serverFxSpecificationsNamespace, ".ValidateMode.", _mode))
                return true;
            return base.VisitMemberAccessExpression(node);
        }
    }

    private ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool> _isValidatableOnInsertOutsideTransaction = new ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool>();
    public bool IsValidatableOnInsertOutsideTransaction(MethodDeclarationSyntax method, StructuralType edmType, EdmxElements edmxElements, bool withNotInTransactionMethods = true)
    {
        bool isValidatableOnInsertOutsideTransaction;
        if (_isValidatableOnInsertOutsideTransaction.TryGetValue(new Tuple<MethodDeclarationSyntax, bool>(method, withNotInTransactionMethods), out isValidatableOnInsertOutsideTransaction))
            return isValidatableOnInsertOutsideTransaction;
        var entityType = edmType as EntityType;
        bool isTransactionalMethod = false;
        isValidatableOnInsertOutsideTransaction = ! IsValidateFunc(method) && (withNotInTransactionMethods && ! IsValidatedInTransaction(method, entityType, edmxElements) || entityType != null && GetDependentNavigationProperties(method, entityType, edmxElements).All(np => 
            {
                isTransactionalMethod = true;
                return np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many;
            }) && isTransactionalMethod);
        _isValidatableOnInsertOutsideTransaction.TryAdd(new Tuple<MethodDeclarationSyntax, bool>(method, withNotInTransactionMethods), isValidatableOnInsertOutsideTransaction);
        return isValidatableOnInsertOutsideTransaction;
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isCriticityError = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsCriticityError(MethodDeclarationSyntax method, ISemanticModel semanticModel)
    {
        bool isCriticityError;
        if (_isCriticityError.TryGetValue(method, out isCriticityError))
            return isCriticityError;
        isCriticityError = new IsCriticityErrorVisitor(semanticModel, this, ServerFxServiceInterfacesNamespace).Visit(method);
        _isCriticityError.TryAdd(method, isCriticityError);
        return isCriticityError;
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isValidatedInTransaction = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsValidatedInTransaction(MethodDeclarationSyntax method, StructuralType edmType, EdmxElements edmxElements)
    {
        bool isValidatedInTransaction;
        if (_isValidatedInTransaction.TryGetValue(method, out isValidatedInTransaction))
            return isValidatedInTransaction;
        if (IsValidateFunc(method))
            return true;
        var entityType = edmType as EntityType;
        isValidatedInTransaction = ! (HasValidateOnServerAttribute(method) || entityType == null) && GetDependentNavigationProperties(method, entityType, edmxElements).Any();
        _isValidatedInTransaction.TryAdd(method, isValidatedInTransaction);
        return isValidatedInTransaction;
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, List<NavigationProperty>> _dependentNavigationProperties = new ConcurrentDictionary<MethodDeclarationSyntax, List<NavigationProperty>>();
    public IEnumerable<NavigationProperty> GetDependentNavigationProperties(MethodDeclarationSyntax method, EntityType entityType, EdmxElements edmxElements) 
    {
        List<NavigationProperty> dependentNavigationProperties;
        if (_dependentNavigationProperties.TryGetValue(method, out dependentNavigationProperties))
            return dependentNavigationProperties;
        List<List<PropertySymbolInfo>> pss;
        if (MethodsDependentProperties.TryGetValue(method, out pss) && pss != null)
        {
            dependentNavigationProperties = pss.Where(ps => edmxElements.Code.Escape(entityType) == ps[0].ContainingType.Name).Select(ps => entityType.NavigationProperties.FirstOrDefault(np => edmxElements.Code.Escape(np) == ps[0].Name)).Where(np => np != null).ToList();
            _dependentNavigationProperties.TryAdd(method, dependentNavigationProperties);
            return dependentNavigationProperties;
        }
        dependentNavigationProperties = new List<NavigationProperty>();
        _dependentNavigationProperties.TryAdd(method, dependentNavigationProperties);
        return dependentNavigationProperties;
    }

    public bool GetSpecificationEquivalentMethod(ref MethodSymbol methodSymbol, List<TypeSymbol> argumentTypes = null)
    {
        var methodSymbolInitial = methodSymbol;
        return GetSpecificationEquivalentMethod(ref methodSymbol, () => 
            {
                List<MethodDeclarationSyntax> candidatesMethods = null;
                // Fix Roslyn BUG
                var displayParts = methodSymbolInitial.ToDisplayParts();
                int methodNameIndex = -1;
                int methodNameLoopIndex = 0;
                foreach (var dp in displayParts)
                {
                    if (dp.ToString() == methodSymbolInitial.Name)
                    {
                        methodNameIndex = methodNameLoopIndex;
                        break;
                    }
                    methodNameLoopIndex ++;
                }
                if (methodNameIndex == -1)
                    return null;
                string entityName = displayParts[methodNameIndex - 2].ToString();
                var typeNameSB = new StringBuilder();
                for (int partIndex = 0 ; partIndex < methodNameIndex - 1 ; partIndex ++)
                    typeNameSB.Append(displayParts[partIndex]);
                List<string> interfaceEntitiesName;
                if (ClassesPerInterfaces.TryGetValue(typeNameSB.ToString(), out interfaceEntitiesName))
                {
                    if (interfaceEntitiesName.Count != 1)
                    {
                        if (argumentTypes != null)
                            interfaceEntitiesName = new List<string>() { argumentTypes[0].Name };
                        else
                            throw new NotImplementedException();
                    }
                    entityName = interfaceEntitiesName[0];
                }
                GetMethods.TryGetValue(entityName, out candidatesMethods);
                if (candidatesMethods == null)
                    return null;
                return candidatesMethods.Where(m => m.Identifier.ValueText == methodSymbolInitial.Name);
            });
    }

    public bool GetSpecificationEquivalentMethod(ref MethodSymbol methodSymbol, Func<IEnumerable<MethodDeclarationSyntax>> getMethods)
    {
        return GetSpecificationEquivalentMethod(ref methodSymbol, getMethods());
    }

    private ConcurrentDictionary<MethodSymbol, MethodSymbol> _equivalentMethods = new ConcurrentDictionary<MethodSymbol, MethodSymbol>();
    public bool GetSpecificationEquivalentMethod(ref MethodSymbol methodSymbol, IEnumerable<MethodDeclarationSyntax> candidatesMethods, string defaultClassName = null)
    {
        MethodSymbol value;
        if (_equivalentMethods.TryGetValue(methodSymbol, out value))
        {
            methodSymbol = value;
            return true;
        }
        if (! methodSymbol.IsStatic)
        {
            if (candidatesMethods != null)
            {
                MethodSymbol candidateMethodSymbolValue = null;
                foreach (var candidateMethod in candidatesMethods)
                {
                    if (candidateMethod.Identifier.ValueText != methodSymbol.Name || candidateMethod.ParameterList.Parameters.Count != methodSymbol.Parameters.OfType<ParameterSymbol>().Count() + 1)
                        continue;
                    var candidateMethodSymbol = MethodSymbolPerMethods[candidateMethod];
                    List<NamedTypeSymbol> typesName;
                    var parameterType = candidateMethodSymbol.Parameters[0].Type;
                    if (ClassTypesPerInterfaces.TryGetValue(parameterType.ToString(), out typesName))
                    {
                        if (typesName.Count == 1)
                            parameterType = typesName[0];
                        else if (defaultClassName == null)
                            return false;
                        else
                        {
                            typesName = typesName.Where(tn => tn.Name == defaultClassName).ToList();
                            if (typesName.Count == 1)
                                parameterType = typesName[0];
                            else
                                return false;
                        }
                    }
                    List<NamedTypeSymbol> parameterTypeInterfaces;
                    var methodSignature = methodSymbol.ToString();
                    var methodSymbolName = methodSymbol.Name;
                    if (! (methodSignature.StartsWith(string.Concat(parameterType.ToString(), ".", methodSymbolName)) || InterfacesPerClasses.TryGetValue(parameterType.Name, out parameterTypeInterfaces) && parameterTypeInterfaces.Any(tn => methodSignature.StartsWith(string.Concat(tn.ToString(), ".", methodSymbolName)))))
                        continue;
                    int parametersCount = methodSymbol.Parameters.OfType<ParameterSymbol>().Count();
                    for (int parameterIndex = 0 ; parameterIndex < parametersCount ; )
                        if (methodSymbol.Parameters[parameterIndex++].Type.ToString() != candidateMethodSymbol.Parameters[parameterIndex].Type.ToString())
                            goto fail;
                    candidateMethodSymbolValue = candidateMethodSymbol;
                    break;
        fail:;
                }
                if (candidateMethodSymbolValue != null)
                {
                    if (candidateMethodSymbolValue != null)
                        _equivalentMethods.TryAdd(methodSymbol, candidateMethodSymbolValue);
                    methodSymbol = candidateMethodSymbolValue;
                    return true;
                }
            }
            var methodSymbolValue = methodSymbol;
            if (Methods != null && Methods.Any(m => m.Identifier.ValueText == methodSymbolValue.Name))
            {
                var newMethodSymbol = (MethodSymbol)FindSourceDefinition(methodSymbol, Solution);
                if (newMethodSymbol != null && newMethodSymbol.IsStatic)
                {
                    if (newMethodSymbol.IsStatic)
                    {
                        if (newMethodSymbol != null)
                            _equivalentMethods.TryAdd(methodSymbol, newMethodSymbol);
                        methodSymbol = newMethodSymbol;
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public bool IsContext(ITypeSymbol type)
    {
        return type.AllInterfaces.Any(i => i.ToString() == ServerFxDALInterfacesNamespace + ".IDataContext");
    }

    public bool IsService(ITypeSymbol type)
    {
        return type.AllInterfaces.Any(i => i.ToString() == ServerFxServiceInterfacesNamespace + ".IService");
    }

    public bool IsContextOrService(ITypeSymbol type)
    {
        return type.AllInterfaces.Any(i => 
            {
                var interfaceString = i.ToString();
                return interfaceString == ServerFxDALInterfacesNamespace + ".IDataContext" || interfaceString == ServerFxServiceInterfacesNamespace + ".IService";
            });
    }

    public bool HasContextAsParameter(MethodDeclarationSyntax method)
    {
        return HasContextAsParameter(MethodSymbolPerMethods[method]);
    }

    public bool HasContextOrServiceAsParameter(MethodDeclarationSyntax method)
    {
        return HasContextOrServiceAsParameter(MethodSymbolPerMethods[method]);
    }

    public bool HasContextAsParameter(MethodSymbol method)
    {
        return method.Parameters.Any(p => IsContext(p.Type));
    }

    public bool HasContextOrServiceAsParameter(MethodSymbol method)
    {
        return method.Parameters.Any(p => IsContextOrService(p.Type));
    }

    private bool HasServiceAsParameter(MethodSymbol method)
    {
        return method.Parameters.Any(p => IsService(p.Type));
    }

    private IEnumerable<ParameterSyntax> GetParametersWithoutContext(MethodDeclarationSyntax method, out bool hasContext, out string contextName)
    {
        return GetParametersWithoutContext(method, method.ParameterList.Parameters, out hasContext, out contextName);
    }

    private IEnumerable<ParameterSyntax> GetParametersWithoutContext(MethodDeclarationSyntax method, IEnumerable<ParameterSyntax> parameters, out bool hasContext, out string contextName, Func<ParameterSyntax, ParameterSyntax> transformParameter = null)
    {
        var methodSymbol = MethodSymbolPerMethods[method];
        bool hasContextLambda = false;
        string contextNameLambda = null;
        var value = parameters
            .Where(p => 
                {
                    var pSymbol = methodSymbol.Parameters.First(p2 => p2.Name == p.Identifier.ValueText);
                    if (IsContext(pSymbol.Type))
                    {
                        hasContextLambda = true;
                        contextNameLambda = pSymbol.Name;
                        return false;
                    }
                    else
                        return true;
                })
            .Select(p => transformParameter == null ? SyntaxFactory.Parameter(p.Identifier).WithType(p.Type) : transformParameter(p)).ToList();
        hasContext = hasContextLambda;
        contextName = contextNameLambda;
        return value;
    }

    public IEnumerable<ParameterSyntax> GetParametersWithoutContextAndService(MethodDeclarationSyntax method, IEnumerable<ParameterSyntax> parameters, IEnumerable<TypeSymbol> dtoTypes, out bool hasContext, out string contextName, out bool hasService, out string serviceName, Dictionary<string, string>  namespacesReplacement, Func<ParameterSyntax, ParameterSyntax> transformParameter = null)
    {
        var methodSymbol = MethodSymbolPerMethods[method];
        var semanticModel = SemanticModelPerMethods[method];
        bool hasContextLambda = false;
        string contextNameLambda = null;
        bool hasServiceLambda = false;
        string serviceNameLambda = null;
        var value = parameters
            .Where(p => 
                {
                    var pSymbol = methodSymbol.Parameters.First(p2 => p2.Name == p.Identifier.ValueText);
                    if (IsContext(pSymbol.Type))
                    {
                        hasContextLambda = true;
                        contextNameLambda = pSymbol.Name;
                        return false;
                    }
                    if (IsService(pSymbol.Type))
                    {
                        hasServiceLambda = true;
                        serviceNameLambda = pSymbol.Name;
                        return false;
                    }
                    return true;
                })
            .Select(p => transformParameter == null ? SyntaxFactory.Parameter(p.Identifier).WithType((TypeSyntax)new DTOAndInterfacesTypesRewriter(semanticModel, this, dtoTypes, namespacesReplacement).Visit(p.Type)).WithDefault(p.Default) : transformParameter(p)).ToList();
        hasContext = hasContextLambda;
        contextName = contextNameLambda;
        hasService = hasServiceLambda;
        serviceName = serviceNameLambda;
        return value;
    }

    private ParameterListSyntax GetParameterListWithoutContext(MethodDeclarationSyntax method, ParameterListSyntax parameterList, out string contextName)
    {
        bool hasContext;
        var parameters = GetParametersWithoutContext(method, parameterList.Parameters, out hasContext, out contextName);
        return SyntaxFactory.ParameterList(SyntaxFactory.SeparatedList(parameters, parameters.Skip(1).Select(v => SyntaxFactory.Token(SyntaxKind.CommaToken))));
    }

    private IEnumerable<ParameterSyntax> GetParametersWithoutContext(MethodDeclarationSyntax method, out bool hasContext)
    {
        string contextName;
        return GetParametersWithoutContext(method, method.ParameterList.Parameters, out hasContext, out contextName);
    }

    public void GetParametersWithoutContextTransformInterfaces(MethodDeclarationSyntax method, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName, out bool useOtherService, string entitiesNamespace, string defaultEntity = null)
    {
        List<string> parameterTypesList;
        GetParametersWithoutContext(method, out parameterTypesList, out parameterTypes, out parameterNames, out hasContext, out contextParameterName, out useOtherService, entitiesNamespace, defaultEntity);
    }
    private void GetParametersWithoutContextTransformInterfaces(MethodDeclarationSyntax method, out List<string> parameterTypesList, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName, out bool useOtherService, string entitiesNamespace, string defaultEntity = null)
    {
        GetParametersWithoutContext(method, out parameterTypesList, out parameterTypes, out parameterNames, out hasContext, out contextParameterName, out useOtherService, entitiesNamespace, defaultEntity);
    }
    public void GetParametersWithoutContextTransformInterfaces(MethodDeclarationSyntax method, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName, string entitiesNamespace, string defaultEntity = null)
    {
        List<string> parameterTypesList;
        bool useOtherService;
        GetParametersWithoutContext(method, out parameterTypesList, out parameterTypes, out parameterNames, out hasContext, out contextParameterName, out useOtherService, entitiesNamespace, defaultEntity);
    }
    public void GetParametersWithoutContextTransformInterfaces(MethodDeclarationSyntax method, out List<string> parameterTypesList, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName, string entitiesNamespace, string defaultEntity = null)
    {
        bool useOtherService;
        GetParametersWithoutContext(method, out parameterTypesList, out parameterTypes, out parameterNames, out hasContext, out contextParameterName, out useOtherService, entitiesNamespace, defaultEntity);
    }
    private void GetParametersWithoutContext(MethodDeclarationSyntax method, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName)
    {
        bool useOtherService;
        List<string> parameterTypesList;
        GetParametersWithoutContext(method, out parameterTypesList, out parameterTypes, out parameterNames, out hasContext, out contextParameterName, out useOtherService, null, null);
    }
    private void GetParametersWithoutContext(MethodDeclarationSyntax method, out List<string> parameterTypesList, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName)
    {
        bool useOtherService;
        GetParametersWithoutContext(method, out parameterTypesList, out parameterTypes, out parameterNames, out hasContext, out contextParameterName, out useOtherService, null, null);
    }
    private void GetParametersWithoutContext(MethodDeclarationSyntax method, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName, out bool useOtherService, string entitiesNamespace, string defaultEntity = null)
    {
        List<string> parameterTypesList;
        GetParametersWithoutContext(method, out parameterTypesList, out parameterTypes, out parameterNames, out hasContext, out contextParameterName, out useOtherService, entitiesNamespace, defaultEntity);
    }
    private void GetParametersWithoutContext(MethodDeclarationSyntax method, out List<string> parameterTypesList, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName, out bool useOtherService, string entitiesNamespace, string defaultEntity = null)
    {
        var semanticModel = SemanticModelPerMethods[method];
        parameterTypesList = new List<string>();
        hasContext = false;
        contextParameterName = null;
        bool hasContextValue = false;
        string contextParameterNameValue = null;
        var methodSymbol = MethodSymbolPerMethods[method];
        var parameters = methodSymbol.Parameters.OfType<ParameterSymbol>().Where(p => 
            {
                if (IsContext(p.Type))
                {
                    hasContextValue = true;
                    contextParameterNameValue = p.Name;
                    return false;
                }
                return true;
            }).ToList();
        hasContext = hasContextValue;
        contextParameterName = contextParameterNameValue;
        useOtherService = new UseServiceVisitor(semanticModel, ServicePropertiesStrings).Visit(method.Body);
        parameterTypes = new StringBuilder();
        parameterNames = new StringBuilder();
        var parametersEnumerator = parameters.GetEnumerator();
        var syntaxParametersEnumerator = method.ParameterList.Parameters.GetEnumerator();
        if (parametersEnumerator.MoveNext() && syntaxParametersEnumerator.MoveNext())
        {
            parameterTypes.Append(GetTypeString(syntaxParametersEnumerator.Current.Type, semanticModel, parametersEnumerator.Current.Type, entitiesNamespace, defaultEntity));
            parameterNames.Append(parametersEnumerator.Current.Name);
            while (parametersEnumerator.MoveNext() && syntaxParametersEnumerator.MoveNext())
            {
                parameterTypes.Append(", ");
                var typeName = GetTypeString(syntaxParametersEnumerator.Current.Type, semanticModel, parametersEnumerator.Current.Type, entitiesNamespace, defaultEntity);
                parameterTypesList.Add(typeName);
                parameterTypes.Append(typeName);
                parameterNames.Append(", ");
                parameterNames.Append(parametersEnumerator.Current.Name);
            }
        }
    }

    public string GetTypeString(TypeSyntax type, ISemanticModel semanticModel, TypeSymbol typeSymbol, string entitiesNamespace, string defaultEntity = null)
    {
        var value = typeSymbol.ToString();
        var newType = new TypeRewriter(semanticModel, ns =>
            {
                var t = (TypeSyntax)ns;
                ReplaceInterface(ref t, semanticModel, defaultEntity);
                return (NameSyntax)t;
            }).Visit(type);
        if (newType != type)
            return newType.NormalizeWhitespace().ToString();
        return value;
    }

    public string ServerFxDALInterfacesNamespace { get; set; }
    public string ServerFxServiceInterfacesNamespace { get; set; }
    public string ServerFxSpecificationsNamespace { get; set; }
}

public struct ClassNames
{
    public static ClassNames Get(Dictionary<string, object> cache)
    {
        return new ClassNames { Name = (string)cache["Name"], FullName = (string)cache["FullName"] };
    }
    public Dictionary<string, object> ToCache()
    {
        return new Dictionary<string, object>() { {"Name", Name}, {"FullName", FullName} };
    }

    public string Name { get; set; }
    public string FullName { get; set; }
}

public static EdmType GetBaseTypeWithExtensionMethods(EdmType edmType, SpecificationsElements specificationsElements, CodeGenerationTools code, string serverEntitiesNamespace)
{
    var baseType = edmType.BaseType;
    var baseTypeLoop = baseType;
    while (baseTypeLoop != null)
    {
        foreach (var method in specificationsElements.Methods)
        {
            var methodSymbol = specificationsElements.MethodSymbolPerMethods[method];
            if (methodSymbol.IsExtensionMethod && methodSymbol.Parameters[0].Type.ToString() == string.Concat(serverEntitiesNamespace, ".", code.Escape(baseTypeLoop)))
                return baseTypeLoop;
        }
        baseTypeLoop = baseTypeLoop.BaseType;
    }
    return null;
}

public IEnumerable<MethodDeclarationSyntax> GetExtensionMethodsPerClass(string className, SpecificationsElements specificationsElements, string serverEntitiesNamespace)
{
    List<MethodDeclarationSyntax> value;
    if (specificationsElements.ExtensionMethodsPerTypes.TryGetValue(className, out value))
        return value;
    return new MethodDeclarationSyntax[0];
}

public class WAQSMetadata
{
    public WAQSMetadata()
    {
    }

    private WAQSMetadata(Dictionary<string, object> cache)
    {
        TypeName = (string)cache["TypeName"];
        TypeSymbol = (TypeSymbol)cache["TypeSymbol"];
        MethodName = (string)cache["MethodName"];
        Property = (string)cache["Property"];
        PropertySymbol = (PropertySymbol)cache["PropertySymbol"];
        LambdaExpression = (SimpleLambdaExpressionSyntax)cache["LambdaExpression"];
        ConstantExpression = (LiteralExpressionSyntax)cache["ConstantExpression"];
        IsOverriden = (bool)cache["IsOverriden"];
        DependentProperties = ((List<List<Dictionary<string, object>>>)cache["DependentProperties"]).Select(ps => ps.Select(p => PropertySymbolInfo.Get(p)).ToList()).ToList();
    }

    public static WAQSMetadata Get(Dictionary<string, object> cache)
    {
        return new WAQSMetadata(cache);
    }

    public Dictionary<string, object> ToCache()
    {
        var value = new Dictionary<string, object>();
        value.Add("TypeName", TypeName);
        value.Add("TypeSymbol", TypeSymbol);
        value.Add("MethodName", MethodName);
        value.Add("Property", Property);
        value.Add("PropertySymbol", PropertySymbol);
        value.Add("LambdaExpression", LambdaExpression);
        value.Add("ConstantExpression", ConstantExpression);
        value.Add("IsOverriden", IsOverriden);
        value.Add("DependentProperties", DependentProperties.Select(ps => ps.Select(p => p.ToCache()).ToList()).ToList());
        value.Add("HashCode", GetHashCode());
        return value;
    }

    public string TypeName { get; set; }
    public TypeSymbol TypeSymbol { get; set; }
    public string MethodName { get; set; }
    public string Property { get; set; }
    public PropertySymbol PropertySymbol { get; set; }
    public SimpleLambdaExpressionSyntax LambdaExpression { get; set; }
    public LiteralExpressionSyntax ConstantExpression { get; set; }
    public bool IsOverriden { get; set; }
    public List<List<PropertySymbolInfo>> DependentProperties { get; set; }
}

public static class TypeSymbolHelper
{
    public static int GetTypeInheritanceDepth(ITypeSymbol type)
    {
        int depth = 0;
        while ((type = type.BaseType) != null)
            depth ++;
        return depth;
    }

    public static bool IsInherited(ITypeSymbol baseType, TypeSymbol inheritedType)
    {
        string baseTypeFullName = baseType.ToString();
        do 
        {
            if (inheritedType.ToString() == baseTypeFullName)
                return true;
        } while ((inheritedType = inheritedType.BaseType) != null);
        return false;
    }
}

public static TypeSymbol GetClassExtensionMethodClass(MethodSymbol methodSymbol, SpecificationsElements specificationsElements, string serverFxSpecificationsNamespace, string serverEntitiesNamespace)
{
    if (! (methodSymbol.IsStatic && methodSymbol.IsExtensionMethod))
        return null;
    var parameterType = methodSymbol.Parameters[0].Type;
    if (parameterType.ContainingNamespace.ToString() == serverEntitiesNamespace)
        return parameterType;
    if (! parameterType.GetAttributes().Any(a => a.ToString() == serverFxSpecificationsNamespace + ".IEntityAttribute"))
        return null;
    return specificationsElements.ClassTypesPerInterfaces[parameterType.ToString()].Single();
}

public static string GetPropertyNameFromMethodName(string methodName)
{
    return SpecificationMethods.GetPropertyNameFromMethodName(methodName);
}

public static string GetPropertyNameFromMethod(MethodDeclarationSyntax method)
{
    return SpecificationMethods.GetPropertyNameFromMethod(method);
}

public class SpecificationMethods
{
    public static string GetPropertyNameFromMethodName(string methodName)
    {
        return Regex.Replace(methodName, "^Get([A-Z])", m => m.Groups[1].Value);
    }

    public static string GetPropertyNameFromMethod(MethodDeclarationSyntax method)
    {
        return GetPropertyNameFromMethodName(method.Identifier.ValueText);
    }
}

abstract class SpecificationVisitor : SyntaxVisitor
{
    protected SpecificationsElements SpecificationsElements { get; set; }
    protected ISemanticModel SemanticModel { get; set; }
    protected string Namespace { get; set; }
    protected bool _proceed;

    public SpecificationVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel, Dictionary<string, List<MethodDeclarationSyntax>> getMethods, Dictionary<string, List<MethodDeclarationSyntax>> validateMethods, Dictionary<string, List<WAQSMetadata>> waqsMetadata, List<MethodDeclarationSyntax> serviceMethods, List<MethodDeclarationSyntax> subMethods, List<MethodDeclarationSyntax> definePropertyDependencesMethods, List<PropertyDeclarationSyntax> serviceProperties, string @namespace)
    {
        SpecificationsElements = specificationsElements;
        SemanticModel = semanticModel;
        GetMethods = getMethods;
        ValidateMethods = validateMethods;
        WAQSMetadata = waqsMetadata;
        ServiceMethods = serviceMethods;
        SubMethods = subMethods;
        DefinePropertyDependencesMethods = definePropertyDependencesMethods;
        ServiceProperties = serviceProperties;
        Namespace = @namespace;
        Namespaces = specificationsElements.SpecificationsNamespaces;
        SpecificationsTypes = specificationsElements.SpecificationsTypes;
    }

    public List<string> Namespaces { get; private set; } 
    public List<TypeSymbol> SpecificationsTypes { get; private set; }
    public Dictionary<string, List<MethodDeclarationSyntax>> GetMethods { get; private set; }
    public Dictionary<string, List<MethodDeclarationSyntax>> ValidateMethods { get; private set; }
    public Dictionary<string, List<WAQSMetadata>> WAQSMetadata { get; private set; } 
    public List<MethodDeclarationSyntax> ServiceMethods { get; private set; }
    public List<MethodDeclarationSyntax> SubMethods { get; private set; }
    public List<MethodDeclarationSyntax> DefinePropertyDependencesMethods { get; private set; }
    public List<PropertyDeclarationSyntax> ServiceProperties { get; private set; }

    protected abstract SpecificationVisitor NewSpecificationVisitor();
    protected abstract bool IsGetMethod(MethodDeclarationSyntax node, string @class, out string className);
    protected abstract bool IsValidateMethod(MethodDeclarationSyntax node, string @class, out string className);
    protected bool IsDefineMethod(MethodDeclarationSyntax node)
    {
        return SpecificationsElements.IsDefineMethod(node, SemanticModel);
    }
    protected abstract bool IsServiceMethod(MethodDeclarationSyntax node, string @class);
    protected abstract bool IsSubMethod(MethodDeclarationSyntax node, string @class);

    public override void Visit(SyntaxNode node)
    {
        base.Visit(node);
        if (!_proceed)
            foreach (var childNode in node.ChildNodes().Where(c => c != null))
                NewSpecificationVisitor().Visit(childNode);
    }

    public override void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
        string name = node.Name.ToString();
        if (! Namespaces.Contains(name))
            Namespaces.Add(name);
        base.VisitNamespaceDeclaration(node);
    }

    public override void VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        VisitTypeDeclaration(node);
        base.VisitClassDeclaration(node);
    }
    public override void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
        VisitTypeDeclaration(node);
        base.VisitInterfaceDeclaration(node);
    }
    public override void VisitStructDeclaration(StructDeclarationSyntax node)
    {
        VisitTypeDeclaration(node);
        base.VisitStructDeclaration(node);
    }
    private void VisitTypeDeclaration(TypeDeclarationSyntax node)
    {
        var typeSymbol = (TypeSymbol)SemanticModel.GetDeclaredSymbol(node);
        if (typeSymbol.GetAttributes().Any(a => a.AttributeClass.ToString() == "System.CodeDom.Compiler.GeneratedCodeAttribute"))
            _proceed = true;
        else
            SpecificationsTypes.Add(typeSymbol);
    }

    public override void VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        if (Regex.IsMatch(node.Identifier.ValueText, @"^Define[^\s]+PropertyDependences$"))
        {
            _proceed = true;
            DefinePropertyDependencesMethods.Add(node);
            return;
        }
        string className = null;
        List<string> classes;
        NamedTypeSymbol namedTypeSymbol;
        if (node.ParameterList.Parameters.Count != 0)
        {
            if (IsGetMethod(node, null, out className))
            {
                AddGetMethods(className, node);
                _proceed = true;
            }
            else if ((namedTypeSymbol = ((ParameterSymbol)SemanticModel.GetDeclaredSymbol(node.ParameterList.Parameters[0])).Type as NamedTypeSymbol) != null && SpecificationsElements.ClassesPerInterfaces.TryGetValue(namedTypeSymbol.ToString(), out classes))
            {
                foreach (var @class in classes)
                    if (IsGetMethod(node, @class, out className))
                    {
                        AddGetMethods(@class, node);
                        _proceed = true;
                    }
            }
            if (_proceed)
                return;
            if (IsValidateMethod(node, null, out className))
            {
                AddValidateMethods(className, node);
                _proceed = true;
            }
            else if ((namedTypeSymbol = ((ParameterSymbol)SemanticModel.GetDeclaredSymbol(node.ParameterList.Parameters[0])).Type as NamedTypeSymbol) != null && SpecificationsElements.ClassesPerInterfaces.TryGetValue(namedTypeSymbol.ToString(), out classes))
            {
                foreach (var @class in classes)
                    if (IsValidateMethod(node, @class, out className))
                    {
                        AddValidateMethods(@class, node);
                        _proceed = true;
                    }
            }
            if (_proceed)
                return;
        }
        if (IsDefineMethod(node))
            foreach (var statement in node.Body.Statements)
            {
                var invocation = (InvocationExpressionSyntax)statement.ChildNodes().Single();
                var invocationMethod = (MethodSymbol)SemanticModel.GetSymbolInfo(invocation).Symbol;
                var type = (invocationMethod.ContainingType).TypeArguments.Single();
                var expression = invocation.ArgumentList.Arguments[1].Expression;
                var property = ((MemberAccessExpressionSyntax)((SimpleLambdaExpressionSyntax)invocation.ArgumentList.Arguments[0].Expression).Body);
                var metadata = new WAQSMetadata { TypeSymbol = type, TypeName = type.Name, MethodName = invocationMethod.Name, Property = property.Name.Identifier.ValueText, PropertySymbol = (PropertySymbol)SemanticModel.GetSymbolInfo(property).Symbol, ConstantExpression = expression as LiteralExpressionSyntax, LambdaExpression = expression as SimpleLambdaExpressionSyntax };
                if (SpecificationsElements.ClassesPerInterfaces.TryGetValue(type.Name, out classes))
                    foreach (var @class in classes)
                    {
                        List<WAQSMetadata> waqsMetadata;
                        if (! WAQSMetadata.TryGetValue(@class, out waqsMetadata))
                            WAQSMetadata.Add(@class, waqsMetadata = new List<WAQSMetadata>());
                        waqsMetadata.Add(metadata);
                    }
                else
                {
                    var typeName = type.Name;
                    List<WAQSMetadata> waqsMetadata;
                    if (! WAQSMetadata.TryGetValue(typeName, out waqsMetadata))
                        WAQSMetadata.Add(typeName, waqsMetadata = new List<WAQSMetadata>());
                    waqsMetadata.Add(metadata);
                }
            }
        else if (IsServiceMethod(node, null))
            ServiceMethods.Add(node);
        else if (IsSubMethod(node, null))
            SubMethods.Add(node);
        else
            throw new NotImplementedException();
        _proceed = true;
    }

    private void AddGetMethods(string edmTypeName, MethodDeclarationSyntax node)
    {
        List<MethodDeclarationSyntax> methods;
        if (!GetMethods.TryGetValue(edmTypeName, out methods))
        {
            methods = new List<MethodDeclarationSyntax>();
            GetMethods.Add(edmTypeName, methods);
        }
        methods.Add(node);
    }

    private void AddValidateMethods(string edmTypeName, MethodDeclarationSyntax node)
    {
        List<MethodDeclarationSyntax> methods;
        if (!ValidateMethods.TryGetValue(edmTypeName, out methods))
        {
            methods = new List<MethodDeclarationSyntax>();
            ValidateMethods.Add(edmTypeName, methods);
        }
        methods.Add(node);
    }

    public override void VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
        ServiceProperties.Add(node);
        _proceed = true;
    }
}

class EntitiesSpecificationVisitor : SpecificationVisitor
{
    private EdmxElements _edmxElements;

    public EntitiesSpecificationVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel, EdmxElements edmxElements, string entitiesNamespace)
        : this(specificationsElements, semanticModel, new Dictionary<string, List<MethodDeclarationSyntax>>(), new Dictionary<string, List<MethodDeclarationSyntax>>(), new Dictionary<string, List<WAQSMetadata>>(), new List<MethodDeclarationSyntax>(), new List<MethodDeclarationSyntax>(), new List<MethodDeclarationSyntax>(), new List<PropertyDeclarationSyntax>(), edmxElements, entitiesNamespace)
    {
    }
    public EntitiesSpecificationVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel, Dictionary<string, List<MethodDeclarationSyntax>> getMethods, Dictionary<string, List<MethodDeclarationSyntax>> validateMethods, Dictionary<string, List<WAQSMetadata>> waqsMetadata, List<MethodDeclarationSyntax> serviceMethods, List<MethodDeclarationSyntax> subMethods, List<MethodDeclarationSyntax> definePropertyDependencesMethods, List<PropertyDeclarationSyntax> serviceProperties, EdmxElements edmxElements, string entitiesNamespace)
        : base(specificationsElements, semanticModel, getMethods, validateMethods, waqsMetadata, serviceMethods, subMethods, definePropertyDependencesMethods, serviceProperties, entitiesNamespace)
    {
        _edmxElements = edmxElements;
    }

    protected override SpecificationVisitor NewSpecificationVisitor()
    {
        return new EntitiesSpecificationVisitor(SpecificationsElements, SemanticModel, GetMethods, ValidateMethods, WAQSMetadata, ServiceMethods, SubMethods, DefinePropertyDependencesMethods, ServiceProperties, _edmxElements, Namespace);
    }

    protected override bool IsGetMethod(MethodDeclarationSyntax node, string @class, out string className)
    {
        return SpecificationsElements.IsGetMethod(node, _edmxElements, SemanticModel, Namespace, out className, @class);
    }

    protected override bool IsValidateMethod(MethodDeclarationSyntax node, string @class, out string className)
    {
        return SpecificationsElements.IsValidateMethod(node, _edmxElements, SemanticModel, Namespace, out className, @class);
    }

    protected override bool IsServiceMethod(MethodDeclarationSyntax node, string @class)
    {
        return SpecificationsElements.IsServiceMethod(node, _edmxElements, SemanticModel, Namespace, @class);
    }

    protected override bool IsSubMethod(MethodDeclarationSyntax node, string @class)
    {
        return SpecificationsElements.IsSubMethod(node, _edmxElements, SemanticModel, Namespace);
    }
}

class DTOSpecificationVisitor : SpecificationVisitor
{
    private IEnumerable<TypeSymbol> _dtoTypes;

    public DTOSpecificationVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel, IEnumerable<TypeSymbol> dtoTypes, string dtoTypesNamespace)
        : this(specificationsElements, semanticModel, new Dictionary<string, List<MethodDeclarationSyntax>>(), new Dictionary<string, List<MethodDeclarationSyntax>>(), new Dictionary<string, List<WAQSMetadata>>(), new List<MethodDeclarationSyntax>(), new List<MethodDeclarationSyntax>(), new List<MethodDeclarationSyntax>(), new List<PropertyDeclarationSyntax>(), dtoTypes, dtoTypesNamespace)
    {
    }
    public DTOSpecificationVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel, Dictionary<string, List<MethodDeclarationSyntax>> getMethods, Dictionary<string, List<MethodDeclarationSyntax>> validateMethods, Dictionary<string, List<WAQSMetadata>> waqsMetadata, List<MethodDeclarationSyntax> serviceMethods, List<MethodDeclarationSyntax> subMethods, List<MethodDeclarationSyntax> definePropertyDependencesMethods, List<PropertyDeclarationSyntax> serviceProperties, IEnumerable<TypeSymbol> dtoTypes, string dtoTypesNamespace)
        : base(specificationsElements, semanticModel, getMethods, validateMethods, waqsMetadata, serviceMethods, subMethods, definePropertyDependencesMethods, serviceProperties, dtoTypesNamespace)
    {
        _dtoTypes = dtoTypes;
    }

    protected override SpecificationVisitor NewSpecificationVisitor()
    {
        return new DTOSpecificationVisitor(SpecificationsElements, SemanticModel, GetMethods, ValidateMethods, WAQSMetadata, ServiceMethods, SubMethods, DefinePropertyDependencesMethods, ServiceProperties, _dtoTypes, Namespace);
    }

    protected override bool IsGetMethod(MethodDeclarationSyntax node, string @class, out string className)
    {
        return SpecificationsElements.IsGetMethod(node, _dtoTypes, SemanticModel, Namespace, out className, @class);
    }

    protected override bool IsValidateMethod(MethodDeclarationSyntax node, string @class, out string className)
    {
        return SpecificationsElements.IsValidateMethod(node, _dtoTypes, SemanticModel, Namespace, out className, @class);
    }

    protected override bool IsServiceMethod(MethodDeclarationSyntax node, string @class)
    {
        return SpecificationsElements.IsServiceMethod(node, _dtoTypes, SemanticModel, Namespace, @class);
    }

    protected override bool IsSubMethod(MethodDeclarationSyntax node, string @class)
    {
        return SpecificationsElements.IsSubMethod(node, _dtoTypes, SemanticModel, Namespace);
    }
}

public class DefinePropertyDependencesMethodVisitor : SyntaxVisitor
{
    private SpecificationsElements _specificationsElements;
    private ISemanticModel _semanticModel;
    private List<PropertySymbolInfo> _currentProperties;
    private bool _proceed;

    public DefinePropertyDependencesMethodVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel)
        : this(specificationsElements, semanticModel, new List<List<PropertySymbolInfo>>())
    {
    }
    public DefinePropertyDependencesMethodVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel, List<List<PropertySymbolInfo>> properties)
    {
        _specificationsElements = specificationsElements;
        _semanticModel = semanticModel;
        Properties = properties;
    }

    public List<List<PropertySymbolInfo>> Properties { get; private set; }

    public override void Visit(SyntaxNode node)
    {
        base.Visit(node);
        if (! _proceed)
            foreach (var childNode in node.ChildNodes())
                Visit(childNode);
    }

    public override void VisitInvocationExpression(InvocationExpressionSyntax node)
    {
        Visit(node.Expression);
        var methodSymbol = (MethodSymbol)_semanticModel.GetSymbolInfo(node).Symbol;
        MethodDeclarationSyntax method;
        if ((methodSymbol.IsStatic || _specificationsElements.GetSpecificationEquivalentMethod(ref methodSymbol)) && _specificationsElements.MethodPerMethodSymbols.TryGetValue(methodSymbol.ToString(), out method))
        {
            var propertySymbolInfo = new PropertySymbolInfo(TypeSymbolInfo.Get(methodSymbol.ReturnType), SpecificationMethods.GetPropertyNameFromMethod(method), TypeSymbolInfo.Get(methodSymbol.Parameters[0].Type), method);
            _currentProperties.Add(propertySymbolInfo);
            Properties.Add(_currentProperties.ToList());
            _proceed = true;
            return;
        }
        var lambda = node.ArgumentList.Arguments[0].Expression as SimpleLambdaExpressionSyntax;
        if (lambda == null)
            throw new NotImplementedException();
        var childDefinePropertyDependencesMethodVisitor = new DefinePropertyDependencesMethodVisitor(_specificationsElements, _semanticModel, Properties);
        childDefinePropertyDependencesMethodVisitor._currentProperties = _currentProperties == null ? new List<PropertySymbolInfo>() : _currentProperties.ToList();
        childDefinePropertyDependencesMethodVisitor.Visit(lambda.Body);
        _proceed = true;
    }

    public override void VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
        var propertySymbol = _semanticModel.GetSymbolInfo(node).Symbol as PropertySymbol;
        if (propertySymbol == null)
        {
            base.VisitMemberAccessExpression(node);
            return;
        }
        Visit(node.Expression);
        var propertySymbolInfo = new PropertySymbolInfo(propertySymbol);
        _currentProperties.Add(propertySymbolInfo);
        Properties.Add(_currentProperties.ToList());
        _proceed = true;
    }
}

string ToExpression(MethodDeclarationSyntax method, SpecificationsElements specificationsElements, Func<SyntaxNode, SyntaxNode> transformNodes, string parameters, out bool isValid)
{
    bool hasLambda;
    return ToExpression(method, specificationsElements, transformNodes, parameters, out isValid, false, out hasLambda);
}
string ToExpression(MethodDeclarationSyntax method, SpecificationsElements specificationsElements, Func<SyntaxNode, SyntaxNode> transformNodes, string parameters, out bool isValid, bool validateMethod, out bool hasLambda)
{
    return ToExpression(method, specificationsElements, (n, _) => transformNodes(n), parameters, out isValid, validateMethod, out hasLambda);
}
string ToExpression(MethodDeclarationSyntax method, SpecificationsElements specificationsElements, Func<SyntaxNode, Func<SyntaxNode, SyntaxNode>, SyntaxNode> transformNodes, string parameters, out bool isValid, bool validateMethod, out bool hasLambda)
{
    var toExpression = new ToExpressionRewriter(specificationsElements.SemanticModelPerMethods[method], specificationsElements, parameters, transformNodes);
    SyntaxNode exp;
    var firstStatement = ((BlockSyntax)toExpression.Visit(method.Body)).Statements[0];
    var body = firstStatement as ReturnStatementSyntax;
    if (body == null)
    {
        hasLambda = false;
        IfStatementSyntax ifStatement;
        if (! validateMethod || (ifStatement = firstStatement as IfStatementSyntax) == null)
        {
            isValid = false;
            return null;
        }
        exp = ifStatement.Condition;
    }
    else
    {
        exp = body.Expression;
        hasLambda = true;
    }
    var value = exp.NormalizeWhitespace().ToString();
    isValid = toExpression.IsValid;
    return value;
}

public class ToExpressionRewriter : SpecificationsRewriter
{
    private ISemanticModel _semanticModel;
    private SpecificationsElements _specificationsElements;
    private string _parameterName;

    public ToExpressionRewriter(ISemanticModel semanticModel, SpecificationsElements specificationsElements, string parameterName, Func<SyntaxNode, Func<SyntaxNode, SyntaxNode>, SyntaxNode> transformNodes)
        : base(transformNodes)
    {
        _semanticModel = semanticModel;
        _specificationsElements = specificationsElements;
        _parameterName = parameterName;
        IsValid = true;
    }

    public bool IsValid { get; private set; }

    public override SyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
    {
        return SyntaxFactory.ParseStatement(string.Concat("return (", _parameterName, ") => ", Visit(node.Expression).NormalizeWhitespace().ToString(), ";"));
    }

    public override SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
    {
        var method = (MethodSymbol)_semanticModel.GetSymbolInfo(node).Symbol;
        if (! (Regex.IsMatch(method.ContainingNamespace.ToString(), "^System(.|$)") || _specificationsElements.MethodPerMethodSymbols.Keys.Any(mp => mp.Equals(method))))
            IsValid = false;
        return base.VisitInvocationExpression(node);
    }
}

public class GetCalledMethodsVisitor : SyntaxVisitorOfIEnumerableOfMethodDeclarationSyntax
{
    private SpecificationsElements _specificationsElements;
    private ISemanticModel _semanticModel;
    private List<MethodDeclarationSyntax> _methods;

    public GetCalledMethodsVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel)
        : this(specificationsElements, semanticModel, new List<MethodDeclarationSyntax>())
    {
    }
    private GetCalledMethodsVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel, List<MethodDeclarationSyntax> methods)
    {
        _specificationsElements = specificationsElements;
        _semanticModel = semanticModel;
        _methods = methods;
        UnfoundMethods = new List<MethodSymbol>();
    }

    public List<MethodSymbol> UnfoundMethods { get; private set; }

    public override IEnumerable<MethodDeclarationSyntax> Visit(SyntaxNode node)
    {
        return (base.Visit(node) ?? new MethodDeclarationSyntax[0]).Union(node.ChildNodes().SelectMany(c => Visit(c)));
    }

    public override IEnumerable<MethodDeclarationSyntax> VisitInvocationExpression(InvocationExpressionSyntax node)
    {
        var methodSymbol = _semanticModel.GetSymbolInfo(node).Symbol as MethodSymbol;
        MethodDeclarationSyntax method;
        if (methodSymbol != null && (methodSymbol.IsStatic || _specificationsElements.GetSpecificationEquivalentMethod(ref methodSymbol)) && _specificationsElements.MethodPerMethodSymbols.TryGetValue(methodSymbol.ToString(), out method) && ! _methods.Contains(method))
        {
            _methods.Add(method);
            yield return method;
            foreach (var m in new GetCalledMethodsVisitor(_specificationsElements, _specificationsElements.SemanticModelPerMethods[method], _methods).Visit(method))
                yield return m;
        }
        else
            UnfoundMethods.Add(methodSymbol);
        var ms = base.VisitInvocationExpression(node);
        if (ms != null)
            foreach (var m in ms)
                yield return m;
    }
}

public class PropertySymbolInfo
{
    private PropertySymbolInfo()
    {
    }

    public PropertySymbolInfo(TypeSymbolInfo type, string name, TypeSymbolInfo containingType, MethodDeclarationSyntax method = default(MethodDeclarationSyntax))
    {
        Type = type;
        Name = name;
        ContainingType = containingType;
        GetMethod = method;
    }

    public PropertySymbolInfo(PropertySymbol propertySymbol)
    {
        PropertySymbol = propertySymbol;
        Type = new TypeSymbolInfo(propertySymbol.Type);
        Name = propertySymbol.Name;
        ContainingType = new TypeSymbolInfo(propertySymbol.ContainingType);
    }

    public static PropertySymbolInfo Get(Dictionary<string, object> cache)
    {
        var propertySymbol = (PropertySymbol)cache["PropertySymbol"];
        PropertySymbolInfo value;
        if (propertySymbol != null)
            value = new PropertySymbolInfo(propertySymbol);
        else
            value = new PropertySymbolInfo(TypeSymbolInfo.Get((Dictionary<string, object>)cache["Type"]), (string)cache["Name"], TypeSymbolInfo.Get((Dictionary<string, object>)cache["ContainingType"]), (MethodDeclarationSyntax)cache["GetMethod"]);
        value.FromOriginalMethod = (bool)cache["FromOriginalMethod"];
        return value;
    }

    public Dictionary<string, object> ToCache()
    {
        var value = new Dictionary<string, object>();
        value.Add("PropertySymbol", PropertySymbol);
        if (PropertySymbol == null)
        {
            value.Add("Type", Type.ToCache());
            value.Add("Name", Name);
            value.Add("ContainingType", ContainingType.ToCache());
            value.Add("GetMethod", GetMethod);
        }
        value.Add("FromOriginalMethod", FromOriginalMethod);
        return value;
    }

    public PropertySymbol PropertySymbol { get; private set; }
    public TypeSymbolInfo Type { get; private set; }
    public string Name { get; private set; }
    public TypeSymbolInfo ContainingType { get; set; }
    public bool FromOriginalMethod { get; set; }
    public MethodDeclarationSyntax GetMethod { get; private set; }

    public override string ToString()
    {
        return Name;
    }

    public static PropertySymbolInfo Get(PropertySymbol propertySymbol)
    {
        return new PropertySymbolInfo(propertySymbol);
    }
}

public class TypeSymbolInfo
{
    private TypeSymbolInfo()
    {
    }

    public TypeSymbolInfo(TypeSymbol typeSymbol)
    {
        TypeSymbol = typeSymbol;
        Name = typeSymbol.Name;
        FullName = typeSymbol.ToString();
        ContainingNamespace = typeSymbol.ContainingNamespace == null ? null : typeSymbol.ContainingNamespace.ToString();
        AllInterfaces = GetAllInterfaces(typeSymbol);
        TypeArguments = GetTypeArguments(typeSymbol);
    }

    public static TypeSymbolInfo Get(Dictionary<string, object> cache)
    {
        return new TypeSymbolInfo((TypeSymbol)cache["TypeSymbol"]);
    }

    public Dictionary<string, object> ToCache()
    {
        return new Dictionary<string, object>() { {"TypeSymbol", TypeSymbol} };
    }

    public static IEnumerable<TypeSymbolInfo> GetAllInterfaces(TypeSymbol typeSymbol)
    {
        return typeSymbol.AllInterfaces.OfType<TypeSymbol>().Select(i => new TypeSymbolInfo(i));
    }
    public static TypeSymbolInfo[] GetTypeArguments(TypeSymbol typeSymbol)
    {
        var namedTypeSymbol = typeSymbol as NamedTypeSymbol;
        return namedTypeSymbol == null ? new TypeSymbolInfo[0] : namedTypeSymbol.TypeArguments.OfType<TypeSymbol>().Select(i => new TypeSymbolInfo(i)).ToArray();
    }

    public static string GetBasicTypeName(TypeSymbol type, Func<TypeSymbol, TypeSymbol> transformType = null)
    {
        return GetBasicTypeNameInternal(type, transformType);
    }
    private static string GetBasicTypeNameInternal(TypeSymbol type, Func<TypeSymbol, TypeSymbol> transformType)
    {
        if (transformType != null)
            type = transformType(type);
        var namedTypeSymbol = type as NamedTypeSymbol;
        if (namedTypeSymbol == null || ! namedTypeSymbol.TypeArguments.Any())
            return type.Name;
        return string.Concat(type.Name, "<", namedTypeSymbol.TypeArguments.OfType<TypeSymbol>().Select(ta => GetBasicTypeNameInternal(ta, transformType)).Aggregate((t1, t2) => string.Concat(t1, ",", t2)), ">");
    }

    public TypeSymbol TypeSymbol { get; private set; }
    public string Name { get; private set; }
    public string FullName { get; private set; }
    public string ContainingNamespace { get; private set; }
    public IEnumerable<TypeSymbolInfo> AllInterfaces { get; private set; }
    public TypeSymbolInfo[] TypeArguments { get; private set; }

    public override string ToString()
    {
        return FullName;
    }

    public static TypeSymbolInfo Get(TypeSymbol typeSymbol)
    {
        return new TypeSymbolInfo(typeSymbol);
    }
}

public class DTOAndInterfacesTypesRewriter : TypeRewriter
{
    private Dictionary<string, string> _namespacesReplacement;

    public DTOAndInterfacesTypesRewriter(ISemanticModel semanticModel, SpecificationsElements specificationsElements, IEnumerable<TypeSymbol> dtoTypes, Dictionary<string, string> namespacesReplacement = null)
        : base(semanticModel)
    {
        SpecificationsElements = specificationsElements;
        DTOTypes = dtoTypes;
        _namespacesReplacement = namespacesReplacement;
        GetNameSyntaxFunc = nameSyntax =>
            {
                TypeSyntax t = nameSyntax;
                if (SpecificationsElements != null && SpecificationsElements.ReplaceInterface(ref t, SemanticModel, withInterfaceSpecifications:true))
                    return (NameSyntax)t;
                var typeSymbol = semanticModel.GetSymbolInfo(nameSyntax).Symbol;
                if (typeSymbol is MethodSymbol) // ctor
                    typeSymbol = typeSymbol.ContainingType;
                if (typeSymbol != null)
                {
                    var dtoTypeName = typeSymbol.ToString();
                    if (DTOTypes.Any(dt => dt.ToString() == dtoTypeName))
                        return SyntaxFactory.ParseName(typeSymbol.Name);
                }
                string @namespace;
                if (_namespacesReplacement != null && _namespacesReplacement.TryGetValue(typeSymbol.ContainingNamespace.ToString(), out @namespace))
                    return (NameSyntax)SyntaxFactory.ParseTypeName(string.Concat(@namespace, ".", typeSymbol.Name));

                return (NameSyntax)t;
            };
    }

    public override SyntaxNode VisitUsingDirective(UsingDirectiveSyntax node)
    {
        string @namespace;
        if (_namespacesReplacement != null && _namespacesReplacement.TryGetValue(node.Name.ToString(), out @namespace))
            return SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(@namespace));
        return node;
    }

    protected SpecificationsElements SpecificationsElements { get; private set; }
    protected IEnumerable<TypeSymbol> DTOTypes { get; private set; }
}

public abstract class SpecificationMethodBodyRewriter : DTOAndInterfacesTypesRewriter
{
    private List<List<PropertySymbolInfo>> _dependentProperties;
    private bool _return;
    private bool _returnNewError;
    private bool _hasErrorDetails;
    private bool _hasKey;
    private string _validateMethodName;

    public SpecificationMethodBodyRewriter(SpecificationsElements specificationsElements, List<List<PropertySymbolInfo>> dependentProperties, ISemanticModel semanticModel, IEnumerable<TypeSymbol> dtoTypes, string serverFxServiceInterfacesNamespace, Dictionary<string, string> namespacesReplacement = null)
        : base(semanticModel, specificationsElements, dtoTypes, namespacesReplacement)
    {
        _dependentProperties = dependentProperties;
        ServerFxServiceInterfacesNamespace = serverFxServiceInterfacesNamespace;
    }

    protected string ServerFxServiceInterfacesNamespace { get; private set; }


    public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        if (node.Identifier.ValueText.StartsWith("Validate"))
            _validateMethodName = node.Identifier.ValueText;
        else
            _validateMethodName = null;
        return base.VisitMethodDeclaration(node);
    }

    public override SyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
    {
        _return = true;
        var value = (ReturnStatementSyntax)base.VisitReturnStatement(node);
        if (_validateMethodName != null && node.Expression is ObjectCreationExpressionSyntax)
            return SyntaxFactory.Block(
                SyntaxFactory.LocalDeclarationStatement(SyntaxFactory.VariableDeclaration(SyntaxFactory.IdentifierName("var"), SyntaxFactory.SeparatedList(new [] { SyntaxFactory.VariableDeclarator("@value").WithInitializer(SyntaxFactory.EqualsValueClause(value.Expression))}, new SyntaxToken[0]))),
                SyntaxFactory.ParseStatement(string.Concat(value.Expression is ObjectCreationExpressionSyntax ? "" : "if (@value != null) ", "@value.Key = \"", _validateMethodName, "\";")),
                SyntaxFactory.ReturnStatement(SyntaxFactory.IdentifierName("@value")));
        return value;
    }

    protected virtual string GetDataTransfertEntityKeyParameter()
    {
        return "";
    }

    public override SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
        if (_return)
            _returnNewError = SemanticModel.GetSymbolInfo(node).Symbol.ContainingType.ToString() == ServerFxServiceInterfacesNamespace + ".Error";
        var value = ((ObjectCreationExpressionSyntax)base.VisitObjectCreationExpression(node)).WithType((TypeSyntax)Visit(node.Type));
        if (_returnNewError)
        {
            var initializers = new List<AssignmentExpressionSyntax>();
            if (!_hasErrorDetails && _dependentProperties != null && _dependentProperties.Count != 0)
            {
                var dependentProperties = _dependentProperties.Select(ps => ps.Select(p => p.Name).Aggregate((p1, p2) => string.Concat(p1, ".", p2)));
                var ifParent = node.Parent.Parent as IfStatementSyntax;
                if (ifParent != null)
                {
                    string ifConditionString = ifParent.Condition.ToString();
                    dependentProperties = dependentProperties.Where(p => ifConditionString.Contains(p));
                }
                initializers.Add(SyntaxFactory.AssignmentExpression(SyntaxKindAssignExpression, SyntaxFactory.IdentifierName("ErrorDetails"), SyntaxFactory.ParseExpression(string.Concat("new ErrorDetail[] { ", dependentProperties.Select(p => string.Concat("new ErrorDetail { EntityKey = ", GetDataTransfertEntityKeyParameter(), "DataTransferEntityKey, PropertyName = \"", p, "\" }")).Aggregate((ps1, ps2) => string.Concat(ps1, ", ", ps2)), " }"))));
            }
            if (! _hasKey && _validateMethodName != null)
                initializers.Add(SyntaxFactory.AssignmentExpression(SyntaxKindAssignExpression, SyntaxFactory.IdentifierName("Key"), SyntaxFactory.ParseExpression(string.Concat("\"", _validateMethodName, "\""))));
            if (initializers.Count != 0)
                return SyntaxFactory.ObjectCreationExpression(node.Type).WithInitializer(SyntaxFactory.InitializerExpression(SyntaxKind.ObjectInitializerExpression, SyntaxFactory.SeparatedList(value.Initializer.Expressions.Union(initializers), value.Initializer.Expressions.Union(initializers.Skip(1)).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken)))));
        }
        return value;
    }

    public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
    {
        IdentifierNameSyntax nodeIdentifier;
        if (_returnNewError && (nodeIdentifier = node.Left as IdentifierNameSyntax) != null)
            switch (nodeIdentifier.Identifier.ValueText)
            {
                case "ErrorDetails":
                    _hasErrorDetails = true;
                    break;
                case "Key":
                    _hasKey = true;
                    break;
            }
        return base.VisitBinaryExpression(node);
    }
}

public class SpecificationsRewriter : SyntaxRewriter
{
    private Func<SyntaxNode, Func<SyntaxNode, SyntaxNode>, SyntaxNode> _nodeRewriter;
    public SpecificationsRewriter(Func<SyntaxNode, Func<SyntaxNode, SyntaxNode>, SyntaxNode> nodeRewriter)
    {
        _nodeRewriter = nodeRewriter;
    }

    public override SyntaxNode Visit(SyntaxNode node)
    {
        var newNode = _nodeRewriter(node, n => Visit(n));
        if (newNode == node)
            return base.Visit(node);
        return newNode;
    }
}

public class UsingVisitor : SyntaxVisitor
{
    private ISemanticModel _semanticModel;
    private SpecificationsElements _specificationsElements;
    private string _entitiesNamespace;
    private SpecificationsElements.Type _type;
    private bool _done;
    private Func<MethodDeclarationSyntax, SpecificationsElements.MethodAnalizing> _analyzeMethod;
    private List<string> _usings = new List<string>();
    private bool _dal;
    private bool _service;
    private Func<ITypeSymbol, string> _getNamespaceFromTypeSymbol;
    private Func<IMethodSymbol, string> _getNamespaceFromMethodSymbol;
    private List<string> _keys;
    private Dictionary<string, List<string>> _usedUsings = new Dictionary<string, List<string>>();
    private string _currentNamespace;
    private string _className;
    private List<string> _specificationNamespaces; 

    public UsingVisitor(ISemanticModel semanticModel, SpecificationsElements specificationsElements, string serverFxSpecificationsNamespace, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, string entitiesNamespace, SpecificationsElements.Type type, List<string> specificationNamespaces, Func<MethodDeclarationSyntax, SpecificationsElements.MethodAnalizing> analyzeMethod = null, Dictionary<string, List<string>> usedUsings = null, bool dal = false, bool service = false, Func<ITypeSymbol, string> getNamespaceFromTypeSymbol = null, Func<IMethodSymbol, string> getNamespaceFromMethodSymbol = null)
    {
        _semanticModel = semanticModel;
        _specificationsElements = specificationsElements;
        _entitiesNamespace = entitiesNamespace;
        _type = type;
        _analyzeMethod = analyzeMethod ?? (m => SpecificationsElements.MethodAnalizing.Method);
        _usedUsings = usedUsings ?? new Dictionary<string, List<string>>();
        _dal = dal;
        _service = service;
        _getNamespaceFromTypeSymbol = getNamespaceFromTypeSymbol;
        _getNamespaceFromMethodSymbol = getNamespaceFromMethodSymbol;
        _specificationNamespaces = specificationNamespaces;
    }

    public Dictionary<string, List<string>> UsedUsings
    {
        get { return _usedUsings; }
    }

    public override void Visit(SyntaxNode node)
    {
        _done = false;
        base.Visit(node);
        if (!_done)
            foreach (var childNode in node.ChildNodes())
                Visit(childNode);
    }

    public override void VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        _className = _semanticModel.GetDeclaredSymbol(node).ToString();
        base.VisitClassDeclaration(node);
    }

    public override void VisitAttributeList(AttributeListSyntax node)
    {
        _done = true;
    }

    public override void VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        var method = _specificationsElements.GetAndAddMethodSymbol(node, _semanticModel);
        if (_specificationsElements.IsDefineMethod(node, method, _semanticModel))
        {
            foreach (var statement in node.Body.Statements.OfType<ExpressionStatementSyntax>())
            {
                var invocationStatement = statement.Expression as InvocationExpressionSyntax;
                MemberAccessExpressionSyntax memberAccess;
                GenericNameSyntax genericName;
                if (invocationStatement != null && (memberAccess = invocationStatement.Expression as MemberAccessExpressionSyntax) != null && (genericName = memberAccess.Expression as GenericNameSyntax) != null && genericName.TypeArgumentList.Arguments.Count == 1)
                {
                    _keys = new List<string>();
                    var entity = (ITypeSymbol)_semanticModel.GetSymbolInfo(genericName.TypeArgumentList.Arguments[0]).Symbol;
                    List<string> classes;
                    if (_specificationsElements.ClassesPerInterfaces.TryGetValue(entity.ToString(), out classes))
                        foreach (var @class in classes)
                            _keys.Add(@class);
                    else
                        _keys.Add(entity.Name);
                    Visit(invocationStatement.ArgumentList.Arguments[1]);
                }
            }
            _done = true;
            return;
        }
        if (_dal)
        {
            _keys = new List<string>();
            SetKeyWithEntityClass(_specificationsElements, node, method);

            bool isValidateMethod = false;
            if (_type != SpecificationsElements.Type.UnitTest && ((isValidateMethod = _specificationsElements.ValidateMethods.SelectMany(kvp => kvp.Value).Contains(node)) || node.Body.Statements.Count != 1))
            {
                VisitMethodSignature(node);
                if (isValidateMethod)
                {
                    IfStatementSyntax ifStatement;
                    if ((ifStatement = node.Body.Statements[0] as IfStatementSyntax) != null && (node.Body.Statements.Count == 1 || node.Body.Statements.Count == 2 && node.Body.Statements[1] is ReturnStatementSyntax))
                        Visit(ifStatement.Condition);
                }
                _done = true;
            }
        }
        else
            switch (_analyzeMethod(node))
            {
                case SpecificationsElements.MethodAnalizing.Method:
                    SetKeyMethodDeclarationAndVisitService(_specificationsElements, node, method, true);
                    break;
                case SpecificationsElements.MethodAnalizing.Signature:
                    SetKeyMethodDeclarationAndVisitService(_specificationsElements, node, method, false);
                    if (! _done)
                        VisitMethodSignature(node);
                    _done = true;
                    return;
                default:
                    _done = true;
                    return;
            }
        base.VisitMethodDeclaration(node);
    }

    private void SetKeyMethodDeclarationAndVisitService(SpecificationsElements specificationsElements, MethodDeclarationSyntax node, MethodSymbol method, bool entity)
    {
        _keys = new List<string>();
        bool contextAsParameter = specificationsElements.HasContextOrServiceAsParameter(method);
        bool? serviceMethod = null;
        if (entity && ! _dal)
            if (contextAsParameter || (serviceMethod = _specificationsElements.ServiceMethods.Contains(node)).Value)
            {
                if (contextAsParameter)
                {
                    SetKeyWithEntityClass(_specificationsElements, node, method);
                    VisitMethodSignature(node);
                    entity = false;
                }
                else
                {
                    _keys.Add("@Service");
                    _keys.Add("@ServiceContract");
                }
            }
        if (entity)
            SetKeyWithEntityClass(_specificationsElements, node, method);
        if (_specificationsElements.ValidateMethods.SelectMany(kvp => kvp.Value).Contains(node))
            _keys.Add("@Service");
        if (! entity)
        {
            if (serviceMethod ?? _specificationsElements.ServiceMethods.Contains(node))
            {
                _keys.Add("@ServiceContract");
                VisitMethodSignature(node);
            }
            if (_type != SpecificationsElements.Type.Client || _specificationsElements.IsApplicableOnClient(node))
                _keys = new List<string>() { "@Service" };
            else
            {
                if (_type == SpecificationsElements.Type.Client)
                    _keys = new List<string>() { "@Service" };
                VisitMethodSignature(node);
                _done = true;
                return;
            }
        }
        _done = false;
    }

    private void SetKeyWithEntityClass(SpecificationsElements specificationsElements, MethodDeclarationSyntax method, MethodSymbol methodSymbol)
    {
        if (_type == SpecificationsElements.Type.UnitTest && ! _dal)
        {
            _keys = new List<string>() { _className };
            return;
        }
        bool dontGenerateMethodBody = (_type == SpecificationsElements.Type.Client) ? ! _specificationsElements.IsApplicableOnClient(method) : (specificationsElements.HasContextAsParameter(methodSymbol) && ! _dal);
        List<string> oldKeys = null;
        if (dontGenerateMethodBody)
        {
            oldKeys = _keys;
            _keys = new List<string>();
        }
        if (methodSymbol.IsExtensionMethod)
        {
            var entity = methodSymbol.Parameters[0].Type;
            List<string> classes;
            if (_specificationsElements.ClassesPerInterfaces.TryGetValue(entity.ToString(), out classes))
            {
                var keys = _keys;
                bool done = _done;
                _keys = new List<string>() { entity.ToString() };
                VisitMethodSignature(method);
                _done = done;
                _keys = keys;
                foreach (var @class in classes)
                    _keys.Add(@class);
            }
            else if (entity.TypeKind != TypeKind.Class)
                _keys.Add("@Other");
            else
                _keys.Add(entity.Name);
        }
        else
            _keys.Add("@Other");
        if (dontGenerateMethodBody)
        {
            VisitMethodSignature(method);
            _keys = oldKeys;
        }
    }

    public void VisitMethodSignature(MethodDeclarationSyntax node)
    {
        Visit(node.ReturnType);
        Visit(node.ParameterList);
        foreach (var cc in node.ConstraintClauses)
            Visit(cc);
    }

    public override void VisitUsingDirective(UsingDirectiveSyntax node)
    {
        _usings.Add(node.Name.GetText().ToString());
        _done = true;
    }

    private void AddUsing(string @using)
    {
        if (@using == "<global namespace>" || @using == _specificationsElements.ServerFxDALInterfacesNamespace || @using == _specificationsElements.ServerFxServiceInterfacesNamespace && _type == SpecificationsElements.Type.Client || @using == _entitiesNamespace || @using == _currentNamespace)
            return ;
        if (_keys != null)
            foreach (var key in _keys)
                AddUsing(key, @using);
        if (_className != null)
            AddUsing(_className, @using);
    }

    private void AddUsing(string key, string @using)
    {
        if (_specificationNamespaces.Contains(@using))
            return;
        List<string> usings;
        if (! UsedUsings.TryGetValue(key, out usings))
            UsedUsings.Add(key, usings = new List<string>());
        else if (usings.Contains(@using))
            return;
        usings.Add(@using);
    }

    private void VisitName(NameSyntax node)
    {
        var typeSymbol = _semanticModel.GetSymbolInfo(node).Symbol as TypeSymbol;
        if (typeSymbol != null)
        {
            string namespaceName;
            bool isIEntity = typeSymbol.GetAttributes().Any(a => a.ToString() == _specificationsElements.ServerFxSpecificationsNamespace + ".IEntityAttribute");
            if (_type == SpecificationsElements.Type.UnitTest || ! isIEntity)
            {
                if (_getNamespaceFromTypeSymbol == null || (namespaceName = _getNamespaceFromTypeSymbol(typeSymbol)) == null)
                {
                    if (typeSymbol.ContainingNamespace == null)
                    {
                        _done = true;
                        return;
                    }
                }
            }
            if (! isIEntity)
            {
                namespaceName = typeSymbol.ContainingNamespace.ToString();
                AddUsing(namespaceName);
            }
        }
        _done = true;
    }

    public override void VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
        if (_service)
            base.VisitPropertyDeclaration(node);
        else
            _done = true;
    }

    public override void VisitIdentifierName(IdentifierNameSyntax node)
    {
        VisitName(node);
    }

    public override void VisitQualifiedName(QualifiedNameSyntax node)
    {
        VisitName(node);
    }

    public override void VisitGenericName(GenericNameSyntax node)
    {
        VisitName(node);
        foreach (var t in node.TypeArgumentList.Arguments)
            Visit(t);
    }

    public override void VisitInvocationExpression(InvocationExpressionSyntax node)
    {
        var memberAccessExpressionSyntax = node.Expression as MemberAccessExpressionSyntax;
        if (memberAccessExpressionSyntax != null)
        {
            MethodSymbol methodSymbol;
            if (memberAccessExpressionSyntax.Expression != null && (methodSymbol = _semanticModel.GetSymbolInfo(memberAccessExpressionSyntax).Symbol as MethodSymbol) != null && (methodSymbol = methodSymbol.ConstructedFrom.ReducedFrom ?? methodSymbol) != null)
            {
                if (methodSymbol.IsExtensionMethod)
                {
                    var methodSymbolString = methodSymbol.ToString();
                    if (! _specificationsElements.MethodPerMethodSymbols.Keys.Any(m => m.ToString() == methodSymbolString))
                    {
                        string namespaceName;
                        if (_getNamespaceFromMethodSymbol == null || (namespaceName = _getNamespaceFromMethodSymbol(methodSymbol)) == null)
                            namespaceName = methodSymbol.ContainingNamespace.ToString();
                        AddUsing(namespaceName);
                    }
                }
                if ((_dal || _type == SpecificationsElements.Type.UnitTest) && methodSymbol.IsStatic)
                    {
                        foreach (var p in methodSymbol.Parameters)
                            AddUsing(p.Type);
                        if (! methodSymbol.ReturnsVoid)
                            AddUsing(methodSymbol.ReturnType);
                    }
            }
        }
        base.VisitInvocationExpression(node);
    }

    private void AddUsing(TypeSymbol type)
    {
        if (type != null)
        {
            if (type.ContainingNamespace != null)
                AddUsing(type.ContainingNamespace.ToString());
            var namedTypeSymbol = type as NamedTypeSymbol;
            if (! (namedTypeSymbol == null || namedTypeSymbol.TypeArguments == null))
                foreach (var t in namedTypeSymbol.TypeArguments)
                    AddUsing(t);
        }
    }

    public override void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
        var typeSymbol = _semanticModel.GetTypeInfo(node).Type;
        if (typeSymbol == null)
            typeSymbol = _semanticModel.GetTypeInfo(node.Type).Type;
        string namespaceName;
        if (_getNamespaceFromTypeSymbol == null || (namespaceName = _getNamespaceFromTypeSymbol(typeSymbol)) == null)
            namespaceName = typeSymbol.ContainingNamespace.ToString();
        AddUsing(namespaceName);
        base.VisitObjectCreationExpression(node);
    }

    public override void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
        _currentNamespace = node.Name.ToString();
        base.VisitNamespaceDeclaration(node);
    }

    public override void VisitParameter(ParameterSyntax node)
    {
        var p = (ParameterSymbol)_semanticModel.GetDeclaredSymbol(node);
        if (_specificationsElements.IsContextOrService(p.Type))
        {
            _done = true;
            return;
        }
        base.VisitParameter(node);
    }

    public static IEnumerable<string> GetUsings(TypeSyntax typeSyntax, TypeSymbol typeSymbol)
    {
        var typeSyntaxName = typeSyntax.ToString().Replace(" ", "");
        var typeSymbolName = typeSymbol.ToString().Replace(" ", "");
        return GetUsings(typeSyntaxName, typeSymbolName);
    }

    private static IEnumerable<string> GetUsings(string typeSyntaxName, string typeSymbolName)
    {
        if (typeSyntaxName == typeSymbolName)
            yield break;
        var nsMatch = Regex.Match(typeSymbolName, string.Concat("^((.?)*).", typeSyntaxName, "$"));
        if (nsMatch.Success)
            yield return nsMatch.Groups[1].Value;
        foreach (var @using in GetGenericUsings(typeSyntaxName, typeSymbolName))
            yield return @using;
    }

    private static IEnumerable<string> GetGenericUsings(string typeSyntaxName, string typeSymbolName)
    {
        var typeSyntaxMatch = Regex.Match(typeSyntaxName, @"([^<>,]+)(?:\<(([^<>,]*(?:(?:(\<)[^<>]*)+(?:(?<-4>\>)[^<>]*)+)*(?(4)(?!))))\>[^<>,]*)");
        var typeSymbolMatch = Regex.Match(typeSymbolName, @"([^<>,]+)(?:\<(([^<>,]*(?:(?:(\<)[^<>]*)+(?:(?<-4>\>)[^<>]*)+)*(?(4)(?!))))\>[^<>,]*)");
        if (typeSyntaxMatch.Success)
        {
            foreach (var @using in GetUsings(typeSyntaxMatch.Groups[1].Value, typeSymbolMatch.Groups[1].Value))
                yield return @using;
            typeSyntaxMatch = Regex.Match(typeSyntaxMatch.Groups[2].Value, @"[^<>,]+(?:\<(?:([^<>,]*(?:(?:(\<)[^<>]*)+(?:(?<-2>\>)[^<>]*)+)*(?(2)(?!))))\>[^<>,]*)?");
            typeSymbolMatch = Regex.Match(typeSymbolMatch.Groups[2].Value, @"[^<>,]+(?:\<(?:([^<>,]*(?:(?:(\<)[^<>]*)+(?:(?<-2>\>)[^<>]*)+)*(?(2)(?!))))\>[^<>,]*)?");
            while (typeSyntaxMatch.Success)
            {
                foreach (var @using in GetUsings(typeSyntaxMatch.Value, typeSymbolMatch.Value))
                    yield return @using;
                typeSyntaxMatch = typeSyntaxMatch.NextMatch();
                typeSymbolMatch = typeSymbolMatch.NextMatch();
            }
        }	
    }
}

public class ClassesVisitor : SyntaxVisitorOfIEnumerableOfClassDeclarationSyntax
{
    public override IEnumerable<ClassDeclarationSyntax> VisitCompilationUnit(CompilationUnitSyntax node)
    {
        return node.Members.OfType<NamespaceDeclarationSyntax>().SelectMany(c => Visit(c));
    }

    public override IEnumerable<ClassDeclarationSyntax> VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
        return node.Members.OfType<ClassDeclarationSyntax>().SelectMany(c => Visit(c));
    }

    public override IEnumerable<ClassDeclarationSyntax> VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        yield return node;
    }
}

public class SpecificationPath
{
    public string Sln { get; set; }
    public string Csproj { get; set; }
    public string Folder { get; set; }
}

public class IsCriticityErrorVisitor : SyntaxVisitorOfBool
{
    private ISemanticModel _semanticModel;
    private SpecificationsElements _specificationsElements;
    private string _serverFxServiceInterfacesNamespace;
    private MethodDeclarationSyntax _method;
        
    public IsCriticityErrorVisitor(ISemanticModel semanticModel, SpecificationsElements specificationsElements, string serverFxServiceInterfacesNamespace)
    {
        _semanticModel = semanticModel;
        _specificationsElements = specificationsElements;
        _serverFxServiceInterfacesNamespace = serverFxServiceInterfacesNamespace;
    }

    public override bool Visit(SyntaxNode node)
    {
        return base.Visit(node) || node.ChildNodes().Any(n => Visit(n));
    }

    public override bool VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        _method = node;
        return base.VisitMethodDeclaration(node);
    }

    public override bool VisitInvocationExpression(InvocationExpressionSyntax node)
    {
        var methodSymbol = (MethodSymbol)_semanticModel.GetSymbolInfo(node).Symbol;
        MethodDeclarationSyntax method;
        if (_specificationsElements.MethodPerMethodSymbols.TryGetValue(methodSymbol.ToString(), out method) && Visit(method))
            return true;
        return base.VisitInvocationExpression(node);
    }

    public override bool VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
        var name = node.Name.ToString();
        IFieldSymbol fieldSymbol;
        ITypeSymbol typeSymbol;
        return (name == "Error" || name == "Mandatory") && (fieldSymbol = _semanticModel.GetSymbolInfo(node).Symbol as IFieldSymbol) != null &&  fieldSymbol != null && (typeSymbol = _semanticModel.GetSymbolInfo(node.Expression).Symbol as ITypeSymbol) != null && typeSymbol.ContainingNamespace.ToString() == _serverFxServiceInterfacesNamespace && typeSymbol.Name == "Criticity";
    }
}

public class TypeRewriter : SyntaxRewriter
{
    public TypeRewriter(ISemanticModel semanticModel, Func<NameSyntax, NameSyntax> getNameSyntax = null)
        :this(semanticModel, getNameSyntax, null)
    {
    }
    public TypeRewriter(ISemanticModel semanticModel, Func<GenericNameSyntax, Func<GenericNameSyntax>, GenericNameSyntax> getGenericNameSyntax)
        :this(semanticModel, null, getGenericNameSyntax)
    {
    }
    public TypeRewriter(ISemanticModel semanticModel, Func<NameSyntax, NameSyntax> getNameSyntax, Func<GenericNameSyntax, Func<GenericNameSyntax>, GenericNameSyntax> getGenericNameSyntax)
    {
        SemanticModel = semanticModel;
        GetNameSyntaxFunc = getNameSyntax;
        GetGenericNameSyntaxFunc = getGenericNameSyntax;
    }

    public ISemanticModel SemanticModel { get; protected set; }
    protected Func<NameSyntax, NameSyntax> GetNameSyntaxFunc { get; set; }
    protected Func<GenericNameSyntax, Func<GenericNameSyntax>, GenericNameSyntax> GetGenericNameSyntaxFunc { get; set; }

    public override SyntaxNode VisitQualifiedName(QualifiedNameSyntax node)
    {
        return GetNameSyntax(node) ?? base.VisitQualifiedName(node);
    }

    private NameSyntax GetNameSyntax(NameSyntax node)
    {
        try
        {
            ISymbol symbol;
            MethodSymbol methodSymbol;
            if (GetNameSyntaxFunc == null || ! ((symbol = SemanticModel.GetSymbolInfo(node).Symbol) is ITypeSymbol || (methodSymbol = symbol as MethodSymbol) != null && methodSymbol.MethodKind == MethodKind.Constructor))
                return node;
            return GetNameSyntaxFunc(node);
        }
        catch
        {
            return null;
        }
    }

    public override SyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
    {
        return GetNameSyntax(node) ?? base.VisitIdentifierName(node);
    }

    public override SyntaxNode VisitGenericName(GenericNameSyntax node)
    {
        if (GetGenericNameSyntaxFunc != null)
            return GetGenericNameSyntaxFunc(node, () => (GenericNameSyntax)base.VisitGenericName(node));
        return base.VisitGenericName(node);
    }

    public override SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
        var value = (ObjectCreationExpressionSyntax)base.VisitObjectCreationExpression(node);
        if (GetNameSyntaxFunc == null)
            return value;
        var type = GetNameSyntaxFunc((NameSyntax)node.Type);
        if (node.Type != type)
            value = value.WithType(type);
        return value;
    }
}

public class UseServicePropertyVisitor : SyntaxVisitorOfBool
{
    private ISemanticModel _semanticModel;
    private IEnumerable<PropertySymbol> _propertiesSymbol;

    public UseServicePropertyVisitor(ISemanticModel semanticModel, IEnumerable<PropertySymbol> propertiesSymbol)
    {
        _semanticModel = semanticModel;
        _propertiesSymbol = propertiesSymbol;
    }

    public static bool UseServiceProperty(MethodDeclarationSyntax method, SpecificationsElements specificationsElements)
    {
        return new UseServicePropertyVisitor(specificationsElements.SemanticModelPerMethods[method], specificationsElements.ServiceProperties).Visit(method);
    }

    public override bool Visit(SyntaxNode node)
    {
        return base.Visit(node) || node.ChildNodes().Any(cn => Visit(cn));
    }

    public override bool VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
        return VisitProp(node) || base.VisitMemberAccessExpression(node);
    }

    public override bool VisitIdentifierName(IdentifierNameSyntax node)
    {
        return VisitProp(node) || base.VisitIdentifierName(node);
    }

    private bool VisitProp(SyntaxNode node)
    {
        return _propertiesSymbol.Any(ps => ps.Equals(_semanticModel.GetSymbolInfo(node).Symbol as PropertySymbol));
    }
}

public static class MethodSymbolExtension
{
    public static bool IsExtensionMethod(MethodSymbol method)
    {
        return method.IsExtensionMethod || method.GetAttributes().Any(a => a.ToString() == "System.Runtime.CompilerServices.ExtensionAttribute");
    }
}

bool GetIncludesInfo(MethodDeclarationSyntax method, SpecificationsElements specificationsElements, IEnumerable<EntityType> entityTypes, CodeGenerationTools code, string serverEntitiesNamespace, out List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>> includesFor, out List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>> includesWith)
{
    includesFor = new List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>>();
    includesWith = new List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>>();

    Func<MethodDeclarationSyntax, bool, List<List<PropertySymbolInfo>>> getDependentProperties = null;
    getDependentProperties = (m, last) =>
    {
        List<List<PropertySymbolInfo>> dependentProperties;
        if ((last ? specificationsElements.MethodsDependentPropertiesLast : specificationsElements.MethodsDependentProperties).TryGetValue(m, out dependentProperties) && dependentProperties != null)
        {
            dependentProperties = dependentProperties.Select(pds => pds.ToList()).ToList();
            Func<List<PropertySymbolInfo>, List<PropertySymbolInfo>, bool> listEquals = (l1, l2) =>
            {
                if (l1.Count != l2.Count)
                    return false;
                for (int i = 0 ; i < l1.Count ; i ++)
                    if (l1[i].Name != l2[i].Name)
                        return false;
                return true;
            };

            if (last)
            {
                for (int i = 0 ; i < dependentProperties.Count ; i ++)
                {
                    for (int j = 1 ; j < dependentProperties[i].Count - 1 ; j ++)
                    {
                        var newDependentProperties = dependentProperties[i].Take(j).ToList();
                        if (! dependentProperties.Any(dp => listEquals(dp, newDependentProperties)))
                            dependentProperties.Insert(i ++, newDependentProperties);
                    }
                }
            }

            for (int pdsIndex = 0 ; pdsIndex < dependentProperties.Count ; pdsIndex ++)
            {
                var pds = dependentProperties[pdsIndex];
                var pd = pds[pds.Count - 1];
                if (pd.GetMethod != null)
                {
                    bool changed = false;
                    var pdMethodsDependentPropertiesLast = getDependentProperties(pd.GetMethod, true);
                    for (int pdsIndex2 = pdsIndex + 1 ; pdsIndex2 < dependentProperties.Count ; pdsIndex2 ++)
                    {
                        var pds2 = dependentProperties[pdsIndex2];
                        for (int i = 0 ; i < pds2.Count - 1 ; i ++)
                        {
                            if (pd.GetMethod == pds2[i].GetMethod)
                            {
                                changed = true;
                                dependentProperties.RemoveAt(pdsIndex2);
                                pds2.RemoveAt(i);
                                foreach (var pdsLast in pdMethodsDependentPropertiesLast.AsEnumerable().Reverse())
                                {
                                    var newDependences = pds2.Take(i).ToList();
                                    var newPds2 = new List<PropertySymbolInfo>(pds2);
                                    int j = i;
                                    foreach (var pdLast in pdsLast)
                                    {
                                        newDependences.Add(pdLast);
                                        if (! dependentProperties.Any(dp => listEquals(dp, newDependences)))
                                        {
                                            dependentProperties.Insert(pdsIndex ++, newDependences);
                                            pdsIndex2 ++;
                                            newDependences = new List<PropertySymbolInfo>(newDependences);
                                        }
                                        newPds2.Insert(j++, pdLast);
                                    }
                                    dependentProperties.Insert(pdsIndex2, newPds2);
                                }
                                break;
                            }
                        }
                    }
                    if (changed)
                        pdsIndex --;
                }
            }
        }
        return dependentProperties;
    };
    var methodDependentProperties = getDependentProperties(method, false);
    if (methodDependentProperties != null)
    {
        for (int pdsIndex = 0 ; pdsIndex < methodDependentProperties.Count ; pdsIndex ++)
        {
            var pds = methodDependentProperties[pdsIndex];
            var pd = pds[pds.Count - 1];
            var entityType = entityTypes.FirstOrDefault(et => string.Concat(serverEntitiesNamespace, ".", code.Escape(et)) == pd.ContainingType.ToString());
            if (entityType == null)
                return false;
            var previousIncludeFor = pds.Count > 1 ? includesFor.Where(includeFor =>
                {
                    if (includeFor.Value.Count + 1 != pds.Count)
                        return false;
                    for (int includeForIndex = 0 ; includeForIndex < includeFor.Value.Count ; includeForIndex ++)
                        if (includeFor.Value[includeForIndex].ToString() != pds[includeForIndex].ToString())
                            return false;
                    return true;
                }).Select(kvp => kvp.Value).FirstOrDefault()
                : null;
            if (entityType != null && entityType.NavigationProperties.Any(np => code.Escape(np) == pd.Name))
                includesFor.Add(new KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>(previousIncludeFor, pds));
            else if (pd.GetMethod != null)
            {
                if (pds.Count > 1 && previousIncludeFor == null)
                    return false;
                includesWith.Add(new KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>(previousIncludeFor, pds));
            }
            else
            {
                for (int nextIndex = pdsIndex + 1 ; nextIndex < methodDependentProperties.Count ;)
                {
                    bool remove = true;
                    var pdsLoop = methodDependentProperties[nextIndex];
                    for (int prevIndex = 0 ; prevIndex < pds.Count ; prevIndex ++)
                    {
                        if (prevIndex >= pdsLoop.Count || pds[prevIndex].Name != pdsLoop[prevIndex].Name)
                            remove = false;
                    }
                    if (remove)
                        methodDependentProperties.Remove(pdsLoop);
                    else
                        nextIndex ++;
                }
            }
        }
    }
    return true;
}

StringBuilder IncludeFor(MethodDeclarationSyntax method, SpecificationsElements specificationsElements, IEnumerable<EntityType> entityTypes, CodeGenerationTools code, string serverEntitiesNamespace, string clientEntitiesNamespace, TypeSymbol type)
{
    List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>> includesFor;
    List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>> includesWith; 
    var sb = new StringBuilder();
    if (GetIncludesInfo(method, specificationsElements, entityTypes, code, serverEntitiesNamespace, out includesFor, out includesWith))
    {
        int variableIndex = 1;
        try
        {
            return IncludeFor(includesFor, includesWith, sb, null, ref variableIndex, clientEntitiesNamespace, type);
        }
        catch (InvalidOperationException)
        {
            return null;
        }
    }
    return null;
}

    private StringBuilder IncludeFor(List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>> includesFor,
        List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>> includesWith, StringBuilder sb,
        List<PropertySymbolInfo> parent, ref int index, string clientEntitiesNamespace, TypeSymbol eType, bool addE = false)
    {
        string eTypeString = eType.ToString();
        bool first = true;
        foreach (var includeFor in includesFor.Where(i => i.Key == parent).Select(i => i.Value))
        {
            var lastIncludeFor = includeFor.Last();
            bool containsProp = false;
            TypeSymbol eTypeLoop = eType;
            do
            {
                var lastIncludeForContainingTypeString = lastIncludeFor.ContainingType.ToString();
                if (eTypeLoop.ToString() == lastIncludeForContainingTypeString)
                {
                    containsProp = true;
                    break;
                }
            } while ((eTypeLoop = eTypeLoop.BaseType) != null);
            if (first)
            {
                first = false;
                bool casted = false;
                if (addE && eType != null && includeFor.Count > 1)
                {
                    if (! containsProp)
                    {
                        if (eType.AllInterfaces.Any(i => i.ToString() == "System.Collections.IEnumerable"))
                        {
                            sb.Append("e");
                            sb.Append(index);
                            sb.Append(".OfType<");
                            sb.Append(clientEntitiesNamespace);
                            sb.Append(".");
                            sb.Append(lastIncludeFor.ContainingType.Name);
                            sb.Append(">()");
                        }
                        else
                        {
                            sb.Append("(e");
                            sb.Append(index);
                            sb.Append(" as ");
                            sb.Append(clientEntitiesNamespace);
                            sb.Append(".");
                            sb.Append(lastIncludeFor.ContainingType.Name);
                            sb.Append(")");
                        }
                        casted = true;
                    }
                }
                if (addE && ! casted)
                {
                    sb.Append("e");
                    sb.Append(index);
                    addE = false;
                }
                index ++;
            }
            sb.Append(".");
            if (! containsProp)
            {
                bool found = false;
                for (var baseType = (lastIncludeFor.ContainingType.TypeSymbol).BaseType ; baseType != null ; baseType = baseType.BaseType)
                    if (baseType.ToString() == eTypeString)
                    {
                        found = true;
                        break;
                    }
                if (found)
                    sb.Append(lastIncludeFor.ContainingType.Name);
                else
                    throw new InvalidOperationException();
            }
            sb.Append("Include");
            sb.Append(lastIncludeFor.Name);
            if (includesFor.Union(includesWith).Any(i => i.Key == includeFor))
            {
                sb.Append("WithExpression(e");
                sb.Append(index);
                sb.Append(" => ");
                IncludeFor(includesFor, includesWith, sb, includeFor, ref index, clientEntitiesNamespace, lastIncludeFor.Type.TypeSymbol, true);
            }
            else
                sb.Append("(");
            sb.Append(")");
        }
        foreach (var includeWith in includesWith.Where(i => i.Key == parent).Select(i => i.Value))
        {
            if (addE)
            {
                if (sb.Length != 0 && sb[sb.Length-1] != ')') 
                {
                    sb.Append("e");
                    sb.Append(index ++);											   
                }
                addE = false;
            }
            sb.Append(".With");
            sb.Append(includeWith.Last().Name);
            sb.Append("()");
        }
        return sb;
    }

    private class T4CustomGenerator
    {
        private Action<string> _write;
        private Func<StringBuilder> _getGenerationEnvironment;

        public StringBuilder GenerationEnvironment
        {
            get { return _getGenerationEnvironment(); }
        }

        protected ITextTemplatingEngineHost Host { get; set; }
        protected Func<string, string> HostResolvePath { get; set; }

        public T4CustomGenerator(Action<string> write, ITextTemplatingEngineHost host,
            Func<StringBuilder> getGenerationEnvironment)
        {
            _write = write;
            Host = host;
            HostResolvePath = path => Host.ResolvePath(path);
            _getGenerationEnvironment = getGenerationEnvironment;
        }

        [ThreadStatic] private static StringBuilder _currentFileStringBuilder;

        protected static StringBuilder CurrentFileStringBuilder
        {
            get { return _currentFileStringBuilder; }
            set { _currentFileStringBuilder = value; }
        }

        [ThreadStatic] private static bool _endsWithNewLine;

        protected static bool EndsWithNewLine
        {
            get { return _endsWithNewLine; }
            set { _endsWithNewLine = value; }
        }

        public void Write(string text)
        {
            if (_currentFileStringBuilder == null)
                _write(text);
            else
            {
                if (_endsWithNewLine)
                    text = Environment.NewLine + text;
                if (_endsWithNewLine = text.EndsWith(Environment.NewLine))
                    text = text.Substring(0, text.Length - Environment.NewLine.Length);
                text = text.Replace(Environment.NewLine, Environment.NewLine + CurrentIndent);
                _currentFileStringBuilder.Append(text);
            }
        }

        [ThreadStatic] private static Stack<string> _indents;

        protected static Stack<string> Indents
        {
            get { return _indents ?? (_indents = new Stack<string>()); }
            set { _indents = value; }
        }

        protected void PushIndent(string indent)
        {
            Indents.Push(Indents.Count == 0 ? indent : Indents.Peek() + indent);
        }

        protected string PopIndent()
        {
            return Indents.Pop();
        }

        public string CurrentIndent
        {
            get { return Indents.Count == 0 ? "" : Indents.Peek(); }
        }

        protected void Process(EntityFrameworkTemplateFileManager fileManager, ConcurrentDictionary<string, StringBuilder> classesCode, EdmxElements edmxElements, Func<IDocument, string, SyntaxRewriter> rewriterFactory)
        {
            _currentFileStringBuilder = null;

            var dte = (EnvDTE.DTE)new DynamicHost(Host).AsIServiceProvider().GetService(typeof(EnvDTE.DTE));
            var projectPath = dte.Solution.FindProjectItem(Host.TemplateFile).ContainingProject.FullName;
            var templateFolder = Path.GetDirectoryName(Host.TemplateFile);

            var solution = LoadSolution(dte.Solution.FullName, Host);
            var project = solution.Projects.First(p => Path.GetFullPath(p.FilePath) == projectPath);

            var documentIdCodes = new Dictionary<string, DocumentId>();

            foreach (var classCode in classesCode)
            {
                var document = project.Documents.FirstOrDefault(d => d.FilePath == Path.Combine(templateFolder, classCode.Key));
                if (document != null)
                    project = project.RemoveDocument(document.Id);
                DocumentId documentId;
                project = AddDocument(project, classCode.Key, classCode.Value.ToString(), new [] { "WAQS." + edmxElements.EdmxName }, out documentId);
                documentIdCodes.Add(classCode.Key, documentId);
            }

            foreach (var documentIdCode in documentIdCodes)
            {
                fileManager.StartNewFile(documentIdCode.Key);
                var newDocument = project.Documents.First(d => d.Id == documentIdCode.Value);
                new WritingFunctions(Write).WriteCopyright();
            #>
            <#=rewriterFactory(newDocument, documentIdCode.Key).Visit(GetSyntaxRoot(newDocument)).NormalizeWhitespace().ToString().Trim()#>
            <#+
            }

            fileManager.Process();
        }
    }

    public class TestNull : SyntaxRewriter
    {
        private ISemanticModel _semanticModel;
        private TypeSyntax _returnType;
        private HashSet<string> _alreadyTestedNullableExpressions;
        private HashSet<string> _removedAlreadyTestedNullableExpressions = new HashSet<string>();
        private Dictionary<string, SyntaxKind> _alreadyTestedNullableExpressionsTmp = new Dictionary<string, SyntaxKind>();
        private StatementSyntax _currentStatement;
        private Dictionary<StatementSyntax, List<StatementSyntax>> _statementsToAdd = new Dictionary<StatementSyntax, List<StatementSyntax>>();
        private HashSet<string> _expressionsToTest = new HashSet<string>();
        private Dictionary<string, string> _replaceNode = new Dictionary<string, string>();
        private string _waqsLogical;
        private bool _yield;
        private bool _pushInBlock;
        private bool _fromLinq;
        private bool _not;

        public TestNull(ISemanticModel semanticModel)
        {
            _semanticModel = semanticModel;
            _alreadyTestedNullableExpressions = new HashSet<string>();
        }

        private TestNull(TestNull @base)
        {
            _semanticModel = @base._semanticModel;
            _returnType = @base._returnType;
            _alreadyTestedNullableExpressions = new HashSet<string>(@base._alreadyTestedNullableExpressions.Union(@base._expressionsToTest));
            _replaceNode = new Dictionary<string, string>(_replaceNode);
            _currentStatement = @base._currentStatement;
            _yield = @base._yield;
            _fromLinq = @base._fromLinq;
            _not = @base._not;
        }

        protected virtual void Init()
        {
            _alreadyTestedNullableExpressions.Clear();
            _expressionsToTest.Clear();
        }

        public void AddAlreadyTestedNullableExpressions(string s)
        {
            _alreadyTestedNullableExpressions.Add(s);
        }

        private string GetExpressionString(ExpressionSyntax node)
        {
            string nodeString = node.NormalizeWhitespace().ToString();
            foreach (var replaceNode in _replaceNode)
                nodeString = nodeString.Replace(replaceNode.Key, replaceNode.Value);
            return nodeString;
        }

        private void AddExpressionToTest(ExpressionSyntax node)
        {
            bool _;
            AddExpressionToTest(node, out _);
        }

        private void AddExpressionToTest(ExpressionSyntax node, out bool changed)
        {
            var value = (ExpressionSyntax)new GetSimpleExpression().Visit(node);
            changed = node != value;
            string nodeString = GetExpressionString(value);
            if (!(_alreadyTestedNullableExpressions.Contains(nodeString)))
                _expressionsToTest.Add(nodeString);
        }

        private void ApplyChanges(TestNull testNull, BlockSyntax block)
        {
            if (testNull._expressionsToTest.Count != 0)
                testNull.AddStatement(testNull.BuildIfFromExpressionsToTest());
            List<StatementSyntax> addedStatements;
            if (testNull._statementsToAdd.TryGetValue(block, out addedStatements))
                foreach (var addedStatement in addedStatements)
                    AddStatement(addedStatement);
            foreach (var alreadyTested in testNull._alreadyTestedNullableExpressions.Union(testNull._expressionsToTest))
                _alreadyTestedNullableExpressions.Add(alreadyTested);
            foreach (var alreadyTestedTmp in testNull._alreadyTestedNullableExpressionsTmp)
                if (!_alreadyTestedNullableExpressionsTmp.ContainsKey(alreadyTestedTmp.Key))
                    _alreadyTestedNullableExpressionsTmp.Add(alreadyTestedTmp.Key, alreadyTestedTmp.Value);
            foreach (var replaceNode in testNull._replaceNode)
                if (!_replaceNode.ContainsKey(replaceNode.Key))
                    _replaceNode.Add(replaceNode.Key, replaceNode.Value);
            ApplyRemoveStatements(testNull);
        }

        private void ApplyRemoveStatements(TestNull testNull, bool addVariables = true)
        {
            foreach (var removeExp in testNull._removedAlreadyTestedNullableExpressions)
            {
                if (_expressionsToTest.Contains(removeExp))
                    AddStatement(BuildIfFromExpressionsToTest());
                if (addVariables)
                    foreach (var alreadyTestedNullableExpression in _alreadyTestedNullableExpressions.ToList())
                        if (Regex.IsMatch(alreadyTestedNullableExpression, string.Concat("^", removeExp, @"($|\.)")) && !testNull._alreadyTestedNullableExpressions.Contains(alreadyTestedNullableExpression))
                        {
                            _alreadyTestedNullableExpressions.Remove(alreadyTestedNullableExpression);
                            _removedAlreadyTestedNullableExpressions.Add(alreadyTestedNullableExpression);
                        }
            }
        }

        public void Visit(IEnumerable<SyntaxNode> nodes)
        {
            foreach (var node in nodes)
                Visit(node);
        }

        public override SyntaxNode Visit(SyntaxNode node)
        {
            var statement = node as StatementSyntax;
            SyntaxKind kind;
            if (statement != null)
            {
                _currentStatement = statement;
                _alreadyTestedNullableExpressionsTmp.Clear();
                _pushInBlock = false;
            }
            else if (!(_waqsLogical == null || (kind = GetKind(node)) == SyntaxKind.LogicalOrExpression || kind == SyntaxKind.LogicalAndExpression))
                _waqsLogical = null;
            var value = base.Visit(node);
            if (!(_expressionsToTest.Count == 0 || statement == null))
            {
                List<StatementSyntax> statementsToAdd;
                if (!_statementsToAdd.TryGetValue(statement, out statementsToAdd))
                    _statementsToAdd.Add(statement, statementsToAdd = new List<StatementSyntax>());
                statementsToAdd.Add(BuildIfFromExpressionsToTest());
            }
            if (statement != null && _pushInBlock)
            {
                if (_expressionsToTest.Count != 0)
                    AddStatement(BuildIfFromExpressionsToTest());
                List<StatementSyntax> statements;
                if (!_statementsToAdd.TryGetValue(statement, out statements))
                    statements = new List<StatementSyntax>();
                else
                    _statementsToAdd.Remove(statement);
                statements.Add((StatementSyntax)value);
                return SyntaxFactory.Block(statements.Where(s => s != null));
            }
            return value;
        }

        public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
        {
            _yield = new IsYieldVisitor().Visit(node.Body);
            Init();
            if (((MethodSymbol)_semanticModel.GetDeclaredSymbol(node)).ReturnsVoid)
                _returnType = null;
            else
                _returnType = node.ReturnType;
            var value = base.VisitMethodDeclaration(node);
            return value;
        }

        public override SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)
        {
            _returnType = node.Type;
            var value = base.VisitPropertyDeclaration(node);
            return value;
        }

        public override SyntaxNode VisitEventDeclaration(EventDeclarationSyntax node)
        {
            Init();
            return base.VisitEventDeclaration(node);
        }

        public override SyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node)
        {
            _yield = new IsYieldVisitor().Visit(node.Body);
            Init();
            return base.VisitAccessorDeclaration(node);
        }

        private IfStatementSyntax BuildIfFromExpressionsToTest()
        {
            if (_expressionsToTest.Count == 0)
                return null;
            var value = SyntaxFactory.IfStatement(
                BuildExpressionsToTest(),
                    _yield ?
                        SyntaxFactory.ParseStatement("yield break;") :
                        SyntaxFactory.ReturnStatement(
                            _returnType == null ? null : (_returnType.ToString().Length == 0 ? (ExpressionSyntax)SyntaxFactory.IdentifierName("null") : SyntaxFactory.DefaultExpression(_returnType))));
            foreach (var expressionToTest in _expressionsToTest)
            {
                _alreadyTestedNullableExpressions.Add(expressionToTest);
                var originalValue = _replaceNode.Where(kvp => kvp.Value == expressionToTest).Select(kvp => kvp.Key).FirstOrDefault();
                if (originalValue != null)
                    _alreadyTestedNullableExpressions.Add(originalValue);
            }
            _expressionsToTest.Clear();
            return value;
        }

        private ExpressionSyntax BuildConditionFromExpressionsToTest(ExpressionSyntax expression)
        {
            if (_expressionsToTest.Count == 0)
                return expression;
            var value =
                SyntaxFactory.ParenthesizedExpression(
                    SyntaxFactory.ConditionalExpression(
                        SyntaxFactory.ParenthesizedExpression(
                            BuildExpressionsToTest()),
                        SyntaxFactory.DefaultExpression(_returnType),
                        expression));
            _expressionsToTest.Clear();
            return value;
        }

        private ExpressionSyntax BuildExpressionsToTest()
        {
            return _expressionsToTest.Select(e => SyntaxFactory.ParseExpression(e + " == null")).Aggregate((e1, e2) => SyntaxFactory.BinaryExpression(SyntaxKind.LogicalOrExpression, e1, e2));
        }

        private void AddStatement(StatementSyntax statement, int? index = null)
        {
            if (statement == null)
                return;
            List<StatementSyntax> statements;
            if (!_statementsToAdd.TryGetValue(_currentStatement, out statements))
                _statementsToAdd.Add(_currentStatement, statements = new List<StatementSyntax>());
            if (index.HasValue)
                statements.Insert(index.Value, statement);
            else
                statements.Add(statement);
        }

        public override SyntaxNode VisitBlock(BlockSyntax node)
        {
            List<StatementSyntax> statements;
            if (VisitStatements(node.Statements, out statements))
                return SyntaxFactory.Block(statements.Where(s => s != null));
            return node;
        }

        private bool VisitStatements(IEnumerable<StatementSyntax> nodeStatements, out List<StatementSyntax> statements)
        {
            bool changed = false;
            statements = new List<StatementSyntax>();
            var testNull = new TestNull(this);
            foreach (var statement in nodeStatements)
            {
                var newStatement = (StatementSyntax)testNull.Visit(statement);
                List<StatementSyntax> statementsToAdd;
                if (testNull._statementsToAdd.TryGetValue(statement, out statementsToAdd))
                {
                    changed = true;
                    statements.AddRange(statementsToAdd);
                    foreach (var alreadyTestedNullableExpression in testNull._alreadyTestedNullableExpressions)
                        _alreadyTestedNullableExpressions.Add(alreadyTestedNullableExpression);
                }
                if (newStatement != statement)
                    changed = true;
                statements.Add(newStatement);
            }
            ApplyRemoveStatements(testNull);
            return changed;
        }

        public static bool IsNullable(ITypeSymbol type)
        {
            if (type == null)
                return false;
            return !type.IsValueType || IsNullableType(type);
        }

        public static bool IsNullableType(ITypeSymbol type)
        {
            string namedTypeSymbolName;
            NamedTypeSymbol namedTypeSymbol;
            return (namedTypeSymbol = type as NamedTypeSymbol) != null && namedTypeSymbol.IsGenericType && ((namedTypeSymbolName = type.ToString()).StartsWith("System.Nullable<") || namedTypeSymbolName.EndsWith("?"));
        }

        public override SyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
        {
            var value = (MemberAccessExpressionSyntax)base.VisitMemberAccessExpression(node);
            PropertySymbol propertySymbol;
            if ((propertySymbol = _semanticModel.GetSymbolInfo(node).Symbol as PropertySymbol) != null && IsNullable(propertySymbol.Type) && node.Parent is MemberAccessExpressionSyntax && !(node.Expression is ThisExpressionSyntax))
            {
                var parentPropertySymbol = _semanticModel.GetSymbolInfo(node.Parent).Symbol as PropertySymbol;
                if (parentPropertySymbol == null || parentPropertySymbol.Name != "HasValue" || parentPropertySymbol.ContainingType == null || !IsNullableType(parentPropertySymbol.ContainingType))
                    AddExpressionToTest(value);
            }
            else if (!(node.Expression is ThisExpressionSyntax) && IsNullable(_semanticModel.GetTypeInfo(node.Expression).Type))
            {
                var ancestor = node.Parent;
                ClassDeclarationSyntax classDeclaration = null;
                while ((ancestor = ancestor.Parent) != null && (classDeclaration = ancestor as ClassDeclarationSyntax) == null)
                    ;
                ISymbol symbol;
                if (propertySymbol != null && !(node.Expression is ThisExpressionSyntax) && !(node.Parent is MemberAccessExpressionSyntax) && !(node.Parent is InvocationExpressionSyntax && node.Parent.Parent is MemberAccessExpressionSyntax) && classDeclaration != null && (symbol = _semanticModel.GetSymbolInfo(node.Expression).Symbol) != null && symbol.ContainingType != null && _semanticModel.GetDeclaredSymbol(classDeclaration).ToString() == symbol.ContainingType.ToString())
                    AddExpressionToTest(value.Expression);
                else if (node.Expression is InvocationExpressionSyntax && !IsLINQ(node.Expression))
                    AddExpressionToTest(value.Expression);
            }
            return value;
        }

        public override SyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node)
        {
            var value = base.VisitElementAccessExpression(node);
            var nodeString = node.ToString();
            if (node.Parent is MemberAccessExpressionSyntax && !(_expressionsToTest.Contains(nodeString) || _alreadyTestedNullableExpressions.Contains(nodeString)))
                AddExpressionToTest(node);
            return value;
        }

        public override SyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
        {
            if (node.Parent is MemberAccessExpressionSyntax)
            {
                var symbol = _semanticModel.GetSymbolInfo(node).Symbol;
                var parameterSymbol = symbol as ParameterSymbol;
                ILocalSymbol localSymbol;
                IRangeVariableSymbol rangeVariableSymbol;
                if (parameterSymbol != null)
                {
                    if (IsNullable(parameterSymbol.Type) && !(_expressionsToTest.Contains(node.Identifier.ValueText) || _alreadyTestedNullableExpressions.Contains(node.Identifier.ValueText)))
                        _expressionsToTest.Add(node.Identifier.ValueText);
                }
                else if ((localSymbol = symbol as ILocalSymbol) != null)
                {
                    if (GetKind(node.Parent) != SyntaxKindAssignExpression && IsNullable(localSymbol.Type) && !(_expressionsToTest.Contains(node.Identifier.ValueText) || _alreadyTestedNullableExpressions.Contains(node.Identifier.ValueText)))
                        _expressionsToTest.Add(node.Identifier.ValueText);
                }
                else if ((rangeVariableSymbol = symbol as IRangeVariableSymbol) != null)
                {
                    if (GetKind(node.Parent) != SyntaxKindAssignExpression && IsNullable(_semanticModel.GetTypeInfo(node).Type) && !(_expressionsToTest.Contains(node.Identifier.ValueText) || _alreadyTestedNullableExpressions.Contains(node.Identifier.ValueText)))
                        _expressionsToTest.Add(node.Identifier.ValueText);
                }
            }
            return base.VisitIdentifierName(node);
        }

        private bool IsLINQ(SyntaxNode node)
        {
            ParenthesizedExpressionSyntax parenthesisExpression;
            while ((parenthesisExpression = node as ParenthesizedExpressionSyntax) != null)
                node = parenthesisExpression.Expression;
            if (node is QueryExpressionSyntax)
                return true;
            var invocationExpression = node as InvocationExpressionSyntax;
            if (invocationExpression != null)
            {
                var methodSymbol = (MethodSymbol)_semanticModel.GetSymbolInfo(invocationExpression).Symbol;
                if (methodSymbol != null && methodSymbol.ContainingType.ToString() == "System.Linq.Enumerable" && methodSymbol.ReturnType.ToString() != "System.String" && methodSymbol.ReturnType.AllInterfaces.Any(i => i.ToString() == "System.Collections.IEnumerable"))
                    return true;
            }
            var binaryExp = node as BinaryExpressionSyntax;
            if (binaryExp != null && GetKind(binaryExp) == SyntaxKindAssignExpression)
                return IsLINQ(binaryExp.Right);
            return false;
        }

        public override SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
        {
            if (IsIQueryable(_semanticModel.GetTypeInfo(node).Type))
            {
                var expression = (ExpressionSyntax)Visit(node.Expression);
                return node.WithExpression(expression);
            }
            if (IsLINQ(node))
            {
                var expression = (ExpressionSyntax)Visit(node.Expression);
                return node.WithExpression(expression).WithArgumentList(SyntaxFactory.ArgumentList(SyntaxFactory.SeparatedList(node.ArgumentList.Arguments.Select(a => (ArgumentSyntax)new TestNull(this).Visit(a)), node.ArgumentList.Arguments.Skip(1).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken)))));
            }
            var value = (InvocationExpressionSyntax)base.VisitInvocationExpression(node);
            foreach (var argument in value.ArgumentList.Arguments)
                if (GetKind(argument.RefOrOutKeyword) != SyntaxKind.None)
                    RemoveAlreadyTestedVariable(argument.Expression.ToString());
            var methodSymbol = (MethodSymbol)_semanticModel.GetSymbolInfo(node).Symbol;
            if (node.Parent is MemberAccessExpressionSyntax || node.Parent is FromClauseSyntax || node.Parent is ForEachStatementSyntax)
            {
                if (methodSymbol == null)
                    return node;
                var valueString = GetExpressionString(value);
                string variable;
                bool variableFound = _replaceNode.TryGetValue(valueString, out variable);
                if (!variableFound)
                {
                    variable = string.Concat("waqsValue", methodSymbol.Name, Guid.NewGuid().ToString("N"));
                    _replaceNode.Add(valueString, variable);
                }
                if (_expressionsToTest.Count != 0)
                    AddStatement(BuildIfFromExpressionsToTest());
                if (!variableFound)
                    AddStatement(SyntaxFactory.ParseStatement(string.Concat("var ", variable, " = ", valueString, ";")));
                return SyntaxFactory.IdentifierName(variable);
            }
            var nodeExpressionMemberAccessExpression = node.Expression as MemberAccessExpressionSyntax;
            ExpressionSyntax nodeExpressionExpression;
            ISymbol nodeExpressionExpressionSymbol;
            if (nodeExpressionMemberAccessExpression != null && (nodeExpressionExpression = nodeExpressionMemberAccessExpression.Expression) != null && ! IsLINQ(nodeExpressionExpression) && (nodeExpressionExpressionSymbol = _semanticModel.GetSymbolInfo(nodeExpressionExpression).Symbol) != null && !(nodeExpressionExpressionSymbol is ITypeSymbol))
                AddExpressionToTest(nodeExpressionExpression);
            if (_expressionsToTest.Count != 0)
                AddStatement(BuildIfFromExpressionsToTest());
            return value;
        }

        public override SyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
        {
            if (GetKind(node) == SyntaxKind.LogicalNotExpression)
                _not = !_not;
            switch (GetKind(node.OperatorToken))
            {
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                    if (IsNullableType((ITypeSymbol)_semanticModel.GetTypeInfo(node.Operand).Type))
                        AddExpressionToTest(node.Operand);
                    break;
            }
            return base.VisitPrefixUnaryExpression(node);
        }

        public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
        {
            switch (GetKind(node.OperatorToken))
            {
                case SyntaxKind.QuestionQuestionToken:
                    return VisitCoalesce(node);
                case SyntaxKind.BarBarToken:
                    return VisitLogical(node, SyntaxKind.LogicalOrExpression);
                case SyntaxKind.AmpersandAmpersandToken:
                    return VisitLogical(node, SyntaxKind.LogicalAndExpression);
                case SyntaxKind.EqualsToken:
                    var value = (BinaryExpressionSyntax)VisitAssign(node);
                    ITypeSymbol rightType;
                    if (!IsNullableType((ITypeSymbol)_semanticModel.GetTypeInfo(node.Left).Type) && IsNullableType(rightType = (ITypeSymbol)_semanticModel.GetTypeInfo(node.Right).Type))
                    {
                        string valueName = "waqsValue" + Guid.NewGuid().ToString("N");
                        AddStatement(BuildIfFromExpressionsToTest());
                        AddStatement(
                            SyntaxFactory.LocalDeclarationStatement(
                                SyntaxFactory.VariableDeclaration(
                                    SyntaxFactory.ParseTypeName(rightType.ToString()),
                                    SyntaxFactory.SeparatedList(
                                        new []
                                        {
                                            SyntaxFactory.VariableDeclarator(valueName)
                                                    .WithInitializer(
                                                        SyntaxFactory.EqualsValueClause(
                                                            value.Right))
                                        }, 
                                        new SyntaxToken[0]))));
                        _expressionsToTest.Add(valueName);
                        AddStatement(BuildIfFromExpressionsToTest());

                        return SyntaxFactory.AssignmentExpression(
                            SyntaxKindAssignExpression,
                            value.Left,
                            SyntaxFactory.IdentifierName(valueName));
                    }
                    return value;
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.PercentToken:
                case SyntaxKind.PlusEqualsToken:
                case SyntaxKind.MinusEqualsToken:
                case SyntaxKind.AsteriskEqualsToken:
                case SyntaxKind.SlashEqualsToken:
                case SyntaxKind.PercentEqualsToken:
                    if (IsNullableType((ITypeSymbol)_semanticModel.GetTypeInfo(node.Left).Type))
                        AddExpressionToTest(node.Left);
                    if (IsNullableType((ITypeSymbol)_semanticModel.GetTypeInfo(node.Right).Type))
                        AddExpressionToTest(node.Right);
                    AddStatement(BuildIfFromExpressionsToTest());
                    break;
            }

            return base.VisitBinaryExpression(node);
        }

        private SyntaxNode VisitLogical(BinaryExpressionSyntax node, SyntaxKind kind)
        {
            if (_expressionsToTest.Count != 0)
                AddStatement(BuildIfFromExpressionsToTest());

            string waqsLogicalName = _waqsLogical ?? "waqsLogical" + Guid.NewGuid().ToString("N");

            var leftBlock = SyntaxFactory.Block();
            var leftTestNull = new TestNull(this) { _currentStatement = leftBlock, _waqsLogical = waqsLogicalName };
            var leftExpression = (ExpressionSyntax)leftTestNull.Visit(node.Left);
            if (IsNullableType((ITypeSymbol)_semanticModel.GetTypeInfo(node.Left).Type))
                leftTestNull.AddExpressionToTest(leftExpression);

            var rightBlock = SyntaxFactory.Block();
            var rightTestNull = new TestNull(this)
            {
                _currentStatement = rightBlock,
                _alreadyTestedNullableExpressions =
                    new HashSet<string>(leftTestNull._alreadyTestedNullableExpressions.Union(leftTestNull._expressionsToTest).Union(leftTestNull._alreadyTestedNullableExpressionsTmp.Select(e => e.Key))),
                _waqsLogical = GetKind(node) == SyntaxKind.LogicalOrExpression && GetKind(node.Right) == SyntaxKind.LogicalAndExpression || _fromLinq ? null : waqsLogicalName
            };
            var rightExpression = (ExpressionSyntax)rightTestNull.Visit(node.Right);
            if (IsNullableType((ITypeSymbol)_semanticModel.GetTypeInfo(node.Right).Type))
                rightTestNull.AddExpressionToTest(rightExpression);

            List<StatementSyntax> ifNotLeftStatements;
            if (!rightTestNull._statementsToAdd.TryGetValue(rightBlock, out ifNotLeftStatements))
            {
                if (!(node.Parent is ForEachStatementSyntax || node.Parent is ForStatementSyntax || node.Parent is WhileStatementSyntax || node.Parent is DoStatementSyntax) && rightTestNull._expressionsToTest.Count == 0 && !rightTestNull._statementsToAdd.ContainsKey(rightBlock) && leftExpression.NormalizeWhitespace().ToString() == node.Left.NormalizeWhitespace().ToString() && rightExpression.NormalizeWhitespace().ToString() == node.Right.NormalizeWhitespace().ToString())
                {
                    ApplyChanges(leftTestNull, leftBlock);
                    return node;
                }
                ifNotLeftStatements = new List<StatementSyntax>();
            }
            if (_fromLinq)
            {
                rightExpression = rightTestNull.MakeCondition(rightExpression);
                var value = leftTestNull.MakeCondition(
                    SyntaxFactory.BinaryExpression(
                        kind,
                        leftExpression,
                        rightExpression));
                foreach (var leftAlreadyTested in _expressionsToTest)
                    _alreadyTestedNullableExpressions.Add(leftAlreadyTested);
                if (kind == SyntaxKind.LogicalAndExpression)
                    foreach (var rightAlreadyTested in rightTestNull._alreadyTestedNullableExpressions)
                        _alreadyTestedNullableExpressions.Add(rightAlreadyTested);
                return value;
            }

            ApplyChanges(leftTestNull, leftBlock);

            var statementsToAdd = new List<StatementSyntax>();

            ApplyRemoveStatements(rightTestNull);

            ifNotLeftStatements.Add(rightTestNull.BuildIfFromExpressionsToTest());
            ifNotLeftStatements.Add(
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.AssignmentExpression(
                        SyntaxKindAssignExpression,
                        SyntaxFactory.IdentifierName(waqsLogicalName),
                        rightExpression)));
            var leftExpressionIdentifierName = leftExpression as IdentifierNameSyntax;
            if (leftExpressionIdentifierName == null || leftExpressionIdentifierName.Identifier.ValueText != waqsLogicalName)
            {
                statementsToAdd.Add(
                    SyntaxFactory.LocalDeclarationStatement(
                        SyntaxFactory.VariableDeclaration(
                            SyntaxFactory.ParseTypeName("bool"),
                            SyntaxFactory.SeparatedList(
                                new [] 
                                {
                                    SyntaxFactory.VariableDeclarator(waqsLogicalName)
                                            .WithInitializer(
                                                SyntaxFactory.EqualsValueClause(
                                                    leftExpression))
                                },
                                new SyntaxToken[0]))));

                statementsToAdd.Add(
                    SyntaxFactory.IfStatement(
                        SyntaxFactory.ParseExpression((kind == SyntaxKind.LogicalOrExpression ? "!" : "") + waqsLogicalName),
                            SyntaxFactory.Block(
                                ifNotLeftStatements.Where(s => s != null))));
            }
            else
            {
                var statementsToAddTmp = _statementsToAdd[_currentStatement];
                int statementIndex = statementsToAddTmp.Count - 1;
                IfStatementSyntax ifStatement;
                while ((ifStatement = (IfStatementSyntax)statementsToAddTmp[statementIndex]) == null)
                    statementsToAddTmp.RemoveAt(statementIndex--);
                statementsToAddTmp[statementIndex] =
                    ifStatement
                        .WithStatement(
                            SyntaxFactory.Block(((BlockSyntax)ifStatement.Statement).Statements.Union(
                                new[] 
                                    { 
                                        SyntaxFactory.IfStatement(
                                            SyntaxFactory.ParseExpression((kind == SyntaxKind.LogicalOrExpression ? "!" : "") + waqsLogicalName),
                                            SyntaxFactory.Block(
                                                ifNotLeftStatements.Where(s => s != null)))
                                    }).Where(s => s != null)));
            }

            var nodeParent = node.Parent;
            if (GetKind(nodeParent) == SyntaxKind.LogicalNotExpression)
                nodeParent = nodeParent.Parent;
            var binaryParentNode = nodeParent as BinaryExpressionSyntax;
            SyntaxKind binaryParentKind;
            if (binaryParentNode != null && ((binaryParentKind = GetKind(binaryParentNode)) == SyntaxKind.LogicalOrExpression || binaryParentKind == SyntaxKind.LogicalAndExpression))
                foreach (var alreadyTestedNullableExp in rightTestNull._alreadyTestedNullableExpressions.Where(e => !_alreadyTestedNullableExpressions.Contains(e) && !_alreadyTestedNullableExpressionsTmp.ContainsKey(e)))
                    _alreadyTestedNullableExpressionsTmp.Add(alreadyTestedNullableExp, GetKind(node));

            foreach (var statementToAdd in statementsToAdd)
                AddStatement(statementToAdd);

            return SyntaxFactory.IdentifierName(waqsLogicalName);
        }

        private ExpressionSyntax MakeCondition(ExpressionSyntax exp)
        {
            List<ExpressionSyntax> expressionsToTest;
            List<StatementSyntax> addedStatements;
            if (_statementsToAdd.TryGetValue(_currentStatement, out addedStatements))
            {
                expressionsToTest = new List<ExpressionSyntax>();
                foreach (var e in addedStatements.OfType<IfStatementSyntax>())
                    expressionsToTest.Add(e.Condition);
                foreach (var e in _expressionsToTest.Select(e => SyntaxFactory.ParseExpression(e + " == null")))
                    expressionsToTest.Add(e);
            }
            else
                expressionsToTest = _expressionsToTest.Select(e => SyntaxFactory.ParseExpression(e + " == null")).ToList();
            if (expressionsToTest.Count == 0)
                return exp;
            ExpressionSyntax expressionToTest =
                SyntaxFactory.ParenthesizedExpression(
                    expressionsToTest.Aggregate((e1, e2) =>
                        SyntaxFactory.BinaryExpression(
                            SyntaxKind.LogicalOrExpression,
                            e1,
                            e2)));
            if (_not)
                return
                    SyntaxFactory.ParenthesizedExpression(
                        SyntaxFactory.BinaryExpression(
                            SyntaxKind.LogicalOrExpression,
                            expressionToTest,
                            exp));
            return
                SyntaxFactory.BinaryExpression(
                    SyntaxKind.LogicalAndExpression,
                    SyntaxFactory.PrefixUnaryExpression(
                        SyntaxKind.LogicalNotExpression,
                            expressionToTest),
                    exp);
        }

        private SyntaxNode VisitAssign(BinaryExpressionSyntax node)
        {
            var right = (ExpressionSyntax)Visit(node.Right);
            if (!(node.Right is ObjectCreationExpressionSyntax))
            {
                var variableName = GetExpressionString(node.Left);
                if (_expressionsToTest.Contains(variableName))
                    AddStatement(BuildIfFromExpressionsToTest());
                var rightString = GetExpressionString(right);
                if (_alreadyTestedNullableExpressions.Contains(rightString))
                    _alreadyTestedNullableExpressions.Add(variableName);
                else if (!IsLINQ(node.Right))
                    RemoveAlreadyTestedVariable(variableName);
            }
            return SyntaxFactory.AssignmentExpression(
                SyntaxKindAssignExpression,
                node.Left,
                right);
        }

        private void RemoveAlreadyTestedVariable(string variableName)
        {
            foreach (var alreadyTestedNullableExpression in _alreadyTestedNullableExpressions.ToList())
                if (Regex.IsMatch(alreadyTestedNullableExpression, string.Concat("^", variableName, "($|.)")))
                {
                    _alreadyTestedNullableExpressions.Remove(alreadyTestedNullableExpression);
                    _removedAlreadyTestedNullableExpressions.Add(alreadyTestedNullableExpression);
                }
        }

        private SyntaxNode VisitCoalesce(BinaryExpressionSyntax node)
        {
            List<StatementSyntax> statementsToAdd;
            if (!_statementsToAdd.TryGetValue(_currentStatement, out statementsToAdd))
                _statementsToAdd.Add(_currentStatement, statementsToAdd = new List<StatementSyntax>());

            var value = (ExpressionSyntax)Visit(node.Left);

            var rightBlock = SyntaxFactory.Block();
            var rightTestNull = new TestNull(this)
            {
                _currentStatement = rightBlock,
                _statementsToAdd = _statementsToAdd
            };
            var rightExpression = (ExpressionSyntax)rightTestNull.Visit(node.Right);
            ApplyRemoveStatements(rightTestNull);

            if (_expressionsToTest.Count == 0 && rightTestNull._expressionsToTest.Count == 0 && value == node.Left && rightExpression == node.Right)
                return node;

            statementsToAdd.Add(BuildIfFromExpressionsToTest());

            string valueName = "waqsValue" + Guid.NewGuid().ToString("N");
            var nodeTypeString = _semanticModel.GetTypeInfo(node).Type.ToString();
            var nodeLeftTypeString = _semanticModel.GetTypeInfo(node.Left).Type.ToString();
            statementsToAdd.Add(
                SyntaxFactory.LocalDeclarationStatement(
                    SyntaxFactory.VariableDeclaration(
                        SyntaxFactory.ParseTypeName(nodeLeftTypeString),
                        SyntaxFactory.SeparatedList(
                            new []
                            {
                                SyntaxFactory.VariableDeclarator(valueName)
                                        .WithInitializer(
                                            SyntaxFactory.EqualsValueClause(
                                                value))
                            },
                            new SyntaxToken[0]))));

            var rightStatements = new List<StatementSyntax>() { rightTestNull.BuildIfFromExpressionsToTest() };
            List<StatementSyntax> rightAdditionalStatements;
            if (rightTestNull._statementsToAdd.TryGetValue(rightBlock, out rightAdditionalStatements))
                rightStatements.AddRange(rightAdditionalStatements);
            rightStatements.Add(
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.AssignmentExpression(
                        SyntaxKindAssignExpression,
                        SyntaxFactory.IdentifierName(valueName),
                        rightExpression)));

            statementsToAdd.Add(
                SyntaxFactory.IfStatement(
                    SyntaxFactory.BinaryExpression(
                        SyntaxKind.EqualsExpression,
                        SyntaxFactory.IdentifierName(valueName),
                        SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression)),
                    SyntaxFactory.Block(
                        rightStatements.Where(s => s != null))));


            if (nodeTypeString != nodeLeftTypeString)
                return SyntaxFactory.ParseExpression(valueName + ".Value");
            return SyntaxFactory.IdentifierName(valueName);
        }

        public override SyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node)
        {
            var condition = (ExpressionSyntax)Visit(node.Condition);
            var ifTrueBlock = SyntaxFactory.Block();
            var ifTrueTestNull = new TestNull(_semanticModel)
            {
                _currentStatement = ifTrueBlock,
                _alreadyTestedNullableExpressions = new HashSet<string>(_alreadyTestedNullableExpressions.Union(_expressionsToTest).Union(_alreadyTestedNullableExpressionsTmp.Where(e => e.Value == SyntaxKind.LogicalAndExpression).Select(e => e.Key))),
                _returnType = _returnType,
                _yield = _yield,
                _statementsToAdd = _statementsToAdd
            };
            var whenTrueExpression = (ExpressionSyntax)ifTrueTestNull.Visit(node.WhenTrue);
            var ifFalseBlock = SyntaxFactory.Block();
            var ifFalseTestNull = new TestNull(_semanticModel)
            {
                _currentStatement = ifFalseBlock,
                _alreadyTestedNullableExpressions = new HashSet<string>(_alreadyTestedNullableExpressions.Union(_expressionsToTest)),
                _returnType = _returnType,
                _yield = _yield,
                _statementsToAdd = _statementsToAdd
            };
            var whenFalseExpression = (ExpressionSyntax)ifFalseTestNull.Visit(node.WhenFalse);
            ApplyRemoveStatements(ifTrueTestNull);
            ApplyRemoveStatements(ifFalseTestNull);
            if (_expressionsToTest.Count == 0 && ifTrueTestNull._expressionsToTest.Count == 0 && ifFalseTestNull._expressionsToTest.Count == 0 && condition == node.Condition && whenTrueExpression == node.WhenTrue && whenFalseExpression == node.WhenFalse)
                return node;

            List<StatementSyntax> statementsToAdd;
            if (!_statementsToAdd.TryGetValue(_currentStatement, out statementsToAdd))
                _statementsToAdd.Add(_currentStatement, statementsToAdd = new List<StatementSyntax>());

            statementsToAdd.Add(BuildIfFromExpressionsToTest());

            if (_fromLinq)
            {
                if (ifTrueTestNull._statementsToAdd.Count != 0 || ifFalseTestNull._statementsToAdd.Count != 0)
                {
                    IfStatementSyntax ifTrueTest, ifFalseTest;
                    statementsToAdd.Add(
                        SyntaxFactory.IfStatement(
                            SyntaxFactory.ConditionalExpression(
                                condition,
                                ifTrueTestNull._statementsToAdd.Count != 0 && (ifTrueTest = ifTrueTestNull.BuildIfFromExpressionsToTest()) != null ? ifTrueTest.Condition : SyntaxFactory.LiteralExpression(SyntaxKind.FalseLiteralExpression),
                                ifFalseTestNull._statementsToAdd.Count != 0 && (ifFalseTest = ifFalseTestNull.BuildIfFromExpressionsToTest()) != null ? ifFalseTest.Condition : SyntaxFactory.LiteralExpression(SyntaxKind.FalseLiteralExpression)),
                            SyntaxFactory.Block()));
                }
                return SyntaxFactory.ConditionalExpression(
                    condition,
                    whenTrueExpression,
                    whenFalseExpression);
            }
            string valueName = "waqsValue" + Guid.NewGuid().ToString("N");

            statementsToAdd.Add(
                SyntaxFactory.LocalDeclarationStatement(
                    SyntaxFactory.VariableDeclaration(
                        SyntaxFactory.ParseTypeName(_semanticModel.GetTypeInfo(node).Type.ToString()),
                        SyntaxFactory.SeparatedList(
                            new [] { SyntaxFactory.VariableDeclarator(valueName) },
                            new SyntaxToken[0]))));

            List<StatementSyntax> ifTrueStatements;
            if (!ifTrueTestNull._statementsToAdd.TryGetValue(ifTrueBlock, out ifTrueStatements))
                ifTrueStatements = new List<StatementSyntax>();
            if (ifTrueTestNull._expressionsToTest.Count != 0)
                ifTrueStatements.Add(ifTrueTestNull.BuildIfFromExpressionsToTest());
            ifTrueStatements.Add(
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.AssignmentExpression(
                        SyntaxKindAssignExpression,
                        SyntaxFactory.IdentifierName(valueName),
                        whenTrueExpression)));
            List<StatementSyntax> ifFalseStatements;
            if (!ifFalseTestNull._statementsToAdd.TryGetValue(ifFalseBlock, out ifFalseStatements))
                ifFalseStatements = new List<StatementSyntax>();
            if (ifFalseTestNull._expressionsToTest.Count != 0)
                ifFalseStatements.Add(ifFalseTestNull.BuildIfFromExpressionsToTest());
            ifFalseStatements.Add(
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.AssignmentExpression(
                        SyntaxKindAssignExpression,
                        SyntaxFactory.IdentifierName(valueName),
                        whenFalseExpression)));
            statementsToAdd.Add(
                SyntaxFactory.IfStatement(
                    condition,
                    SyntaxFactory.Block(
                        ifTrueStatements.Where(s => s != null)),
                    SyntaxFactory.ElseClause(
                        SyntaxFactory.Block(
                            ifFalseStatements.Where(s => s != null)))));

            return SyntaxFactory.IdentifierName(valueName);
        }

        public override SyntaxNode VisitDoStatement(DoStatementSyntax node)
        {
            var statement = (StatementSyntax)Visit(node.Statement);
            _currentStatement = node;
            var conditionBlock = SyntaxFactory.Block();
            var conditionTestNull = new TestNull(this) { _currentStatement = conditionBlock };
            var condition = (ExpressionSyntax)conditionTestNull.Visit(node.Condition);
            if (conditionTestNull._expressionsToTest.Count != 0)
                conditionTestNull.AddStatement(conditionTestNull.BuildIfFromExpressionsToTest());
            List<StatementSyntax> conditionStatementsToAdd;
            if (conditionTestNull._statementsToAdd.TryGetValue(conditionBlock, out conditionStatementsToAdd) && conditionStatementsToAdd.Count != 0)
            {
                var statementBlock = statement as BlockSyntax;
                List<StatementSyntax> statements;
                if (statementBlock == null)
                    statements = new List<StatementSyntax>() { statement };
                else
                    statements = statementBlock.Statements.ToList();
                statements.AddRange(conditionStatementsToAdd);
                if (conditionStatementsToAdd.OfType<LocalDeclarationStatementSyntax>().Any())
                {
                    string variableName = "waqsTest" + Guid.NewGuid().ToString("N");
                    AddStatement(
                        SyntaxFactory.LocalDeclarationStatement(
                            SyntaxFactory.VariableDeclaration(
                                SyntaxFactory.ParseTypeName("bool"),
                                SyntaxFactory.SeparatedList(
                                    new [] { SyntaxFactory.VariableDeclarator(variableName) },
                                    new SyntaxToken[0]))));
                    statements.Add(
                        SyntaxFactory.ExpressionStatement(
                            SyntaxFactory.AssignmentExpression(
                                SyntaxKindAssignExpression,
                                SyntaxFactory.IdentifierName(variableName),
                                condition)));
                    condition = SyntaxFactory.IdentifierName(variableName);
                }
                statement = SyntaxFactory.Block(statements.Where(s => s != null));
            }
            return SyntaxFactory.DoStatement(statement, condition);
        }

        public override SyntaxNode VisitForStatement(ForStatementSyntax node)
        {
            bool initializersChange = false;
            var initializers = new List<ExpressionSyntax>();
            if (node.Initializers != null)
                foreach (var initializer in node.Initializers)
                {
                    var initializerValue = (ExpressionSyntax)Visit(initializer);
                    initializers.Add(initializerValue);
                    if (initializerValue != initializer)
                        initializersChange = true;
                }

            var declarationValue = (VariableDeclarationSyntax)Visit(node.Declaration);
            List<VariableDeclaratorSyntax> declarations = null;
            if (declarationValue != null)
                declarations = declarationValue.Variables.ToList();
            bool declarationsChange = declarationValue != node.Declaration;

            List<StatementSyntax> statementsToAdd;
            int statementIndex = _statementsToAdd.TryGetValue(_currentStatement, out statementsToAdd) ? statementsToAdd.Count : 0;
            if (_expressionsToTest.Count != 0)
                statementIndex++;

            var condition = (ExpressionSyntax)Visit(node.Condition);

            var incrementors = new List<ExpressionSyntax>();
            bool incrementorsChange = false;
            foreach (var incrementor in node.Incrementors)
            {
                var incrementorValue = (ExpressionSyntax)Visit(incrementor);
                if (incrementorValue != incrementor)
                    incrementorsChange = true;
                incrementors.Add(incrementorValue);
            }

            var statementTestNull = new TestNull(this);
            var statement = (StatementSyntax)statementTestNull.Visit(node.Statement);

            ApplyRemoveStatements(statementTestNull);

            statement = MakeLoopCondition(node.Condition, node.Statement, node.Incrementors, statement, statementTestNull, ref condition, declarationValue, statementIndex, initializers, ref declarations, ref declarationsChange, ref initializersChange, ref incrementors, ref incrementorsChange);

            return SyntaxFactory.ForStatement(
                declarationsChange ?
                    (declarations == null ?
                        null :
                        SyntaxFactory.VariableDeclaration(
                            node.Declaration.Type,
                            SyntaxFactory.SeparatedList(
                                declarations,
                                declarations.Skip(1).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken))))) :
                    node.Declaration,
                initializersChange ?
                    SyntaxFactory.SeparatedList(
                        initializers,
                        initializers.Skip(1).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken))) :
                    node.Initializers,
                condition,
                incrementorsChange ?
                    SyntaxFactory.SeparatedList(
                        incrementors,
                        incrementors.Skip(1).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken))) : node.Incrementors, statement);
        }

        private StatementSyntax MakeLoopCondition(ExpressionSyntax nodeCondition, StatementSyntax nodeStatement, SeparatedSyntaxList<ExpressionSyntax> nodeIncrementors, StatementSyntax statement, TestNull statementTestNull, ref ExpressionSyntax condition, VariableDeclarationSyntax declarationValue, int statementIndex, List<ExpressionSyntax> initializers, ref List<VariableDeclaratorSyntax> declarations, ref bool declarationsChange, ref bool initializersChange, ref List<ExpressionSyntax> incrementors, ref bool incrementorsChange)
        {
            bool changeCondition = false;
            List<StatementSyntax> statementAdditionalStatements;
            if (!(nodeStatement == statement && statementTestNull._expressionsToTest.Count == 0) |
                statementTestNull._statementsToAdd.TryGetValue(nodeStatement, out statementAdditionalStatements) ||
                condition != nodeCondition)
            {
                if (statementAdditionalStatements == null)
                    statementAdditionalStatements = new List<StatementSyntax>();
                if (statementTestNull._expressionsToTest.Count != 0)
                    statementAdditionalStatements.Add(statementTestNull.BuildIfFromExpressionsToTest());
                statementAdditionalStatements.Add(statement);
                if (condition != nodeCondition)
                {
                    _pushInBlock = true;
                    changeCondition = true;
                    if (declarationValue != null)
                    {
                        AddStatement(
                            SyntaxFactory.LocalDeclarationStatement(
                                declarationValue), statementIndex++);
                        declarations = null;
                        declarationsChange = true;
                    }
                    if (initializers != null)
                    {
                        foreach (var initializer in initializers)
                            AddStatement(
                                SyntaxFactory.ExpressionStatement(
                                    initializer), statementIndex++);
                        initializers.Clear();
                        initializersChange = true;
                    }
                    if (incrementors != null)
                    {
                        statementAdditionalStatements.AddRange(
                            incrementors.Select(i => SyntaxFactory.ExpressionStatement(i)));
                        incrementors = new List<ExpressionSyntax>();
                        incrementorsChange = true;
                    }
                    var conditionBlock = SyntaxFactory.Block();
                    var conditionTestNull = new TestNull(this) { _currentStatement = conditionBlock };
                    var newCondition = (ExpressionSyntax)conditionTestNull.Visit(nodeCondition);
                    var conditionIdentifier = condition as IdentifierNameSyntax;
                    string testVariableName;
                    if (conditionIdentifier == null)
                    {
                        if (_expressionsToTest.Count != 0)
                            AddStatement(BuildIfFromExpressionsToTest());
                        testVariableName = "waqsTest" + Guid.NewGuid().ToString("N");
                        AddStatement(SyntaxFactory.ParseStatement(string.Concat("bool ", testVariableName, " = ", condition, ";")));
                        condition = SyntaxFactory.IdentifierName(testVariableName);
                        changeCondition = true;
                    }
                    else
                        testVariableName = conditionIdentifier.Identifier.ValueText;
                    if (conditionTestNull._expressionsToTest.Count != 0)
                        conditionTestNull.AddStatement(conditionTestNull.BuildIfFromExpressionsToTest());
                    List<StatementSyntax> conditionAdditionalStatements;
                    if (conditionTestNull._statementsToAdd.TryGetValue(conditionBlock, out conditionAdditionalStatements))
                        statementAdditionalStatements.AddRange(conditionAdditionalStatements);
                    statementAdditionalStatements.Add(
                        SyntaxFactory.ExpressionStatement(
                            SyntaxFactory.AssignmentExpression(
                                SyntaxKindAssignExpression,
                                SyntaxFactory.IdentifierName(testVariableName),
                                newCondition
                                )));
                }
                if (statementAdditionalStatements.Count > 1)
                    statement = SyntaxFactory.Block(statementAdditionalStatements.Where(s => s != null));
            }
            if (!changeCondition)
            {
                var conditionBlock2 = SyntaxFactory.Block();
                var conditionTestNull2 = new TestNull(this) { _currentStatement = conditionBlock2 };
                conditionTestNull2.Visit(nodeCondition);
                conditionTestNull2.Visit(nodeIncrementors);
                if (!(conditionTestNull2._expressionsToTest.Count == 0 && conditionTestNull2._statementsToAdd.Count == 0))
                {
                    conditionTestNull2.AddStatement(conditionTestNull2.BuildIfFromExpressionsToTest());
                    List<StatementSyntax> statements;
                    var statementAsBlock = statement as BlockSyntax;
                    if (statementAsBlock != null)
                        statements = statementAsBlock.Statements.ToList();
                    else
                        statements = new List<StatementSyntax>() { statement };
                    statements.AddRange(conditionTestNull2._statementsToAdd[conditionBlock2]);
                    statement = SyntaxFactory.Block(statements.Where(s => s != null));
                }
            }
            return statement;
        }

        public override SyntaxNode VisitForEachStatement(ForEachStatementSyntax node)
        {
            var expressionBlock = SyntaxFactory.Block();
            var expressionTestNull = new TestNull(this) { _currentStatement = expressionBlock };
            var expression = (ExpressionSyntax)expressionTestNull.Visit(node.Expression);
            ApplyRemoveStatements(expressionTestNull);

            var statementTestNull = new TestNull(this);
            var statement = (StatementSyntax)statementTestNull.Visit(node.Statement);

            var value = node;

            List<StatementSyntax> statementAdditionalStatements;
            if (!(node.Statement == statement && statementTestNull._expressionsToTest.Count == 0) | statementTestNull._statementsToAdd.TryGetValue(node.Statement, out statementAdditionalStatements))
            {
                if (statementAdditionalStatements == null)
                    statementAdditionalStatements = new List<StatementSyntax>();
                if (statementTestNull._expressionsToTest.Count != 0)
                    statementAdditionalStatements.Add(statementTestNull.BuildIfFromExpressionsToTest());
                statementAdditionalStatements.Add(statement);
                if (statementAdditionalStatements.Count > 1)
                    statement = SyntaxFactory.Block(statementAdditionalStatements.Where(s => s != null));
                value = value.WithStatement(statement);
            }

            ApplyRemoveStatements(statementTestNull);

            List<StatementSyntax> expressionAdditionalStatements;
            if (!expressionTestNull._statementsToAdd.TryGetValue(expressionBlock, out expressionAdditionalStatements))
                expressionAdditionalStatements = new List<StatementSyntax>();

            if (!(node.Expression is QueryExpressionSyntax || IsIQueryable(_semanticModel.GetTypeInfo(node.Expression).Type) || IsLINQ(node.Expression)))
                expressionTestNull.AddExpressionToTest(expression);

            if (expressionTestNull._expressionsToTest.Count != 0)
                expressionAdditionalStatements.Add(expressionTestNull.BuildIfFromExpressionsToTest());

            if (!(node.Expression is QueryExpressionSyntax) && IsIQueryable(_semanticModel.GetTypeInfo(node.Expression).Type))
            {
                expressionAdditionalStatements.Add(expressionTestNull.BuildIfFromExpressionsToTest());
                string variableName = "waqsCollection" + Guid.NewGuid().ToString("N");
                expressionAdditionalStatements.Add(SyntaxFactory.ParseStatement(string.Concat("var ", variableName, " = ", expression.NormalizeWhitespace().ToString(), ";")));
                _expressionsToTest.Add(variableName);
                expressionAdditionalStatements.Add(BuildIfFromExpressionsToTest());
                expression = SyntaxFactory.IdentifierName(variableName);
            }

            _statementsToAdd.Add(node, expressionAdditionalStatements);

            if (node.Expression != expression)
                value = value.WithExpression(expression);

            return value;
        }

        public override SyntaxNode VisitWhileStatement(WhileStatementSyntax node)
        {
            var condition = (ExpressionSyntax)Visit(node.Condition);

            int index = _statementsToAdd.Count;
            if (_expressionsToTest.Count != 0)
                index++;

            var statementTestNull = new TestNull(this);
            var statement = (StatementSyntax)statementTestNull.Visit(node.Statement);

            ApplyRemoveStatements(statementTestNull);

            List<VariableDeclaratorSyntax> declarations = null;
            bool declarationsChange = false;
            bool initializersChange = false;
            List<ExpressionSyntax> incrementors = null;
            bool incrementorsChange = false;
            statement = MakeLoopCondition(node.Condition, node.Statement, SyntaxFactory.SeparatedList<ExpressionSyntax>(), statement, statementTestNull, ref condition, null, index, null, ref declarations, ref declarationsChange, ref initializersChange, ref incrementors, ref incrementorsChange);

            _pushInBlock = false;

            return SyntaxFactory.WhileStatement(condition, statement);
        }

        public override SyntaxNode VisitIfStatement(IfStatementSyntax node)
        {
            var condition = (ExpressionSyntax)Visit(node.Condition);
            var statementTestNull = new TestNull(_semanticModel)
            {
                _currentStatement = _currentStatement,
                _alreadyTestedNullableExpressions = new HashSet<string>(_alreadyTestedNullableExpressions.Union(_expressionsToTest).Union(_alreadyTestedNullableExpressionsTmp.Where(e => e.Value == SyntaxKind.LogicalAndExpression).Select(e => e.Key))),
                _returnType = _returnType,
                _yield = _yield,
                _statementsToAdd = _statementsToAdd
            };
            var statement = (StatementSyntax)statementTestNull.Visit(node.Statement);
            List<StatementSyntax> additionalStatements;
            if (!statementTestNull._statementsToAdd.TryGetValue(node.Statement, out additionalStatements))
                additionalStatements = new List<StatementSyntax>();
            if (!(statementTestNull._expressionsToTest == null || statementTestNull._expressionsToTest.Count == 0))
                additionalStatements.Add(statementTestNull.BuildIfFromExpressionsToTest());
            if (additionalStatements.Count != 0)
            {
                additionalStatements.Add(statement);
                statement = SyntaxFactory.Block(additionalStatements.Where(s => s != null));
            }
            var result = SyntaxFactory.IfStatement(condition, statement);
            if (node.Else != null)
            {
                var elseClauseTestNull = new TestNull(this) { _statementsToAdd = _statementsToAdd };
                var elseClauseStatement = (StatementSyntax)elseClauseTestNull.Visit(node.Else.Statement);
                List<StatementSyntax> elseAdditionalStatements;
                if (!elseClauseTestNull._statementsToAdd.TryGetValue(node.Else.Statement, out elseAdditionalStatements))
                    elseAdditionalStatements = new List<StatementSyntax>();
                if (!(elseClauseTestNull._expressionsToTest == null || elseClauseTestNull._expressionsToTest.Count == 0))
                    elseAdditionalStatements.Add(elseClauseTestNull.BuildIfFromExpressionsToTest());
                ElseClauseSyntax elseClause;
                if (elseAdditionalStatements.Count == 0)
                    elseClause = SyntaxFactory.ElseClause(elseClauseStatement);
                else
                {
                    var elseStatementBlock = elseClauseStatement as BlockSyntax;
                    if (elseStatementBlock == null)
                        elseAdditionalStatements.Add(elseClauseStatement);
                    else
                        elseAdditionalStatements.AddRange(elseStatementBlock.Statements);
                    var elseBlock = SyntaxFactory.Block();
                    elseBlock = elseBlock.AddStatements(elseAdditionalStatements.Where(s => s != null).ToArray());
                    elseClause = SyntaxFactory.ElseClause(elseBlock);
                }
                result = result.WithElse(elseClause);
                ApplyRemoveStatements(elseClauseTestNull);
                foreach (var additionalAlreadyTest in elseClauseTestNull._alreadyTestedNullableExpressions.Intersect(statementTestNull._alreadyTestedNullableExpressions).Except(_alreadyTestedNullableExpressions).ToList())
                    _alreadyTestedNullableExpressions.Add(additionalAlreadyTest);
            }
            ApplyRemoveStatements(statementTestNull);
            return result;
        }

        public override SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
        {
            EqualsValueClauseSyntax equalsValueClause;
            if (GetKind(node.Parent) == SyntaxKindAssignExpression)
            {
                var binaryParentLeft = ((BinaryExpressionSyntax)node.Parent).Left;
                var identifierName = binaryParentLeft as IdentifierNameSyntax;
                if (identifierName != null)
                    _alreadyTestedNullableExpressions.Add(identifierName.Identifier.ValueText);
                else
                    throw new NotImplementedException();
            }
            else if ((equalsValueClause = node.Parent as EqualsValueClauseSyntax) != null)
            {
                var variableDeclarator = equalsValueClause.Parent as VariableDeclaratorSyntax;
                if (variableDeclarator != null)
                    _alreadyTestedNullableExpressions.Add(variableDeclarator.Identifier.ValueText);
                else
                    throw new NotImplementedException();
            }
            return base.VisitObjectCreationExpression(node);
        }

        private bool IsIQueryable(ITypeSymbol type)
        {
            return type.ToString() == "System.Linq.IQueryable" || type.Interfaces.Any(i => i.ToString() == "System.Linq.IQueryable");
        }

        public override SyntaxNode VisitQueryExpression(QueryExpressionSyntax node)
        {
            if (IsIQueryable(_semanticModel.GetTypeInfo(node).Type))
            {
                var @from = (FromClauseSyntax)Visit(node.FromClause);
                return node.WithFromClause(@from);
            }
            bool fromLinq = _fromLinq;
            _fromLinq = true;

            var fromBlock = SyntaxFactory.Block();
            var visitor = new TestNull(this) { _currentStatement = fromBlock };
            var newFrom = (FromClauseSyntax)visitor.Visit(node.FromClause);
            if (visitor._expressionsToTest.Count != 0)
                visitor.AddStatement(visitor.BuildIfFromExpressionsToTest());
            List<StatementSyntax> fromAdditionalStatements;
            if (visitor._statementsToAdd.TryGetValue(fromBlock, out fromAdditionalStatements))
                foreach (var s in fromAdditionalStatements)
                    AddStatement(s);

            var value = SyntaxFactory.QueryExpression(newFrom, (QueryBodySyntax)visitor.Visit(node.Body));
            _fromLinq = fromLinq;
            return value;
        }

        public override SyntaxNode VisitFromClause(FromClauseSyntax node)
        {
            var expression = (ExpressionSyntax)Visit(node.Expression);
            MemberAccessExpressionSyntax memberAccessExpression;
            InvocationExpressionSyntax invocationExpression;
            if (!((memberAccessExpression = node.Expression as MemberAccessExpressionSyntax) != null && memberAccessExpression.Expression != null && IsIQueryable(_semanticModel.GetTypeInfo(memberAccessExpression.Expression).Type) || (invocationExpression = node.Expression as InvocationExpressionSyntax) != null && (memberAccessExpression = invocationExpression.Expression as MemberAccessExpressionSyntax) != null && memberAccessExpression.Expression != null && IsIQueryable(_semanticModel.GetTypeInfo(memberAccessExpression.Expression).Type) || IsLINQ(node.Expression)))
                AddExpressionToTest(expression);
            AddStatement(BuildIfFromExpressionsToTest());
            return SyntaxFactory.FromClause(node.Identifier, expression);
        }

        public override SyntaxNode VisitQueryBody(QueryBodySyntax node)
        {
            var clauses = new List<QueryClauseSyntax>();
            foreach (var clause in node.Clauses)
            {
                var clauseBlock = SyntaxFactory.Block();
                var clauseTestNull = new TestNull(this) { _currentStatement = clauseBlock };
                var newClause = (QueryClauseSyntax)clauseTestNull.Visit(clause);
                if (clauseTestNull._expressionsToTest.Count != 0)
                    clauseTestNull.AddStatement(clauseTestNull.BuildIfFromExpressionsToTest());
                List<StatementSyntax> clauseAdditionalStatements;
                if (clauseTestNull._statementsToAdd.TryGetValue(clauseBlock, out clauseAdditionalStatements))
                    clauses.AddRange(ConvertToQueryClauses(clauseAdditionalStatements));
                clauses.Add(newClause);
                foreach (var alreadyTested in clauseTestNull._alreadyTestedNullableExpressions)
                    _alreadyTestedNullableExpressions.Add(alreadyTested);
                ApplyRemoveStatements(clauseTestNull);

            }

            var queryContinuationBlock = SyntaxFactory.Block();
            var queryContinuationTestNull = new TestNull(this) { _currentStatement = queryContinuationBlock };
            var queryContinuation = (QueryContinuationSyntax)queryContinuationTestNull.Visit(node.Continuation);
            ApplyRemoveStatements(queryContinuationTestNull);

            var selectOrGroupBlock = SyntaxFactory.Block();
            var selectOrGroupTestNull = new TestNull(this) { _currentStatement = selectOrGroupBlock };
            var selectOrGroup = (SelectOrGroupClauseSyntax)selectOrGroupTestNull.Visit(node.SelectOrGroup);
            if (selectOrGroupTestNull._expressionsToTest.Count != 0)
                selectOrGroupTestNull.AddStatement(selectOrGroupTestNull.BuildIfFromExpressionsToTest());

            ApplyRemoveStatements(selectOrGroupTestNull);
            List<StatementSyntax> selectOrGroupTestNullAdditionalStatements;
            if (selectOrGroupTestNull._statementsToAdd.TryGetValue(selectOrGroupBlock, out selectOrGroupTestNullAdditionalStatements))
                clauses.AddRange(ConvertToQueryClauses(selectOrGroupTestNullAdditionalStatements));

            return SyntaxFactory.QueryBody(SyntaxFactory.List<QueryClauseSyntax>(clauses), selectOrGroup, queryContinuation);
        }

        private IEnumerable<QueryClauseSyntax> ConvertToQueryClauses(IEnumerable<StatementSyntax> statements)
        {
            var statementsEnumerator = statements.GetEnumerator();
            while (statementsEnumerator.MoveNext())
            {
                var statement = statementsEnumerator.Current;
                if (statement == null)
                    continue;
                var localDeclaration = statement as LocalDeclarationStatementSyntax;
                IfStatementSyntax ifStatement;
                if (localDeclaration != null)
                {
                    var variable = localDeclaration.Declaration.Variables.Single();
                    yield return SyntaxFactory.LetClause(variable.Identifier, variable.Initializer.Value);
                }
                else if ((ifStatement = statement as IfStatementSyntax) != null)
                {
                    if (ifStatement.Else != null)
                        continue;
                    yield return SyntaxFactory.WhereClause(
                        ifStatement.Condition is IdentifierNameSyntax ?
                        ifStatement.Condition :
                        SyntaxFactory.PrefixUnaryExpression(
                            SyntaxKind.LogicalNotExpression,
                            SyntaxFactory.ParenthesizedExpression(
                                ifStatement.Condition)));
                }
                else
                    throw new NotImplementedException();
            }
        }

        public override SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
        {
            var fromLinq = _fromLinq;
            _fromLinq = false;
            var value = node.WithBody(VisitLambdaBody(node.Body));
            _fromLinq = fromLinq;
            return value;
        }

        public override SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
        {
            var fromLinq = _fromLinq;
            _fromLinq = false;
            var value = node.WithBody(VisitLambdaBody((CSharpSyntaxNode)node.Body));
            _fromLinq = fromLinq;
            return value;
        }

        private CSharpSyntaxNode VisitLambdaBody(SyntaxNode body)
        {
            var block = SyntaxFactory.Block();
            var lambdaSymbol = (MethodSymbol)_semanticModel.GetSymbolInfo(body.Parent).Symbol;
            var testNull = new TestNull(this) { _currentStatement = block, _yield = new IsYieldVisitor().Visit(body), _returnType = lambdaSymbol.ReturnsVoid ? null : SyntaxFactory.ParseTypeName(lambdaSymbol.ReturnType.ToString()) };
            var bodyValue = testNull.Visit(body);
            if (testNull._expressionsToTest.Count != 0)
                testNull.AddStatement(testNull.BuildIfFromExpressionsToTest());
            ApplyRemoveStatements(testNull, false);
            List<StatementSyntax> additionalStatements;
            if (testNull._statementsToAdd.TryGetValue(block, out additionalStatements))
            {
                additionalStatements.Add(lambdaSymbol.ReturnsVoid ? (StatementSyntax)SyntaxFactory.ExpressionStatement((ExpressionSyntax)bodyValue) : SyntaxFactory.ReturnStatement((ExpressionSyntax)bodyValue));
                return SyntaxFactory.Block(additionalStatements.Where(s => s != null));
            }
            return (CSharpSyntaxNode)bodyValue;
        }

        public override SyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
        {
            var value = (ParenthesizedExpressionSyntax)base.VisitParenthesizedExpression(node);
            if (IsNullable(_semanticModel.GetTypeInfo(node.Expression).Type) && !IsLINQ(node.Expression) && (node.Parent is MemberAccessExpressionSyntax || node.Parent is InvocationExpressionSyntax))
            {
                string waqsValueName;
                if (GetKind(node.Expression) == SyntaxKindAssignExpression)
                {
                    var binaryExp = (BinaryExpressionSyntax)value.Expression;
                    waqsValueName = binaryExp.Left.ToString();
                    if (!IsLINQ(node))
                    {
                        bool changed;
                        AddExpressionToTest(value, out changed);
                        if (changed)
                            return value;
                    }
                }
                else
                {
                    AddStatement(BuildIfFromExpressionsToTest());
                    waqsValueName = "waqsValue" + Guid.NewGuid().ToString("N");
                    AddStatement(
                        SyntaxFactory.LocalDeclarationStatement(
                            SyntaxFactory.VariableDeclaration(
                                SyntaxFactory.ParseTypeName("var"),
                                SyntaxFactory.SeparatedList(
                                    new [] 
                                    {
                                        SyntaxFactory.VariableDeclarator(waqsValueName)
                                                .WithInitializer(
                                                SyntaxFactory.EqualsValueClause(
                                                    value.Expression))
                                    },
                                    new SyntaxToken[0]))));
                    _expressionsToTest.Add(waqsValueName);
                }
                return SyntaxFactory.IdentifierName(waqsValueName);
            }
            return value;
        }

        public override SyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)
        {
            var expression = (ExpressionSyntax)Visit(node.Expression);
            if (_expressionsToTest.Count != 0)
                AddStatement(BuildIfFromExpressionsToTest());
            var switchSections = new List<SwitchSectionSyntax>();
            var sectionTestNulls = new List<TestNull>();
            foreach (var section in node.Sections)
            {
                var sectionBlock = SyntaxFactory.Block();
                var sectionTestNull = new TestNull(this) { _currentStatement = sectionBlock };
                sectionTestNulls.Add(sectionTestNull);
                var newSection = (SwitchSectionSyntax)sectionTestNull.Visit(section);
                switchSections.Add(newSection);
            }
            foreach (var sectionTestNull in sectionTestNulls)
                ApplyRemoveStatements(sectionTestNull);
            if (switchSections.Any(s => s.Labels.Any(l => IsSwitchDefaultLabel(l))))
                foreach (var alreadyTested in sectionTestNulls.Select(s => (IEnumerable<string>)s._alreadyTestedNullableExpressions).Aggregate((atne1, atne2) => atne1.Intersect(atne2)))
                    _alreadyTestedNullableExpressions.Add(alreadyTested);
            return SyntaxFactory.SwitchStatement(expression, SyntaxFactory.List<SwitchSectionSyntax>(switchSections));
        }

        public override SyntaxNode VisitSwitchSection(SwitchSectionSyntax node)
        {
            List<StatementSyntax> statements;
            if (VisitStatements(node.Statements, out statements))
                return node.WithStatements(SyntaxFactory.List<StatementSyntax>(statements.Where(s => s != null)));
            return node;
        }

        public override SyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node)
        {
            var value = (VariableDeclaratorSyntax)base.VisitVariableDeclarator(node);
            IdentifierNameSyntax initializerIdentifier;
            string initializerVariableName;
            if (value.Initializer != null && (initializerIdentifier = value.Initializer.Value as IdentifierNameSyntax) != null && _alreadyTestedNullableExpressions.Contains(initializerVariableName = initializerIdentifier.Identifier.ValueText))
            {
                var pattern = string.Concat("^(", initializerVariableName, @")((.*)?)$");
                foreach (var alreadyTestedNullableExpression in _alreadyTestedNullableExpressions.Where(atn => Regex.IsMatch(atn, pattern)).ToList())
                    _alreadyTestedNullableExpressions.Add(Regex.Replace(alreadyTestedNullableExpression, pattern, m => value.Identifier.ValueText + m.Groups[2].Value));
            }
            return value;
        }
    }

    public class GetSimpleExpression : SyntaxRewriter
    {
        private bool _changed;

        public override SyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
        {
            _changed = false;
            var exp = (ExpressionSyntax)Visit(node.Expression);
            if (exp is IdentifierNameSyntax || _changed)
            {
                _changed = true;
                return exp;
            }
            return base.VisitParenthesizedExpression(node);
        }

        public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
        {
            switch (GetKind(node.OperatorToken))
            {
                case SyntaxKind.EqualsToken:
                    _changed = true;
                    return Visit(node.Right);
            }
            return base.VisitBinaryExpression(node);
        }
    }

    public class IsYieldVisitor : SyntaxVisitorOfBool
    {
        public override bool Visit(SyntaxNode node)
        {
            return node != null && (base.Visit(node) || node.ChildNodes().Any(cn => Visit(cn)));
        }

        public override bool VisitYieldStatement(YieldStatementSyntax node)
        {
            return true;
        }
    }

    class SpecificationsTestNull : TestNull
    {
        public SpecificationsTestNull(ISemanticModel semanticModel, string classPath,
            SpecificationsElements specificationsElements)
            : base(semanticModel)
        {
            ClassName = Path.GetFileNameWithoutExtension(Path.GetFileNameWithoutExtension(classPath));
            SpecificationsElements = specificationsElements;
        }

        protected string ClassName { get; private set; }
        protected SpecificationsElements SpecificationsElements { get; private set; }


        public override SyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
        {
            return node;
        }

        public override SyntaxNode VisitEventDeclaration(EventDeclarationSyntax node)
        {
            return node;
        }

        public override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)
        {
            if (node.Parent is NamespaceDeclarationSyntax)
                return base.VisitClassDeclaration(node);
            return node;
        }

        public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
        {
            if (SpecificationsElements.ExtensionMethods.Any(m => m.Identifier.ValueText == node.Identifier.ValueText &&  SpecificationsElements.MethodSymbolPerMethods[m].Parameters[0].Type.Name == ClassName) || ClassName == "EntitiesOtherSpecifications" && SpecificationsElements.SubMethods.Any(m => m.Identifier.ValueText == node.Identifier.ValueText))
                return base.VisitMethodDeclaration(node);
            return node;
        }
    }

    public class UseServiceVisitor : SyntaxVisitorOfBool
    {
        private ISemanticModel _semanticModel;
        private List<string> _serviceProperties;

        public UseServiceVisitor(ISemanticModel semanticModel, List<string> serviceProperties)
        {
            _semanticModel = semanticModel;
            _serviceProperties = serviceProperties;
        }

        public override bool Visit(SyntaxNode node)
        {
            return base.Visit(node) || node.ChildNodes().Any(c => Visit(c));
        }

        public override bool VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
        {
            if (_serviceProperties.Contains(_semanticModel.GetSymbolInfo(node).Symbol.ToString()))
                return true;
            return base.VisitMemberAccessExpression(node);
        }

        public override bool VisitIdentifierName(IdentifierNameSyntax node)
        {
            if (_serviceProperties.Contains(_semanticModel.GetSymbolInfo(node).Symbol.ToString()))
                return true;
            return base.VisitIdentifierName(node);
        }
    }


IEnumerable<TypeSymbol> GetSubTypes(IEnumerable<TypeSymbol> types, TypeSymbol type)
{
    foreach (var t in types.Where(t2 => t2 != type))
    {
        foreach (var st in GetSubTypes(types, t))
            yield return st;
        if (t.BaseType == type)
            yield return t;
    }
}

public class GetTypeSymbols : SyntaxVisitorOfIEnumerableOfTypeSymbol
{
    private ISemanticModel _semanticModel;

    public GetTypeSymbols(ISemanticModel semanticModel)
    {
        _semanticModel = semanticModel;        
    }

    public override IEnumerable<TypeSymbol> Visit(SyntaxNode node)
    {
        return (base.Visit(node) ?? new TypeSymbol[0]).Union(node.ChildNodes().SelectMany(cn => Visit(cn)));
    }

    public override IEnumerable<TypeSymbol> VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        return new TypeSymbol[] { _semanticModel.GetDeclaredSymbol(node) as TypeSymbol };
    }
}

public class GetNamespaceSymbols : SyntaxVisitorOfIEnumerableOfNamespaceSymbol
{
    private ISemanticModel _semanticModel;

    public GetNamespaceSymbols(ISemanticModel semanticModel)
    {
        _semanticModel = semanticModel;
    }

    public override IEnumerable<NamespaceSymbol> Visit(SyntaxNode node)
    {
        return (base.Visit(node) ?? new NamespaceSymbol[0]).Union(node.ChildNodes().SelectMany(cn => Visit(cn)));
    }

    public override IEnumerable<NamespaceSymbol> VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
        return new NamespaceSymbol[] { _semanticModel.GetDeclaredSymbol(node) as NamespaceSymbol };
    }
}
#>
