<#@ include file="WAQS.Specifications.Entities.ttinclude"#>
<#@ include file="WAQS.DTO.ttinclude"#>
<#@ import namespace="System.Threading"#>
<#+

// Copyright (c) Microsoft Corporation.  All rights reserved.
// Copyright (c) Matthieu MEZIL.  All rights reserved.

void WriteClientEntities(string edmxPath, SpecificationPath[] specificationPathes, SpecificationPath[] dtoPathes, string dtoNamespace, SpecificationPath serverEntitiesPath, string clientFxClientContextInterfacesNamespace, string clientFxClientContextNamespace, string clientFxComponentModelNamespace, string clientFxEntitiesNamespace, string clientFxEntitiesTrackingNamespace, string serverFxCommonNamespace, string serverFxSpecificationsNamespace, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, string serverEntitiesNamespace, Dictionary<string, string> namespacesReplacement, string namespaceName, string entityTypesBaseType = null, string complexTypesBaseType = null, string propertyAttributes = null, int? take = null, int? skip = null, int defaultTake = 50)
{
    DefineMetadata();
    var edmxElements = EdmxElements.Get(Host, ref edmxPath, namespaceName);
    var fileManager = EntityFrameworkTemplateFileManager.Create(this);

    int entityTypesCount = edmxElements.EntityTypes.Where(et => IsPublic(et)).Count();
    int complexTypesCount = edmxElements.ComplexTypes.Where(et => IsPublic(et)).Count();
    
    if (take != null || entityTypesCount + complexTypesCount <= defaultTake)
    {
        var specificationsElements = SpecificationsElements.Get(Host, specificationPathes, serverEntitiesPath, serverFxSpecificationsNamespace, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, serverEntitiesNamespace, edmxElements, SpecificationsElements.Type.Client, getNamespaceFromTypeSymbol: t => (t.ToString() == serverFxCommonNamespace + ".PropertyName") ? clientFxComponentModelNamespace : t.ContainingNamespace.ToString());

        new ClientEntities(Write, Host, () => GenerationEnvironment).WriteClientEntities(edmxElements.EdmxPath, specificationPathes, dtoPathes, dtoNamespace, serverEntitiesPath, clientFxClientContextInterfacesNamespace, clientFxClientContextNamespace, clientFxComponentModelNamespace, clientFxEntitiesNamespace, clientFxEntitiesTrackingNamespace, serverFxCommonNamespace, serverFxSpecificationsNamespace, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, serverEntitiesNamespace, namespacesReplacement, namespaceName, entityTypesBaseType, complexTypesBaseType, propertyAttributes, edmxElements, specificationsElements, GetClasses(dtoPathes).ToList(), GetNamespaces(dtoPathes).Select(n => n.ToString()).ToList(), fileManager, take ?? defaultTake, skip ?? 0);
    
        return;
    }

    skip = 0;
    take = defaultTake - 10 - complexTypesCount;
    if (take < 0)
        take = 0;
    int index = 0;

    string ttMainContent;
    using (var sr = new StreamReader(Host.TemplateFile))
    {
        ttMainContent = sr.ReadToEnd();
    }

    while (skip < entityTypesCount)
    {
        fileManager.StartNewFile(string.Concat(Path.GetFileNameWithoutExtension(Host.TemplateFile), index.ToString(), ".tt"));
        WriteCopyright();
#>
<#=ttMainContent.Replace(");#" + ">", string.Concat(", take:", take, ", skip:", skip, ");#", ">"))#>
<#+
        if (index ++ == 0)
        {
            skip = take;
            take = defaultTake;
        }
        else
            skip += take;
    }
    fileManager.Process();
}

partial class ClientEntities : T4CustomGenerator
{
public ClientEntities(Action<string> write, ITextTemplatingEngineHost host, Func<StringBuilder> getGenerationEnvironment)
    : base(write, host, getGenerationEnvironment)
{
}

public void WriteClientEntities(string edmxPath, SpecificationPath[] specificationPathes, SpecificationPath[] dtoPathes, string dtoNamespace, SpecificationPath serverEntitiesPath, string clientFxClientContextInterfacesNamespace, string clientFxClientContextNamespace, string clientFxComponentModelNamespace, string clientFxEntitiesNamespace, string clientFxEntitiesTrackingNamespace, string serverFxCommonNamespace, string serverFxSpecificationsNamespace, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, string serverEntitiesNamespace, Dictionary<string, string> namespacesReplacement, string namespaceName, string entityTypesBaseType, string complexTypesBaseType, string propertyAttributes, EdmxElements edmxElements, SpecificationsElements specificationsElements, List<TypeSymbol> dtoTypes, List<string> dtoNamespaces, EntityFrameworkTemplateFileManager fileManager, int entityTypesTake, int entityTypesSkip)
{	
    var classesCode = new ConcurrentDictionary<string, StringBuilder>();
    var classesCodeARE = new AutoResetEvent(false);

    Indents = null;
    CurrentFileStringBuilder = null;
    EndsWithNewLine = false;

    _edmxElements = edmxElements;
    _specificationsElements = specificationsElements;
    _serverFxDALInterfacesNamespace = serverFxDALInterfacesNamespace;
    _serverFxServiceInterfacesNamespace = serverFxServiceInterfacesNamespace;

    var ef = edmxElements.MetadataTools;
    var code = edmxElements.Code;

    var interfaceSpecifications = new List<IGrouping<string, NamedTypeSymbol>>();
    var interfaceExtensionMethods = new Dictionary<string, List<MethodDeclarationSyntax>>();
    foreach (var @interface in specificationsElements.InterfacesPerClasses.SelectMany(ipc => ipc.Value.Where(i => ! i.GetAttributes().Any(a => a.ToString() == serverFxSpecificationsNamespace + ".IEntityAttribute"))).GroupBy(i => i.ToString()))
    {
        var extensionMethods = specificationsElements.ExtensionMethods.Where(m => specificationsElements.MethodSymbolPerMethods[m].Parameters[0].Type.ToString () == @interface.Key).ToList();
        if (extensionMethods.Count != 0)
        {
            interfaceSpecifications.Add(@interface);
            interfaceExtensionMethods.Add(@interface.Key, extensionMethods.Where(m => specificationsElements.IsApplicableOnClient(m)).ToList());
        }
    }

    MetadataWorkspace metadataWorkspace;
    bool allMetadataLoaded = edmxElements.Loader.TryLoadAllMetadata(edmxPath, out metadataWorkspace);
    EdmItemCollection itemCollection = (EdmItemCollection)metadataWorkspace.GetItemCollection(DataSpace.CSpace);
    OriginalValueMembers originalValueMembers = new OriginalValueMembers(allMetadataLoaded, metadataWorkspace, ef);

    // Emit Entity Types
    var entityTypes = (
        from et in edmxElements.EntityTypes.Where(e => IsPublic(e)).Select(e => 
        {
            int depth = 0;
            var eLoop = e.BaseType;
            while (eLoop != null)
            {
                depth ++;
                eLoop = (EntityType)eLoop.BaseType;
            }
            return new { EntityType = e, Depth = depth };
        })
        orderby et.Depth, et.EntityType.Name
        select et.EntityType).ToList();

    var complexTypes = itemCollection.GetItems<ComplexType>().Where(c => IsPublic(c)).OrderBy(e => e.Name).ToList();


    var allMembers = new ConcurrentDictionary<string, ConcurrentDictionary<string, List<MemberDeclarationSyntax>>>();
    var allSpecificationsMembers = new ConcurrentDictionary<string, List<MemberDeclarationSyntax>>(); 
    var allSpecificationGetMethodsPerClass = new ConcurrentDictionary<string, List<MethodDeclarationSyntax>>(); 
    var allTasks = new ConcurrentDictionary<string, Task[]>();
    var entityTypesTask = Task.Factory.StartNew(() => 
    Parallel.ForEach(edmxElements.EntityTypes.OrderBy(e => code.Escape(e)).Skip(entityTypesSkip).Take(entityTypesTake), entityType =>
        {
            Indents = null;
            string specBaseTypeName = GetSpecificationsBaseTypeName(code, specificationsElements, entityType);
            string entityTypeName = code.Escape(entityType);
            var members = new ConcurrentDictionary<string, List<MemberDeclarationSyntax>>();
            allMembers.TryAdd(entityTypeName, members);
            List<MethodDeclarationSyntax> specificationGetMethodsPerClass;
            var specificationsMembers = new List<MemberDeclarationSyntax>();

            allTasks.TryAdd(entityTypeName, GetSpecifications(edmxElements.EdmxName, specificationsElements, serverFxSpecificationsNamespace, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, serverEntitiesNamespace, entityType, entityType.Properties, edmxElements, dtoTypes, dtoNamespace, members, specificationsMembers, out specificationGetMethodsPerClass, namespacesReplacement, specBaseTypeName == null ? null : string.Format(" : {0}.{0}Specifications", specBaseTypeName), propertyAttributes).ToArray());
            allSpecificationGetMethodsPerClass.TryAdd(entityTypeName, specificationGetMethodsPerClass);
            allSpecificationsMembers.TryAdd(entityTypeName, specificationsMembers);

        CurrentEdmType = entityType;
        string entityBaseTypeName = entityType.BaseType == null ? null : code.Escape(entityType.BaseType);
        bool hasTemporaryKey = HasCSDLTemporaryKeys(entityType, HostResolvePath);
        var keyNps = entityType.NavigationProperties.Where(navProp => 
            {
                IEnumerable<EdmProperty> fromProperties, toProperties;
                GetNavigationPropertyReferentialConstraintsEnumerables(navProp, out fromProperties, out toProperties);
                return fromProperties.Any(p => entityType.KeyMembers.Any(p2 => code.Escape(p) == code.Escape(p2)));

            }).ToList();
        var couldHaveTemporaryKeyNps = CouldHaveCSDLTemporaryKeysNps(entityType, HostResolvePath).ToList();
        bool couldHaveTemporaryKey = hasTemporaryKey || couldHaveTemporaryKeyNps.Count != 0;
        List<WAQSMetadata> metadata;
        if (! _specificationsElements.Metadata.TryGetValue(entityTypeName, out metadata))
            metadata = new List<WAQSMetadata>();
        IEnumerable<string> usings = new [] { "System", "System.Collections.Generic", "System.Collections.ObjectModel", "System.Collections", "System.Collections.Specialized", "System.ComponentModel", dataAnnotationsNamespace, "System.Linq", "System.Reflection", "System.Runtime.Serialization", "System.Text", clientFxClientContextNamespace, clientFxClientContextInterfacesNamespace, clientFxEntitiesNamespace, clientFxEntitiesTrackingNamespace, clientFxComponentModelNamespace, clientFxClientContextInterfacesNamespace + ".Errors" };
        List<string> specificationMethodsUsings;
        if (specificationsElements.Usings.TryGetValue(entityTypeName, out specificationMethodsUsings))
        {
            bool withDto = false;
            specificationMethodsUsings = specificationMethodsUsings.Where(u => 
                {
                    var value = dtoNamespaces.Contains(u);
                    if (value)
                        withDto = true;
                    return ! value;
                }).Select(u => 
                {
                    string newUsing;
                    if (namespacesReplacement.TryGetValue(u, out newUsing))
                        return newUsing;
                    return u;
                }).ToList();
            if (withDto)
                specificationMethodsUsings.Add(dtoNamespace);
            usings = usings.Union(specificationMethodsUsings);
        }
        CurrentFileStringBuilder = new StringBuilder();

        new WritingFunctions(Write).WriteHeader(PushIndent, namespaceName, code, usings.OrderBy(u => u).ToArray());
        new WritingFunctions(Write).WriteEntityTypeSerializationInfo(entityType, itemCollection, code, ef, string.Format("http://{0}/Entities", edmxElements.EdmxName));
        string classBaseTypeName = entityBaseTypeName;
        if (entityBaseTypeName == null)
            classBaseTypeName = entityTypesBaseType ?? dynamicType; 
        if (classBaseTypeName == null)
            classBaseTypeName = "BindableObject";
        List<MethodDeclarationSyntax> entityTypeGetMethods;
        specificationsElements.GetMethods.TryGetValue(entityTypeName, out entityTypeGetMethods);
#>
public <#=code.SpaceAfter(code.AbstractOption(entityType))#>partial class <#=entityTypeName#> : <#=classBaseTypeName#>, IEntity<#=IsEntityWithErrors(entityType.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == entityType && IsPublic(p)), entityType.NavigationProperties.Where(np => np.DeclaringType == entityType), GetNonOverridenGetMethods(_specificationsElements, entityTypeGetMethods)) ? "WithErrors" : ""#><#+
        List<NamedTypeSymbol> interfaces;
        if (specificationsElements.InterfacesPerClasses.TryGetValue(entityTypeName, out interfaces))
        {
            var interfaceTypes = interfaces.Where(i => specificationsElements.InterfaceSpecifications.Any(i2 => i2.Equals(i))).Select(i => i.Name);
            foreach (var @interface in interfaceTypes)
            {
#>, <#=@interface#>Specifications<#+
            }
        }
#> 
{
<#+
        WriteDynamicTypeMethods(code, entityType);

#>
    #region Simple Properties
<#+
        foreach (EdmProperty edmProperty in entityType.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == entityType && IsPublic(p)))
        {
            string propertyName = code.Escape(edmProperty);
            string fieldName = code.FieldName(edmProperty);
            var hasPropertyDependences = AddOnPropertyChanged(specificationsElements, entityType, propertyName, true, edmxElements, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, true);
#>

    [DataMember]
<#+
            new WritingFunctions(Write).WriteCustomAttributes(PushIndent, PopIndent, propertyAttributes, propertyName, entityTypeName);
            if (IsConcurrencyFixed(edmProperty))
                DisplayAutoGenerateFilterAutoGenerateField(false, false);
#>
    public <#=code.Escape(edmProperty.TypeUsage)#> <#=propertyName#>
    {
        get { return <#=fieldName#>; }
        set
        {
<#+
            bool isRequired = ! edmProperty.Nullable && (edmProperty.TypeUsage.ToString() == "Edm.String" || edmProperty.TypeUsage.ToString() == "Edm.Binary");
            if (ef.ClrType(edmProperty.TypeUsage) == typeof(byte[]) &&
                (ef.IsKey(edmProperty) || entityType.NavigationProperties.Where(np => np.GetDependentProperties().Contains(edmProperty) && IsPublic(np)).Any()))
            {
#>
            if (EqualityComparer.BinaryEquals(<#=fieldName#>, value))
<#+
            }
            else
            {
#>
            if (<#=fieldName#> == value)
<#+
            }
#>
            {
<#+
            var isNullableMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "IsNullable");
            if (isRequired || isNullableMetadata != null)
            {
#>
                if (! (IsDeserializing || ChangeTracker.Saving))
                    Validate<#=propertyName#>Required(value);
<#+
            }
#>
                return;
            }

            On<#=propertyName#>PropertyChanging(ref value);
<#+
            if (hasPropertyDependences)
            {
#>
            if (ChangeTracker.IsDetaching)
                return;
<#+
            }
            if (ef.IsKey(edmProperty))
            {
                string errorMessage = String.Format("The property '{0}' is part of the object's key and cannot be changed. Changes to key properties can only be made when the object is not being tracked or is in the Added state.", edmProperty.Name);
#>
            if (ChangeTracker.ChangeTrackingEnabled && ChangeTracker.State != ObjectState.Added)
                throw new InvalidOperationException("<#=errorMessage#>");
<#+
            }
            else if (originalValueMembers.IsOriginalValueMember(edmProperty))
            {
#>
            if (! IsDeserializing)
                ChangeTracker.RecordOriginalValue("<#=edmProperty.Name#>", <#=fieldName#>);
<#+
            }
            var navigationProperties = entityType.NavigationProperties.Where(np => np.GetDependentProperties().Contains(edmProperty) && IsPublic(np)).ToList();
            if (navigationProperties.Count != 0)
            {
#>
            if (!IsDeserializing)
            {
<#+
                foreach (var np in navigationProperties)
                {
                    EdmProperty principalProperty = ef.GetCorrespondingPrincipalProperty(np, edmProperty);
                    string npName = code.Escape(np);
                    if (ef.ClrType(principalProperty.TypeUsage) == typeof(byte[]))
                    {
#>
                if (<#=npName#> != null && !EqualityComparer.BinaryEquals(<#=npName#>.<#=code.Escape(principalProperty)#>, value))
<#+
                    }
                    else
                    {
#>
                if (<#=npName#> != null && <#=npName#>.<#=code.Escape(principalProperty)#> != value)
<#+
                    }
#>
                {
<#+
                    if (!(np.GetDependentProperties().Where(p => ef.IsNullable(p)).Any() && np.GetDependentProperties().Count() > 1))
                    {
#>
                    <#=npName#> = null;
<#+
                    }
                    else
                    {
#>
                    var previousValue = <#=code.FieldName(np)#>;
                    <#=code.FieldName(np)#> = null;
                    Fixup<#=np.Name#>(previousValue, skipKeys: true);
                    if (! IsInitializingRelationships)
                    {
                        if (value == null || ! value.IsInitializingRelationships)
                            OnNavigationPropertyChanged("<#=np.Name#>");
                        else
                            <#=RaisePropertyChanged(np.Name)#>
                    }
<#+
                    }
#>
                }
<#+
            }
#>
                ChangeTracker.RecordOriginalValue("<#=propertyName#>", <#=fieldName#>);
            }
<#+
        }
        WAQSMetadata minValueMetadata, maxValueMetadata, minLengthMetadata, maxLengthMetadata, patternMetadata;
        int? maxLength;
        if (hasPropertyDependences)
        {
            GetMetadataScalarProperties(edmProperty, propertyName, metadata, out minValueMetadata, out maxValueMetadata, out minLengthMetadata, out maxLengthMetadata, out patternMetadata, out maxLength);
            if (isRequired && isNullableMetadata == null || maxLength.HasValue && maxLengthMetadata == null)
            {
#>
            if (! IsDeserializing)
            {
<#+
            }
            if (isRequired && isNullableMetadata == null)
            {
#>
                Validate<#=propertyName#>Required(value);
<#+
            }
            if (maxLength.HasValue && maxLengthMetadata == null)
            {
#>
                Validate<#=propertyName#>MaxLength(value);
<#+
            }
            if (isRequired && isNullableMetadata == null || maxLength.HasValue && maxLengthMetadata == null)
            {
#>
            }
<#+
            }
        }
        else
            WriteMetadataTestScalarPropertiesConstant(edmProperty, propertyName, metadata, isRequired, isNullableMetadata, out minValueMetadata, out maxValueMetadata, out minLengthMetadata, out maxLengthMetadata, out patternMetadata, out maxLength);
        if (navigationProperties.Any())
        {
#>
            var old<#=propertyName#> = <#=fieldName#>;
<#+
        }
#>
            <#=fieldName#> = value;
            if (! ChangeTracker.Saving)
            {
                On<#=propertyName#>PropertyChanged(value);
<#+
        if (hasPropertyDependences)
        {
#>
                On<#=propertyName#>Changed(validate: ! IsDeserializing);
<#+
        }
        else
        {
#>
                OnPropertyChanged("<#=propertyName#>");
<#+		    
        }
        if (entityType.KeyMembers.Contains(edmProperty) && couldHaveTemporaryKey)
        {
#>
                ResetEntityKey();
<#+
        }
        bool isFk = false;
        foreach (var np in navigationProperties.Where(np2 => np2.GetDependentProperties().Any()))
        {
            isFk = true;
#>
                On<#=np#>FKsChanged(<#=np.GetDependentProperties().Select(d => d == edmProperty ? string.Concat("old", propertyName, ", value") : string.Concat(code.Escape(d), ", ", code.Escape(d))).Aggregate((d1, d2) => string.Concat(d1, ", ", d2))#>);
<#+
        }
        if (isFk)
        {
#>
                RaiseNavigationPropertyChanged("<#=propertyName#>");
<#+
        }
#>
            }
        }
    }
    private <#=code.Escape(edmProperty.TypeUsage)#> <#=fieldName#><#=code.StringBefore(" = ", code.CreateLiteral(edmProperty.DefaultValue))#>;
    partial void On<#=propertyName#>PropertyChanging(ref <#=code.Escape(edmProperty.TypeUsage)#> value);
    partial void On<#=propertyName#>PropertyChanged(<#=code.Escape(edmProperty.TypeUsage)#> value);

<#+
            WriteValidateMethods(edmProperty, propertyName, code, isRequired, maxLength, isNullableMetadata, minValueMetadata, maxValueMetadata, minLengthMetadata, maxLengthMetadata, patternMetadata);
    }
#>
    #endregion

    #region Complex Properties
<#+
    foreach(EdmProperty edmProperty in entityType.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == entityType && IsPublic(p)))
    {
        var complexPropertyName = code.Escape(edmProperty);
        var complexPropertyFieldName = code.FieldName(edmProperty);
        var complexTypeName = code.Escape(edmProperty.TypeUsage);
        var hasPropertyDependences = AddOnPropertyChanged(specificationsElements, entityType, complexPropertyName, true, edmxElements, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, false);
#>
    [DataMember]
<#+
        new WritingFunctions(Write).WriteCustomAttributes(PushIndent, PopIndent, propertyAttributes, complexPropertyName, entityTypeName);
#>
    public <#=complexTypeName#> <#=complexPropertyName#>
    {
        get
        {
            if (!<#=InitializedTrackingField(edmProperty, code)#> && <#=complexPropertyFieldName#> == null)
            {
                <#=complexPropertyFieldName#> = new <#=complexTypeName#>();
                <#=complexPropertyFieldName#>.ChangeTracker = ChangeTracker;
                <#=complexPropertyFieldName#>.ComplexPropertyName = "<#=complexPropertyName#>";
                ((INotifyComplexPropertyChanging)<#=complexPropertyFieldName#>).ComplexPropertyChanging += Handle<#=edmProperty.Name#>Changing;
                On<#=complexPropertyName#>PropertyChanging(null, <#=complexPropertyFieldName#>);
<#+
        if (hasPropertyDependences)
        {
#>
                On<#=complexPropertyName#>Changed(null, <#=complexPropertyFieldName#>, false);
<#+
        }
#>
            }
            <#=InitializedTrackingField(edmProperty, code)#> = true;
            return <#=complexPropertyFieldName#>;
        }
        set
        {
            <#=InitializedTrackingField(edmProperty, code)#> = true;
            if (Equals(<#=complexPropertyFieldName#>, value))
                return;

            On<#=code.Escape(edmProperty)#>Changing(ref value);
            var old<#=complexPropertyName#> = <#=complexPropertyFieldName#>;
            if (<#=complexPropertyFieldName#> != null)
                ((INotifyComplexPropertyChanging)<#=complexPropertyFieldName#>).ComplexPropertyChanging -= Handle<#=edmProperty.Name#>Changing;
            Handle<#=edmProperty.Name#>Changing(this, null);
            <#=complexPropertyFieldName#> = value;
            if (value != null)
            {
                value.ChangeTracker = ChangeTracker;
                value.ComplexPropertyName = "<#=code.Escape(edmProperty)#>";
            }
            if (! ChangeTracker.Saving)
                On<#=complexPropertyName#>Changed(value);
            if (value != null)
                ((INotifyComplexPropertyChanging)<#=complexPropertyFieldName#>).ComplexPropertyChanging += Handle<#=edmProperty.Name#>Changing;
            On<#=complexPropertyName#>PropertyChanging(old<#=complexPropertyName#>, <#=complexPropertyFieldName#>);
<#+
        if (hasPropertyDependences)
        {
#>
            On<#=complexPropertyName#>Changed(old<#=complexPropertyName#>, <#=complexPropertyFieldName#>);
<#+
        }
        else
        {
#>
            OnPropertyChanged("<#=complexPropertyName#>");
<#+
        }
#>
        }
    }
    private <#=complexTypeName#> <#=complexPropertyFieldName#>;
    partial void On<#=complexPropertyName#>Changing(ref <#=complexTypeName#> value);
    partial void On<#=complexPropertyName#>Changed(<#=complexTypeName#> value);
    private bool <#=InitializedTrackingField(edmProperty, code)#>;
    protected virtual void On<#=complexPropertyName#>PropertyChanging(<#=complexTypeName#> oldValue, <#=complexTypeName#> newValue)
    {
        if (<#=complexPropertyName#>PropertyChanging != null)
            <#=complexPropertyName#>PropertyChanging(oldValue, newValue);
    }
    protected internal event Action<<#=complexTypeName#>, <#=complexTypeName#>> <#=complexPropertyName#>PropertyChanging;

<#+
    }
#>
    #endregion

    #region Navigation Properties
<#+
    foreach (NavigationProperty navProperty in entityType.NavigationProperties.Where(np => np.DeclaringType == entityType && IsPublic(np)))
    {
        NavigationProperty inverse = ef.Inverse(navProperty);
        if (inverse != null &&  !IsPublic(inverse))
            inverse = null;

            
        string managed;
        if ((navProperty.FromEndMember.DeleteBehavior == OperationAction.Cascade || navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One) && IsPublic(navProperty))
            managed = "Managed";
        else
            managed = "";

#>

<#+
        var navPropertyName = code.Escape(navProperty);
        var hasPropertyDependences = AddOnPropertyChanged(specificationsElements, entityType, navPropertyName, true, edmxElements, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, false);
        var navPropertyFieldName = code.FieldName(navProperty);
        string navPropTypeName = code.Escape(navProperty.ToEndMember.GetEntityType());
        string navPropTypeFullName;
        if (navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
        {
            navPropTypeFullName = string.Concat("TrackableCollection<", navPropTypeName, ">");
#>
    [DataMember]
<#+
        new WritingFunctions(Write).WriteCustomAttributes(PushIndent, PopIndent, propertyAttributes, navPropertyName, entityTypeName);
#>
    public <#=navPropTypeFullName#> <#=navPropertyName#>
    {
        get
        {
            if (! ChangeTracker.Saving)
                OnGet<#=navPropertyName#>();
            if (OnGet<#=navPropertyName#>Action != null)
                OnGet<#=navPropertyName#>Action();
            if (<#=navPropertyFieldName#> == null)
            {
                <#=navPropertyFieldName#> = new TrackableCollection<<#=navPropTypeName#>>();
                SetFixup<#=navPropertyName#>();
                On<#=navPropertyName#>PropertyChanging(null, <#=navPropertyFieldName#>);
<#+
            if (hasPropertyDependences)
            {
#>
                On<#=navPropertyName#>Changed(null, <#=navPropertyFieldName#>, false);
<#+
            }
#>
                On<#=navPropertyName#>PropertyChanged(null, <#=navPropertyFieldName#>);
            }
            return <#=navPropertyFieldName#>;
        }
        set
        {
            if (ReferenceEquals(<#=navPropertyFieldName#>, value))
                return;

            if (ChangeTracker.ChangeTrackingEnabled)
                throw new InvalidOperationException("Cannot set the FixupChangeTrackingCollection when ChangeTracking is enabled");

            var old<#=navPropertyName#> = <#=navPropertyFieldName#>;

            if (<#=navPropertyFieldName#> != null)
            {
                <#=navPropertyFieldName#>.CollectionChanged -= Fixup<#=navProperty.Name#>;
<#+
            if (ef.IsCascadeDeletePrincipal(navProperty) || navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One)
            {
#>
                foreach (<#=navPropTypeName#> item in <#=navPropertyFieldName#>)
                    ChangeTracker.ObjectStateChanged -= item.Handle<#=managed#>CascadeDelete;
<#+
            }
#>
            }
            <#=navPropertyFieldName#> = value;
            if (<#=navPropertyFieldName#> != null)
            {
                SetFixup<#=navPropertyName#>();
<#+
            if (ef.IsCascadeDeletePrincipal(navProperty) || navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One)
            {
#>
                foreach (<#=navPropTypeName#> item in <#=navPropertyFieldName#>)
                    ChangeTracker.ObjectStateChanged += item.Handle<#=managed#>CascadeDelete;
<#+
            }
#>
            }
            On<#=navPropertyName#>PropertyChanging(old<#=navPropertyName#>, <#=navPropertyFieldName#>);
<#+
            if (hasPropertyDependences)
            {
#>
            On<#=navPropertyName#>Changed(old<#=navPropertyName#>, <#=navPropertyFieldName#>);
<#+
            }
#>
            On<#=navPropertyName#>PropertyChanged(old<#=navPropertyName#>, <#=navPropertyFieldName#>);
            OnNavigationPropertyChanged("<#=navProperty.Name#>");
        }
    }
    partial void OnGet<#=navPropertyName#>();
    public Action OnGet<#=navPropertyName#>Action { get; set; }
    partial void On<#=navPropertyName#>PropertyChanged(TrackableCollection<<#=navPropTypeName#>> oldValue, TrackableCollection<<#=navPropTypeName#>> newValue);
    private TrackableCollection<<#=navPropTypeName#>> <#=navPropertyFieldName#>;

    private void SetFixup<#=navPropertyName#>()
    {
        <#=navPropertyFieldName#>.CollectionChanged += Fixup<#=navProperty.Name#>;
<#+
        if (navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
        {
            var otherNavProp = GetOtherNavigationProperty(navProperty);
            if (otherNavProp != null)
            {
                string npVarName = code.CamelCase(navPropertyName) + "AsITrackableCollection";
#>
        var <#=npVarName#> = (ITrackableCollection<<#=navPropTypeName#>>)<#=navPropertyFieldName#>;
<#+
if (IsPublic(otherNavProp))
{
#>
        <#=npVarName#>.GetWhereExpression = e => e.<#=code.Escape(otherNavProp)#>.Any(e2 => <#=entityType.KeyMembers.Select(km => string.Format("e2.{0} == {0}", code.Escape(km))).Aggregate((km1, km2) => string.Format("{0} && {1}", km1, km2))#>);
<#+
}
#>
        <#=npVarName#>.GetClientContext = () => 
            {
                IClientEntitySet clientEntitySet = ClientEntitySetExtensions.GetClientEntitySet(this);
                return clientEntitySet == null || ChangeTracker.State == ObjectState.Detached ? null : clientEntitySet.Context;
            };
<#+
            }
        }
        else
        {
            var referencialConstraints = ((AssociationType)navProperty.RelationshipType).ReferentialConstraints;
            if (referencialConstraints.Count == 0)
            {
                var otherNavProp = GetOtherNavigationProperty(navProperty);
                if (otherNavProp != null)
                {
                    string npVarName = code.CamelCase(navPropertyName) + "AsITrackableCollection";
#>
        var <#=npVarName#> = (ITrackableCollection<<#=navPropTypeName#>>)<#=navPropertyFieldName#>;
<#+
if (IsPublic(otherNavProp))
{
#>
        <#=npVarName#>.GetWhereExpression = e => <#=entityType.KeyMembers.Select(km => string.Format("e.{0}.{1} == {1}", code.Escape(otherNavProp), code.Escape(km))).Aggregate((km1, km2) => string.Format("{0} && {1}", km1, km2))#>;
<#+
}
#>
        <#=npVarName#>.GetClientContext = () => 
            {
                IClientEntitySet clientEntitySet = ClientEntitySetExtensions.GetClientEntitySet(this);
                return clientEntitySet == null || ChangeTracker.State == ObjectState.Detached ? null : clientEntitySet.Context;
            };
<#+
                }
            }
            else
            {
                var referencialConstraint = referencialConstraints[0]; 
                ReadOnlyMetadataCollection<EdmProperty> fromProps, toProps;
                if (referencialConstraint.FromProperties.All(fp => entityType.KeyMembers.Contains(fp)))
                {
                    fromProps = referencialConstraint.FromProperties;
                    toProps = referencialConstraint.ToProperties;
                }
                else
                {
                    fromProps = referencialConstraint.ToProperties;
                    toProps = referencialConstraint.FromProperties;
                }
                string npVarName = code.CamelCase(navPropertyName) + "AsITrackableCollection";
#>
        var <#=npVarName#> = (ITrackableCollection<<#=navPropTypeName#>>)<#=navPropertyFieldName#>;
        <#=npVarName#>.GetWhereExpression = e => <#=toProps.Select((toProp, index) => string.Format("e.{0} == {1}", code.Escape(toProp), code.Escape(fromProps[index]))).Aggregate((km1, km2) => string.Format("{0} && {1}", km1, km2))#>;
        <#=npVarName#>.GetClientContext = () => 
            {
                IClientEntitySet clientEntitySet = ClientEntitySetExtensions.GetClientEntitySet(this);
                return clientEntitySet == null || ChangeTracker.State == ObjectState.Detached ? null : clientEntitySet.Context;
            };
<#+
            }
        }
#>
    }

<#+
        }
        else
        {
            navPropTypeFullName = navPropTypeName;
#>
    [DataMember]
<#+
        new WritingFunctions(Write).WriteCustomAttributes(PushIndent, PopIndent, propertyAttributes, navPropertyName, entityTypeName);
#>
    public <#=navPropTypeName#> <#=navPropertyName#>
    {
        get { return <#=navPropertyFieldName#>; }
        set
        {
<#+
            bool isRequired = navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One;
#>
            if (ReferenceEquals(<#=navPropertyFieldName#>, value))
            {
<#+
            if (isRequired)
            {
#>
                if (! (IsDeserializing || ChangeTracker.Saving || IsInitializingRelationships || value != null && value.IsInitializingRelationships))
                    Validate<#=navPropertyName#>Required(value);
<#+
            }
#>
                return;
            }

            var old<#=navPropertyName#> = <#=navPropertyFieldName#>;
            if (! ChangeTracker.Saving)
                On<#=navPropertyName#>Changing(ref value);

<#+	
            if (ef.IsPrincipalEndOfIdentifyingRelationship((AssociationEndMember)navProperty.ToEndMember))
            {
#>
            if (ChangeTracker.ChangeTrackingEnabled && ChangeTracker.State != ObjectState.Added && value != null)
            {
<#+
                List<EdmProperty> dependents = navProperty.GetDependentProperties().ToList();
                int dependentCount = dependents.Count;
                StringBuilder keyMatchCondition = new StringBuilder();
                for (int i = 0; i < dependentCount; i++)
                {
                    EdmProperty dependentProperty = dependents[i];
                    EdmProperty principalProperty = ef.GetCorrespondingPrincipalProperty(navProperty, dependentProperty);
                    string escapedDependent = code.Escape(dependentProperty);
                    string escapedPrincipal = code.Escape(principalProperty);

                    if (i > 0)
                        keyMatchCondition.AppendFormat(" || ");

                    string equality = null;
                    if (ef.ClrType(principalProperty.TypeUsage) == typeof(byte[]))
                        equality = "!EqualityComparer.BinaryEquals({0}, value.{1})";
                    else
                        equality = "{0} != value.{1}";
                    keyMatchCondition.AppendFormat(CultureInfo.InvariantCulture, equality, escapedDependent, escapedPrincipal);
                }
#>
                if (<#=keyMatchCondition.ToString()#>)
                    throw new InvalidOperationException("The principal end of an identifying relationship can only be changed when the dependent end is in the Added state.");
            }
<#+
            }
            if (isRequired)
            {
#>
            if (! (IsDeserializing || ChangeTracker.Saving || IsInitializingRelationships || value != null && value.IsInitializingRelationships))
                Validate<#=navPropertyName#>Required(value);
<#+
            }
#>
            <#=navPropertyFieldName#> = value;
            Fixup<#=navPropertyName#>(old<#=navPropertyName#>);
            if (! ChangeTracker.Saving)
            {
                On<#=navPropertyName#>Changed(value);
<#+
            bool npIsInKey = couldHaveTemporaryKey && keyNps.Any(np => code.Escape(np) == navPropertyName);
            if (npIsInKey)
            {
#>
                if (value != null && value.HasTemporaryKey)
                    ResetEntityKey();
<#+
            }
            bool tempKey = npIsInKey && GetFKsFromNavigationProperty(navProperty).Any(fk => TemporaryKeys(entityType, HostResolvePath).Any(pk => fk.Name == pk.Name));
            if (tempKey)
            {
#>
                if (old<#=navPropertyName#> != null)
                    old<#=navPropertyName#>.ChangeTracker.ObjectStateChanged -= <#=navPropertyName#>StateChanged;
                if (value != null && value.HasTemporaryKey)
                    value.ChangeTracker.ObjectStateChanged += <#=navPropertyName#>StateChanged;
<#+
            }
#>
            }
            On<#=navPropertyName#>PropertyChanging(old<#=navPropertyName#>, <#=navPropertyFieldName#>);
<#+
            if (hasPropertyDependences)
            {
#>
            On<#=navPropertyName#>Changed(old<#=navPropertyName#>, <#=navPropertyFieldName#>, raise: IsInitializingRelationships);
<#+
            }
#>
            if (! IsInitializingRelationships)
            {
                if (<#=navPropertyFieldName#> == null || !<#=navPropertyFieldName#>.IsInitializingRelationships)
                    OnNavigationPropertyChanged("<#=navProperty.Name#>");
                else
                    <#=RaisePropertyChanged(navProperty.Name)#>
            }
        }
    }
<#+
    if (tempKey)
    {
#>
    private void <#=navPropertyName#>StateChanged(object sender, ObjectStateChangedEventArgs e)
    {
        if (<#=navPropertyFieldName#> != null && <#=navPropertyFieldName#>.ChangeTracker == sender)
        {
            <#=navPropertyFieldName#>.ChangeTracker.ObjectStateChanged -= <#=navPropertyName#>StateChanged;
            ResetEntityKey();
        }
    }
<#+
    }
#>
    partial void On<#=navPropertyName#>Changing(ref <#=navPropTypeName#> value);
    partial void On<#=navPropertyName#>Changed(<#=navPropTypeName#> value);
    private <#=navPropTypeName#> <#=navPropertyFieldName#>;
<#+
        if (isRequired)
        {
#>
    protected virtual Error Validate<#=navPropertyName#>Required(<#=navPropTypeName#> value)
    {
        var errorInfo = Validators.ValidateRequiredObjectProperty(value, () => <#=navPropertyName#>, <#=dataErrorInfoTypeName#>);
        var error = Errors.<#=navPropertyName#>.FirstOrDefault(e => e.Key == "<#=navPropertyName#>Required");
        if (errorInfo == null)
        {
            if (error != null)
                Errors.<#=navPropertyName#>.Remove(error);
            return null;
        }
        if (error == null)
            Errors.<#=navPropertyName#>.Add(error = new MetadataError { Criticity = Criticity.Mandatory, Key = "<#=navPropertyName#>Required", Message = errorInfo.Message, ErrorInfo = errorInfo });
        return error;
    }

<#+
        }
            if (navProperty.GetDependentProperties().Any())
            {
#>
    protected virtual void On<#=navPropertyName#>FKsChanged(<#=navProperty.GetDependentProperties().Select(dp => string.Concat(code.Escape(dp.TypeUsage), " old", code.Escape(dp), ", ", code.Escape(dp.TypeUsage), " new", code.Escape(dp))).Aggregate((dp1, dp2) => string.Concat(dp1, ", ", dp2))#>)
    {
        if (<#=navPropertyName#>FKsChanged != null)
            <#=navPropertyName#>FKsChanged(this, <#=navProperty.GetDependentProperties().Select(dp => string.Concat("old", code.Escape(dp), ", new", code.Escape(dp))).Aggregate((dp1, dp2) => string.Concat(dp1, ", ", dp2))#>);
    }
    public event Action<<#=entityTypeName#>, <#=navProperty.GetDependentProperties().Select(dp => string.Concat(code.Escape(dp.TypeUsage), ", ", code.Escape(dp.TypeUsage))).Aggregate((dp1, dp2) => string.Concat(dp1, ", ", dp2))#>> <#=navPropertyName#>FKsChanged;
<#+
            }
        }
#>
    protected virtual void On<#=navPropertyName#>PropertyChanging(<#=navPropTypeFullName#> oldValue, <#=navPropTypeFullName#> newValue)
    {
        if (<#=navPropertyName#>PropertyChanging != null)
            <#=navPropertyName#>PropertyChanging(oldValue, newValue);
    }
    protected internal event Action<<#=navPropTypeFullName#>, <#=navPropTypeFullName#>> <#=navPropertyName#>PropertyChanging;

<#+
    }
#>
    #endregion
<#+

    Task[] tasks;
    if (allTasks.TryGetValue(entityTypeName, out tasks))
        Task.WaitAll(tasks);
    var e = tasks.Where(t => t.Exception != null).Select(t => t.Exception).FirstOrDefault();
    if (e != null)
        throw e;

    WriteSpecifications(specificationsElements, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, entityType, edmxElements, allSpecificationGetMethodsPerClass[entityTypeName], metadata, allMembers[entityTypeName], allSpecificationsMembers[entityTypeName]);

#>
    #region ChangeTracking
<#+
    if (entityType.BaseType == null)
    {
#>
    protected virtual void AddValidationProperty(string propertyName)
    {
        if (! ChangeTracker.ValidationProperties.Contains(propertyName))
            ChangeTracker.ValidationProperties.Add(propertyName);
    }

    protected virtual void OnPropertyChanged(string propertyName, bool isTracked = true)
    {
        if (<#= entityType.KeyMembers.Select(km => string.Concat("propertyName != \"", code.Escape(km), "\"")).Aggregate((km1, km2) => string.Concat(km1, " && ", km2)) #> && isTracked && ChangeTracker.ChangeTrackingEnabled && ChangeTracker.State != ObjectState.Added && (ChangeTracker.State & ObjectState.Deleted) == 0)
        {
            if (! (IsDeserializing || ChangeTracker.ModifiedProperties.Contains(propertyName)))
                ChangeTracker.ModifiedProperties.Add(propertyName);
            ChangeTracker.State = ObjectState.Modified;
        }
        NotifyPropertyChanged.RaisePropertyChanged(propertyName);
        OnPropertyChangedExtension(propertyName);
    }
    partial void OnPropertyChangedExtension(string propertyName);

    protected virtual void OnNavigationPropertyChanged(string propertyName)
    {
        NotifyPropertyChanged.RaisePropertyChanged(propertyName);
        OnNavigationPropertyChangedExtension(propertyName);
        RaiseNavigationPropertyChanged(propertyName);
    }
    partial void OnNavigationPropertyChangedExtension(string propertyName);

    protected virtual void RaiseNavigationPropertyChanged(string propertyName)
    {
        if (NavigationPropertyChanged != null)
            NavigationPropertyChanged(this, propertyName);
    }
    public event Action<<#=entityTypeName#>, string> NavigationPropertyChanged;

    private ObjectChangeTracker _changeTracker;
    [DataMember]
<#+
    DisplayAutoGenerateFilterAutoGenerateField(false, false);
#>
    public ObjectChangeTracker ChangeTracker
    {
        get
        {
            if (_changeTracker == null)
            {
                _changeTracker = new ObjectChangeTracker();
<#+
foreach(EdmProperty edmProperty in entityType.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == entityType && IsPublic(p)))
{
#>
                if (<#=code.FieldName(edmProperty)#> != null)
                    <#=code.Escape(edmProperty)#>.ChangeTracker = _changeTracker;
<#+
}
#>
                _changeTracker.ObjectStateChanged += HandleObjectStateChanged;
            }
            return _changeTracker;
        }
        set
        {
            if(_changeTracker != null)
                _changeTracker.ObjectStateChanged -= HandleObjectStateChanged;
            _changeTracker = value;
<#+
foreach(EdmProperty edmProperty in entityType.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == entityType && IsPublic(p)))
{
#>
            if (<#=code.FieldName(edmProperty)#> != null)
                <#=code.Escape(edmProperty)#>.ChangeTracker = value;
<#+
}
#>
            if(_changeTracker != null)
                _changeTracker.ObjectStateChanged += HandleObjectStateChanged;
        }
    }

    private void HandleObjectStateChanged(object sender, ObjectStateChangedEventArgs e)
    {
        switch (e.NewState)
        {
            case ObjectState.Deleted:
            case ObjectState.CascadeDeleted:
                if (ChangeTracker.ChangeTrackingEnabled)
                {
                    IsDeleting = true;
                    ClearNavigationProperties();
                    IsDeleting = false;
                }
                break;
            case ObjectState.Detached:
                ClearNavigationProperties();
                break;
        }
        OnStateChanged(e.NewState);
    }
    
    protected virtual void OnStateChanged(ObjectState state)
    {
        if (StateChanged != null)
            StateChanged(this, state);
    }
    public event Action<IObjectWithChangeTracker, ObjectState> StateChanged;

    private bool _isDeserializing;
<#+DisplayAutoGenerateFilterAutoGenerateField(false, false);#>
    public bool IsDeserializing 
    { 
        get { return _isDeserializing; } 
        set 
        { 
            if (_isDeserializing == value)
                return;
            _isDeserializing = value; 
<#+
foreach(EdmProperty edmProperty in entityType.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == entityType && IsPublic(p)))
{
#>
            if (<#=code.Escape(edmProperty)#> != null)
                <#=code.Escape(edmProperty)#>.IsDeserializing = value;
<#+
}
#>
        }
    }

<#+DisplayAutoGenerateFilterAutoGenerateField(false, false);#>
    public bool IsInitializingRelationships { get; set; }

    [OnDeserializing]
    public void OnDeserializingMethod(StreamingContext context)
    {
        IsDeserializing = true;
    }

    [OnDeserialized]
    public void OnDeserializedMethod(StreamingContext context)
    {
        IsDeserializing = false;
        ChangeTracker.ChangeTrackingEnabled = true;
    }
<#+
    }

    if (ef.NeedsHandleCascadeDeleteMethod(itemCollection, entityType) || entityType.NavigationProperties.Any(np => np.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One))
    {
        bool baseHandleCascadeDelete = false;
        var baseType = entityType;
        while ((baseType = (EntityType)baseType.BaseType) != null)
        {
            if (ef.NeedsHandleCascadeDeleteMethod(itemCollection, baseType) || baseType.NavigationProperties.Any(np => np.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && IsPublic(np)))
            {
                baseHandleCascadeDelete = true;
                break;
            }
        }
        if (! baseHandleCascadeDelete)
        {
#>

    internal void HandleCascadeDelete(object sender, ObjectStateChangedEventArgs e)
    {
        if (e.NewState == ObjectState.Deleted)
            this.MarkAsDeleted();
    }
<#+
        }
    }
    if (entityType.NavigationProperties.Where(np => np.DeclaringType == entityType).Where(np => (np.ToEndMember.DeleteBehavior == OperationAction.Cascade || np.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One) && IsPublic(np)).Any())
    {
        bool baseManagedHandleCascadeDelete = false;
        var baseType = entityType;
        while ((baseType = (EntityType)baseType.BaseType) != null)
        {
            if (ef.NeedsHandleCascadeDeleteMethod(itemCollection, baseType) || baseType.NavigationProperties.Any(np => np.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && IsPublic(np)))
            {
                baseManagedHandleCascadeDelete = true;
                break;
            }
        }
        if (! baseManagedHandleCascadeDelete)
        {
#>

    internal void HandleManagedCascadeDelete(object sender, ObjectStateChangedEventArgs e)
    {
        if (e.NewState == ObjectState.Deleted)
            this.MarkAsCascadeDeleted();
    }
<#+
        }
    }

    foreach(EdmProperty edmProperty in entityType.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == entityType))
    {
#>
    private void Handle<#=edmProperty.Name#>Changing(object sender, EventArgs args)
    {
        if (ChangeTracker.State != ObjectState.Added && (ChangeTracker.State & ObjectState.Deleted) == 0)
        {
            ChangeTracker.State = ObjectState.Modified;
        }
<#+
        if (originalValueMembers.IsOriginalValueMember(edmProperty))
        {
#>
        <#=code.Escape(edmProperty.TypeUsage)#>.RecordComplexOriginalValues("<#=edmProperty.Name#>", this.<#=code.Escape(edmProperty)#>, ChangeTracker);
<#+
        }
#>
    }

<#+
    }

    List<AssociationEndMember> shadowAssociationEnds = new List<AssociationEndMember>();
    foreach(var association in itemCollection.GetItems<AssociationType>().Where(x => !IsForeignKeyOrIdentifyingRelationship(ef, x) &&
                                                                                ((((RefType)x.AssociationEndMembers[0].TypeUsage.EdmType).ElementType == entityType &&
                                                                                   x.AssociationEndMembers[0].RelationshipMultiplicity != RelationshipMultiplicity.One &&
                                                                                   x.AssociationEndMembers[1].RelationshipMultiplicity != RelationshipMultiplicity.Many) ||
                                                                                 ((RefType)x.AssociationEndMembers[1].TypeUsage.EdmType).ElementType == entityType &&
                                                                                   x.AssociationEndMembers[1].RelationshipMultiplicity != RelationshipMultiplicity.One &&
                                                                                   x.AssociationEndMembers[0].RelationshipMultiplicity != RelationshipMultiplicity.Many)))
    {
        if (!entityType.NavigationProperties.Any(np => np.RelationshipType == association && IsPublic(np)))
        {
            for (int i = 0; i < 2; i++)
            {
                int targetRoleIndex = 0;
                if (((RefType)association.AssociationEndMembers[i].TypeUsage.EdmType).ElementType == entityType)
                {
                    targetRoleIndex = (i + 1) % 2;
                    shadowAssociationEnds.Add(association.AssociationEndMembers[targetRoleIndex]);
                }
            }
        }
    }
#>

<#+
        var properties = entityType.Properties.Where(p => p.DeclaringType == entityType && IsPublic(p)).ToList();
        if (entityBaseTypeName == null || properties.Count != 0)
        {
#>
    public <#=entityBaseTypeName == null ? "virtual" : "override" #> void MarkAsModified()
    {
<#+
            if (entityBaseTypeName == null)
            {
#>
        ChangeTracker.ChangeTrackingEnabled = true;
        ChangeTracker.State = ObjectState.Modified;
<#+
            }
            else
            {
#>
        base.MarkAsModified();
<#+
            }
            foreach (var p in properties)
            {
#>
        ChangeTracker.ModifiedProperties.Add("<#=code.Escape(p) #>");
<#+
            }
#>
    }
<#+
        }
#>

    protected <#=entityType.BaseType == null ? "virtual " : "override " #>void ClearNavigationProperties()
    {
        bool isInitializingRelationships = IsInitializingRelationships;
        IsInitializingRelationships = true;
<#+
    if (entityType.BaseType != null)
    {
#>
        base.ClearNavigationProperties();
<#+
    }
    foreach (NavigationProperty navProperty in entityType.NavigationProperties.Where(np => np.DeclaringType == entityType && IsPublic(np)))
    {
        string navPropertyName = code.Escape(navProperty);
        if (navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
        {
#>
        <#=navPropertyName#>.Clear();
<#+
        }
        else
        {
#>
        <#=navPropertyName#> = null;
<#+
            if (IsSaveReference(ef, navProperty))
            {
#>
        Fixup<#=navProperty.Name#>Keys();
<#+
            }
        }
    }
    foreach(var associationEnd in shadowAssociationEnds)
    {
        AssociationType association = associationEnd.DeclaringType as AssociationType;
#>
        <#=CreateFixupMethodName(associationEnd)#>(null, true);
<#+
    }
#>
        IsInitializingRelationships = isInitializingRelationships;
    }

<#+
    if (entityType.KeyMembers.Any(km => km.DeclaringType == entityType))
    {
#>
    public bool HasTemporaryKey
    {
        get { return <#+
    if (hasTemporaryKey)
    {
#>ChangeTracker.State == ObjectState.Added<#+
    }
    else if (couldHaveTemporaryKeyNps.Count != 0)
    {
#>ChangeTracker.State == ObjectState.Added && (<#=couldHaveTemporaryKeyNps.Select(np => string.Format("{0} != null && {0}.HasTemporaryKey || {0} == null && {1}", code.Escape(np), np.GetDependentProperties().Select(p => string.Concat(code.Escape(p), " == default(", code.Escape(p.TypeUsage), ")")).Aggregate((p1, p2) => string.Concat(p1, " && ", p2)))).Aggregate((np1, np2) => string.Concat(np1, " || ", np2))#>)<#+
    }
    else
    {
#>false<#+
    }
#>; }
    }

<#+
    }
#>
    public <#=entityType.BaseType == null ? "virtual" : "override"#> bool HasChanges
    {
        get { return <#+
    if (entityType.BaseType != null){#>base.HasChanges || <#+}#>ChangeTracker.State != ObjectState.Unchanged || ChangeTracker.ObjectsRemovedFromCollectionProperties.Any() || ChangeTracker.OriginalValues.Any() || ChangeTracker.ObjectsAddedToCollectionProperties.Any(); }
    }
<#+
	if (entityType.BaseType == null)
	{
#>
	private Guid? _uniqueIdentifier;
	Guid IObjectWithChangeTracker.UniqueIdentifier
	{
		get { return _uniqueIdentifier ?? (_uniqueIdentifier = Guid.NewGuid()).Value; }
	}
<#+
	}
#>
    #endregion

    #region Association Fixup
    private bool IsDeleting { get; set; }
    internal <#=entityType.BaseType == null ? "virtual" : "override"#> void Detach()
    {
        ChangeTracker.State = ObjectState.Detached;
    }
<#+

    foreach (NavigationProperty navProperty in entityType.NavigationProperties.Where(np => np.DeclaringType == entityType && IsPublic(np)))
    {
        string navPropertyName = code.Escape(navProperty);
        NavigationProperty inverse = ef.Inverse(navProperty);

        if (inverse != null && !IsPublic(inverse))
            inverse = null;

        string fromManaged;
        if ((navProperty.ToEndMember.DeleteBehavior == OperationAction.Cascade || navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One) && IsPublic(navProperty))
            fromManaged = "Managed";
        else
            fromManaged = "";
        string toManaged;
        if ((navProperty.FromEndMember.DeleteBehavior == OperationAction.Cascade || navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One) && IsPublic(navProperty))
            toManaged = "Managed";
        else
            toManaged = "";

        if (navProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many)
        {
            var skipKeysArgument = navProperty.GetDependentProperties().Where(p=>ef.IsNullable(p)).Any()
                ? ", bool skipKeys = false"
                : String.Empty;
#>

    private void Fixup<#=navProperty.Name#>(<#=code.Escape(navProperty.ToEndMember.GetEntityType())#> previousValue<#= skipKeysArgument #>)
    {
<#+
        if (ef.IsCascadeDeletePrincipal(navProperty) || navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One)
        {
#>
        if (previousValue != null)
            ChangeTracker.ObjectStateChanged -= previousValue.Handle<#=toManaged#>CascadeDelete;

        if (<#=navPropertyName#> != null)
            ChangeTracker.ObjectStateChanged += <#=navPropertyName#>.Handle<#=toManaged#>CascadeDelete;

<#+
        }
        else if (inverse == null && ef.IsCascadeDeletePrincipal((AssociationEndMember)navProperty.ToEndMember))
        {
#>
        if (previousValue != null)
            previousValue.ChangeTracker.ObjectStateChanged -= Handle<#=fromManaged#>CascadeDelete;

        if (<#=navPropertyName#> != null)
            <#=navPropertyName#>.ChangeTracker.ObjectStateChanged += Handle<#=fromManaged#>CascadeDelete;

<#+
        }
#>
        if (IsDeserializing)
            return;

        if (<#=navPropertyName#> == null && ChangeTracker.ChangeTrackingEnabled && previousValue.ChangeTracker.State == ObjectState.Detached && previousValue.ChangeTracker.DetachedPreviousState != ObjectState.Added)
        {
            object originalValue;
            if (ChangeTracker.OriginalValues.TryGetValue("<#=navPropertyName#>", out originalValue) && (originalValue == null || originalValue == previousValue))
                ChangeTracker.OriginalValues.Remove("<#=navPropertyName#>");
            return;
        }

        bool isInitializingRelationships = IsInitializingRelationships || (<#=navPropertyName#> != null && <#=navPropertyName#>.IsInitializingRelationships);
<#+
        if (navProperty.GetDependentProperties().Any())
        {
#>
        var changeTrackingEnabled = ChangeTracker.ChangeTrackingEnabled;
        if (isInitializingRelationships || ChangeTracker.IsAttaching)
            ChangeTracker.ChangeTrackingEnabled = false;

<#+
        }
        if (inverse != null)
        {
            if (inverse.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
            {
#>
        if (previousValue != null && previousValue.<#=code.Escape(inverse)#>.Contains(this))
            previousValue.<#=code.Escape(inverse)#>.Remove(this);
<#+
            }
            else
            {
#>
        if (previousValue != null && ReferenceEquals(previousValue.<#=code.Escape(inverse)#>, this))
            previousValue.<#=code.Escape(inverse)#> = null;
<#+
            }
            if (inverse.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
            {
#>

        if (<#=navPropertyName#> != null)
        {
            if (!<#=navPropertyName#>.<#=code.Escape(inverse)#>.Contains(this))
            {
                if (isInitializingRelationships)
                    <#=navPropertyName#>.<#=code.Escape(inverse)#>.Attach(this);
                else
                    <#=navPropertyName#>.<#=code.Escape(inverse)#>.Add(this);
            }

<#+
                foreach (var dependentProperty in navProperty.GetDependentProperties())
                {
#>
            <#=code.Escape(dependentProperty)#> = <#=navPropertyName#>.<#=code.Escape(ef.GetCorrespondingPrincipalProperty(navProperty, dependentProperty))#>;
<#+
                }
#>
        }
        else if (!(<#=navProperty.GetDependentProperties().Where(p => ef.IsNullable(p)).Any() ? "skipKeys || " : ""#> IsDeserializing || ChangeTracker.State == ObjectState.Detached) && (ChangeTracker.State & ObjectState.Deleted) == 0)
        {
<#+
                foreach (var dependentProperty in navProperty.GetDependentProperties())
                {
                    var otherDependentNavigationProperties = entityType.NavigationProperties.Where(np => np != navProperty && np.GetDependentProperties().Contains(dependentProperty)).ToList();
                    if (otherDependentNavigationProperties.Count != 0)
                    {
                        var testOtherNavPropsSB = new StringBuilder();
                        var otherDependentNavigationPropertiesEnumerator = otherDependentNavigationProperties.GetEnumerator();
                        otherDependentNavigationPropertiesEnumerator.MoveNext();
                        for(;;)
                        {
                            testOtherNavPropsSB.Append(code.Escape(otherDependentNavigationPropertiesEnumerator.Current));
                            testOtherNavPropsSB.Append(" == null");
                            if (otherDependentNavigationPropertiesEnumerator.MoveNext())
                                testOtherNavPropsSB.Append(" && ");
                            else
                                break;
                        }
#>
            if (<#=testOtherNavPropsSB#>)
<#+
                        PushIndent(CodeRegion.GetIndent(1));
                    }
#>
            <#=code.Escape(dependentProperty)#> = default(<#=code.Escape(dependentProperty.TypeUsage)#>);
<#+
                    if (otherDependentNavigationProperties.Count != 0)
                        PopIndent();
                }
#>
        }

<#+
            }
            else
            {
#>

        if (<#=navPropertyName#> != null)
        {
            <#=navPropertyName#>.<#=code.Escape(inverse)#> = this;
<#+
                foreach (var dependentProperty in navProperty.GetDependentProperties())
                {
#>
            <#=code.Escape(dependentProperty)#> = <#=navPropertyName#>.<#=code.Escape(ef.GetCorrespondingPrincipalProperty(navProperty, dependentProperty))#>;
<#+
                }
#>
        }

<#+
            }
        }
#>
        if (ChangeTracker.ChangeTrackingEnabled && (! isInitializingRelationships || ChangeTracker.State == ObjectState.Added || <#=navProperty.Name#> != null && <#=navProperty.Name#>.ChangeTracker.State == ObjectState.Added))
        {
            if (ChangeTracker.OriginalValues.ContainsKey("<#=navProperty.Name#>") && (ChangeTracker.OriginalValues["<#=navProperty.Name#>"] == <#=navPropertyName#>))
                ChangeTracker.OriginalValues.Remove("<#=navProperty.Name#>");
            else
            {
                ChangeTracker.RecordOriginalValue("<#=navProperty.Name#>", previousValue);
<#+
        if (ef.IsPrincipalEndOfIdentifyingRelationship((AssociationEndMember)navProperty.FromEndMember))
        {
#>
                if (previousValue != null && previousValue.ChangeTracker.State != ObjectState.Added)
                {
                    previousValue.MarkAsDeleted();
                }
<#+
        }
        else if (inverse == null && ef.IsPrincipalEndOfIdentifyingRelationship((AssociationEndMember)navProperty.ToEndMember))
        {
#>
                if (previousValue != null && ChangeTracker.State != ObjectState.Added)
                    this.MarkAsDeleted();
<#+
        }
#>
            }
            if (<#=navPropertyName#> != null && !<#=navPropertyName#>.ChangeTracker.ChangeTrackingEnabled && ChangeTracker.State != ObjectState.Detached)
                <#=navPropertyName#>.MarkAsAdded();
<#+
        if (IsSaveReference(ef, navProperty))
        {
#>
            Fixup<#=navProperty.Name#>Keys();
<#+
        }
        if (inverse == null &&
            !IsForeignKeyOrIdentifyingRelationship(ef, navProperty) &&
            navProperty.FromEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many &&
            navProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.One)
        {
#>
            if (previousValue != null)
                previousValue.<#=CreateFixupMethodName(navProperty.FromEndMember)#>(null, false);
            if (<#=navPropertyName#> != null)
                <#=navPropertyName#>.<#=CreateFixupMethodName(navProperty.FromEndMember)#>(this, false);
<#+
        }
#>
        }
<#+
        if (navProperty.GetDependentProperties().Any())
        {
#>
        ChangeTracker.ChangeTrackingEnabled |= changeTrackingEnabled;
<#+
        }
#>
    }
<#+
        if (IsSaveReference(ef, navProperty))
        {
            EntityType targetType = (EntityType)navProperty.TypeUsage.EdmType;
            List<string> keyNames = targetType.KeyMembers.Select(x => x.Name).ToList();
#>

    private void Fixup<#=navProperty.Name#>Keys()
    {
<#+
            for(int k=0; k < keyNames.Count; k++)
            {
#>
        const string <#=CreateKeyNameVariable(code.Escape(keyNames[k]))#> = "<#=CreateReferenceValueLookupKey(navProperty, keyNames[k])#>";
<#+
            }
#>

        if(ChangeTracker.ExtendedProperties.ContainsKey(<#=CreateKeyNameVariable(code.Escape(keyNames[0]))#>)<#=keyNames.Count > 1 ? " &&" : ")"#>
<#+
            for(int k=1; k < keyNames.Count; k++)
            {
#>
           ChangeTracker.ExtendedProperties.ContainsKey(<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>)<#=k < keyNames.Count - 1 ? " &&" : ")" #>
<#+
            }
#>
        {
            if(<#=navPropertyName#> == null ||
<#+
            for(int k=0; k < keyNames.Count; k++)
            {
                string equality = ef.ClrType(targetType.KeyMembers[keyNames[k]].TypeUsage) == typeof(byte[]) ? "EqualityComparer.Binary" : String.Empty;
#>
               !<#=equality#>Equals(ChangeTracker.ExtendedProperties[<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>], <#=navPropertyName#>.<#=code.Escape(keyNames[k])#>)<#=k < keyNames.Count - 1 ? " ||" : ")" #>
<#+
            }
#>
            {
<#+
            for(int k=0; k < keyNames.Count; k++)
            {
#>
                ChangeTracker.RecordOriginalValue(<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>, ChangeTracker.ExtendedProperties[<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>]);
<#+
            }
#>
            }
<#+
            for(int k=0; k < keyNames.Count; k++)
            {
#>
            ChangeTracker.ExtendedProperties.Remove(<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>);
<#+
            }
#>
        }
    }
<#+
            }
        }
    }

    foreach (NavigationProperty navProperty in entityType.NavigationProperties.Where(np => np.DeclaringType == entityType && IsPublic(np)))
    {
        string navPropertyName = code.Escape(navProperty);
        NavigationProperty inverse = ef.Inverse(navProperty);

        if (inverse != null && !IsPublic(inverse))
            inverse = null;

        string managed;
        if ((navProperty.FromEndMember.DeleteBehavior == OperationAction.Cascade || navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One) && IsPublic(navProperty))
            managed = "Managed";
        else
            managed = "";

        if (navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
        {
#>

    private void Fixup<#=navProperty.Name#>(object sender, NotifyCollectionChangedEventArgs e)
    {
        if (IsDeserializing<#+if(navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many){#> || <#=navProperty.Name#>.IsAttachingOrDetaching<#+}#>)
            return;

        if (e.NewItems != null)
        {
            foreach (<#=code.Escape(navProperty.ToEndMember.GetEntityType())#> item in e.NewItems)
            {
                bool itemIsInitializingRelationships = item.IsInitializingRelationships;
                if (IsInitializingRelationships)
                    item.IsInitializingRelationships = true;
<#+
                if (inverse != null && IsPublic(inverse))
                {
                    if (inverse.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many)
                    {
#>
                item.<#=code.Escape(inverse)#> = this;
<#+
                    }
                    else
                    {
#>
                if (!item.<#=code.Escape(inverse)#>.Contains(this))
                {
                    if (IsInitializingRelationships || item.ChangeTracker.IsAttaching)
                        item.<#=code.Escape(inverse)#>.Attach(this);
                    else
                        item.<#=code.Escape(inverse)#>.Add(this);
                }
<#+
                    }
                }
                else if (IsForeignKeyOrIdentifyingRelationship(ef, navProperty))
                {
                    foreach (var fromProperty in ef.GetPrincipalProperties(navProperty))
                    {
#>
                item.<#=code.Escape(ef.GetCorrespondingDependentProperty(navProperty, fromProperty))#> = <#=code.Escape(fromProperty)#>;
<#+
                    }
                }
                else if (navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.ZeroOrOne)
                {
#>
                item.<#=CreateFixupMethodName(navProperty.FromEndMember)#>(this, false);
<#+
                }
#>
                if (! (IsInitializingRelationships || item.IsInitializingRelationships) && ChangeTracker.ChangeTrackingEnabled && (ChangeTracker.State == ObjectState.Added || item.ChangeTracker.State == ObjectState.Added || !(ChangeTracker.IsAttaching || item.ChangeTracker.IsAttaching)))
                {
                    if (! item.ChangeTracker.ChangeTrackingEnabled)
                        item.MarkAsAdded();
                    ChangeTracker.RecordAdditionToCollectionProperties("<#=navPropertyName#>", item);
                }
<#+
                if (ef.IsCascadeDeletePrincipal(navProperty) || navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One)
                {
#>
                ChangeTracker.ObjectStateChanged += item.Handle<#=managed#>CascadeDelete;
<#+
                }
#>
                item.IsInitializingRelationships = itemIsInitializingRelationships;
            }
        }

        if (e.OldItems != null)
        {
            foreach (<#=code.Escape(navProperty.ToEndMember.GetEntityType())#> item in e.OldItems)
            {
                bool itemIsInitializingRelationships = item.IsInitializingRelationships;
                if (IsInitializingRelationships)
                    item.IsInitializingRelationships = true;
<#+
                if (inverse != null && IsPublic(inverse))
                {
                    if (inverse.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many)
                    {
#>
                if (ReferenceEquals(item.<#=code.Escape(inverse)#>, this))
                    item.<#=code.Escape(inverse)#> = null;
<#+
                    }
                    else
                    {
#>
                if (item.<#=code.Escape(inverse)#>.Contains(this))
                    item.<#=code.Escape(inverse)#>.Remove(this);
<#+
                    }
                }
                else if (IsForeignKeyOrIdentifyingRelationship(ef, navProperty))
                {
                    foreach (var fromProperty in ef.GetPrincipalProperties(navProperty))
                    {
                        var p = ef.GetCorrespondingDependentProperty(navProperty, fromProperty);
                        if (ef.IsNullable(p.TypeUsage))
                        {
#>
                item.<#=code.Escape(p)#> = null;
<#+
                        }
                    }
                }
                else if (navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.ZeroOrOne)
                {
#>
                item.<#=CreateFixupMethodName(navProperty.FromEndMember)#>(null, false);
<#+
                }
#>
                if (ChangeTracker.ChangeTrackingEnabled && !IsInitializingRelationships)
                {
                    ChangeTracker.RecordRemovalFromCollectionProperties("<#=navPropertyName#>", item);
<#+
                if (ef.IsPrincipalEndOfIdentifyingRelationship((AssociationEndMember)navProperty.FromEndMember))
                {
#>
                    if (! (item.ChangeTracker.State == ObjectState.Added || item.ChangeTracker.State == ObjectState.CascadeDeleted || item.ChangeTracker.State == ObjectState.Detached))
<#+
                    if (navProperty.FromEndMember.DeleteBehavior == OperationAction.Cascade || navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One)
                    {
#>
                        item.MarkAsCascadeDeleted();
<#+
                    }
                    else
                    {
#>
                        item.MarkAsDeleted();
<#+
                    }
                }
#>
                }
<#+
                if (ef.IsCascadeDeletePrincipal(navProperty) || navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One)
                {
#>
                ChangeTracker.ObjectStateChanged -= item.Handle<#=managed#>CascadeDelete;
<#+
                }
#>
                item.IsInitializingRelationships = itemIsInitializingRelationships;
            }
        }
    }
<#+
        }
    }

    foreach(var associationEnd in shadowAssociationEnds)
    {
        AssociationType association = associationEnd.DeclaringType as AssociationType;
        EntityType targetType = ((RefType)associationEnd.TypeUsage.EdmType).ElementType as EntityType;
        List<string> keyNames = targetType.KeyMembers.Select(x => x.Name).ToList();
#>

    internal void <#=CreateFixupMethodName(associationEnd)#>(<#=code.Escape(targetType)#> value, bool forceRemove)
    {
<#+
            for(int k=0; k < keyNames.Count; k++)
            {
#>
        const string <#=CreateKeyNameVariable(code.Escape(keyNames[k]))#> = "<#=CreateReferenceValueLookupKey(associationEnd, keyNames[k])#>";
<#+
            }
#>

        if (ChangeTracker.ChangeTrackingEnabled &&
<#+
        for(int k=0; k < keyNames.Count; k++)
        {
#>
            ChangeTracker.ExtendedProperties.ContainsKey(<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>)<#=k < keyNames.Count - 1 ? " &&" : ")"#>
<#+
        }
#>
        {
            if (forceRemove ||
<#+
        for(int k=0; k < keyNames.Count; k++)
        {
                string equality = ef.ClrType(targetType.KeyMembers[keyNames[k]].TypeUsage) == typeof(byte[]) ? "EqualityComparer.Binary" : String.Empty;
#>
                !<#=equality#>Equals(ChangeTracker.ExtendedProperties[<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>], value == null ? null : (object)value.<#=code.Escape(keyNames[k])#>)<#=k < keyNames.Count - 1 ? " ||" : ")"#>
<#+
        }
#>
            {
<#+
        for(int k=0; k < keyNames.Count; k++)
        {
#>
                ChangeTracker.RecordOriginalValue(<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>, ChangeTracker.ExtendedProperties[<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>]);
<#+
        }
#>
                if (value == null)
                {
<#+
        for(int k=0; k < keyNames.Count; k++)
        {
#>
                    ChangeTracker.ExtendedProperties.Remove(<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>);
<#+
        }
#>
                }
                else
                {
<#+
        for(int k=0; k < keyNames.Count; k++)
        {
#>
                    ChangeTracker.ExtendedProperties[<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>] = value.<#=code.Escape(keyNames[k])#>;
<#+
        }
#>
                }
            }
        }
    }
<#+
    }
#>
    #endregion

    #region EntityKey
    private Guid? _dataTransferEntityKey;
    [DataMember]
    public <#=entityBaseTypeName == null ? "virtual" : "override"#> Guid DataTransferEntityKey 
    { 
        get { return _dataTransferEntityKey ?? (_dataTransferEntityKey = Guid.NewGuid()).Value; }
        set { _dataTransferEntityKey = value; } 
    }

<#+
    if (couldHaveTemporaryKey)
    {
#>
    private string _entityKey;
<#+
    }
#>
    public <#=entityBaseTypeName == null ? "virtual" : "override"#> string EntityKey
    {
        get 
        { 
<#+ 
    if (couldHaveTemporaryKey)
    {
        var entityKeysTmp = entityType.KeyMembers.Select(km => code.Escape(km)).ToList();
#>
            switch (ChangeTracker.State)
            {
                case ObjectState.Added:
                    if (_entityKey == null)
                        _entityKey = "<#=entityTypeName#> - IdentityKey = " + <#=hasTemporaryKey ? "Guid.NewGuid().ToString()" : string.Concat("string.Concat(", couldHaveTemporaryKeyNps.Select(np => 
                            {
                                IEnumerable<EdmProperty> fromProperties, toProperties;
                                GetNavigationPropertyReferentialConstraintsEnumerables(np, out fromProperties, out toProperties);
                                var fromTemporaryKeys = TemporaryKeys(entityType, HostResolvePath).Intersect(fromProperties).ToList();
                                return string.Format("{0} == null ? ({1} ? \"{0}Key = null\" : string.Concat(\"{0}Key = {{\", {2}, \"}}\")) : (\"{0}Key = \" + {0}.EntityKey)", code.Escape(np), fromTemporaryKeys.Select(k => 
                                {
                                    var kName = code.Escape(k);
                                    entityKeysTmp.Remove(kName);
                                    return string.Concat(kName, " == default(", code.Escape(k.TypeUsage), ")");
                                }).Aggregate((k1, k2) => string.Concat(k1, " || ", k2)), fromTemporaryKeys.Select(k => string.Concat("string.Concat(\"", code.Escape(k), "=\", ", code.Escape(k), ")")).Aggregate((k1, k2) => string.Concat(k1, ",", k2)));
                            }).Aggregate((np1, np2) => string.Concat(np1, ", ", np2)), entityKeysTmp.Count == 0 ? "" :  entityKeysTmp.Select(k => string.Concat(", \"", k, " = \", ", k)).Aggregate((k1, k2) => k1 + k2), ")")#>;
                    return _entityKey;
                case ObjectState.Detached:
                    if (_entityKey != null)
                        return _entityKey;
                    if (<#=TemporaryKeys(entityType, HostResolvePath).Select(k => string.Concat(code.Escape(k), " == default(", code.Escape(k.TypeUsage), ")")).Aggregate((k1, k2) => string.Concat(k1, " || ", k2))#>)
                        goto case ObjectState.Added;
                    break;
                case ObjectState.Unchanged:
                case ObjectState.Modified:
                case ObjectState.CascadeDeleted:
                case ObjectState.Deleted:
                    _entityKey = null;
                    break;
            }
<#+
    }
#>
            return string.Format("<#=entityTypeName#> - <#+
        var keyMembers = entityType.KeyMembers.Select(km => code.Escape(km)).OrderBy(p => p).ToList();
        for (int keyIndex = 0 ; keyIndex < keyMembers.Count ; keyIndex ++)
        {
#><#=code.Escape(keyMembers[keyIndex])#>={<#=keyIndex#>};<#+
        }
#>", <#+
        var keyMembersEnumerator = keyMembers.GetEnumerator();
        keyMembersEnumerator.MoveNext();
        for(;;)
        {
#><#=code.Escape(keyMembersEnumerator.Current)#><#+
            if (keyMembersEnumerator.MoveNext())
            {
#>, <#+
            }
            else
                break;
        }
#>); 
        }
        set { <#=couldHaveTemporaryKey ? "_entityKey = value;" : ""#> }
    }
<#+
    if (couldHaveTemporaryKey)
    {
#>
    public <#=entityBaseTypeName == null ? "virtual" : "override"#> void ResetEntityKey()
    {
        if (! IsDeserializing)
        {
            var previousEntityKey = _entityKey;
            _entityKey = null;
            OnEntityKeyChanged(previousEntityKey);
        }
    }

<#+
        if (entityType.BaseType == null)
        {
#>
    protected virtual void OnEntityKeyChanged(string previousEntityKey)
    {
        if (EntityKeyChanged != null)
            EntityKeyChanged(this, previousEntityKey);
    }
    public event Action<<#=entityTypeName #>, string> EntityKeyChanged;
<#+
        }
#>
    public <#=entityBaseTypeName == null ? "virtual" : "override"#> bool IsTemporaryKey
    {
        get { return _entityKey != null; }
    }
<#+
    }
#>
    #endregion

    #region Dependences
<#+
    EntityType entityTypeLoop = entityType;
    List<string> alreadyAddedProperties;
    if (entityTypeGetMethods == null)
        alreadyAddedProperties = new List<string>();
    else
        alreadyAddedProperties = entityTypeGetMethods.Select(m => SpecificationMethods.GetPropertyNameFromMethod(m)).ToList();
    while ((entityTypeLoop = (EntityType)entityTypeLoop.BaseType) != null)
    {
        foreach (var edmProperty in entityTypeLoop.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == entityTypeLoop).Where(p => IsPublic(p)))
            AddOnPropertyChanged(specificationsElements, entityType, code.Escape(edmProperty), false, edmxElements, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, true);
        foreach(var edmProperty in entityTypeLoop.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == entityTypeLoop && IsPublic(p)))
            AddOnPropertyChanged(specificationsElements, entityType, code.Escape(edmProperty), false, edmxElements, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, false);
        foreach (var navProperty in entityType.NavigationProperties.Where(np => np.DeclaringType == entityTypeLoop && IsPublic(np)))
            AddOnPropertyChanged(specificationsElements, entityType, code.Escape(navProperty), false, edmxElements, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, false);
        if (specificationsElements.GetMethods.TryGetValue(code.Escape(entityTypeLoop), out specificationGetMethodsPerClass))
            foreach (var getMethod in specificationGetMethodsPerClass)
            {
                string propertyName = SpecificationMethods.GetPropertyNameFromMethod(getMethod);
                if (alreadyAddedProperties.Contains(propertyName))
                    continue;
                alreadyAddedProperties.Add(propertyName);
                AddOnPropertyChanged(specificationsElements, entityType, propertyName, false, edmxElements, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, true, true, true);
            }
    }
#>
    #endregion

    #region UISpecifications
<#+
    WriteUISpecifications(code, entityType, string.Concat(namespaceName, ".", entityTypeName), GetNonOverridenGetMethods(_specificationsElements, entityTypeGetMethods), entityType.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == entityType && IsPublic(p)), entityType.NavigationProperties.Where(np => np.DeclaringType == entityType), metadata);
#>
    #endregion
}
<#+
    new WritingFunctions(Write).WriteFooter(PopIndent, namespaceName);
    classesCode.TryAdd(entityTypeName + ".cs", CurrentFileStringBuilder);
    classesCodeARE.Set();
}));

    var complexTypesTask = entityTypesSkip == 0 ? Task.Factory.StartNew(() => 
    Parallel.ForEach(complexTypes, complexType =>
        {
            string complexTypeName = code.Escape(complexType);
            var members = new ConcurrentDictionary<string, List<MemberDeclarationSyntax>>();
            allMembers.TryAdd(complexTypeName, members);
            List<MethodDeclarationSyntax> specificationGetMethodsPerClass;
            var specificationsMembers = new List<MemberDeclarationSyntax>();

            allTasks.TryAdd(complexTypeName, GetSpecifications(edmxElements.EdmxName, specificationsElements, serverFxSpecificationsNamespace, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, serverEntitiesNamespace, complexType, complexType.Properties, edmxElements, dtoTypes, dtoNamespace, members, specificationsMembers, out specificationGetMethodsPerClass, namespacesReplacement, propertyAttributes: propertyAttributes).ToArray());
            allSpecificationGetMethodsPerClass.TryAdd(complexTypeName, specificationGetMethodsPerClass);
            allSpecificationsMembers.TryAdd(complexTypeName, specificationsMembers);

    CurrentEdmType = complexType;
    List<WAQSMetadata> metadata;
    if (! _specificationsElements.Metadata.TryGetValue(complexTypeName, out metadata))
        metadata = new List<WAQSMetadata>();

    CurrentFileStringBuilder = new StringBuilder();
    new WritingFunctions(Write).WriteHeader(PushIndent, namespaceName, code, "System", "System.Collections.Generic", "System.Collections.ObjectModel", "System.ComponentModel", "System.ComponentModel.DataAnnotations", "System.Globalization", "System.Reflection", "System.Runtime.Serialization", "System.Text", clientFxEntitiesNamespace, clientFxEntitiesTrackingNamespace, clientFxComponentModelNamespace);
#>

[DataContract(IsReference = true, Namespace = "http://<#=edmxElements.EdmxName#>/Entities")]
public partial class <#=complexTypeName#> : <#=(complexTypesBaseType ?? dynamicType) ?? "BindableObject"#>, INotifyComplexPropertyChanging
{
    #region DynamicType
    protected override <#=iCustomTypeDescriptorTypeName#> <#=customTypeDescriptorPropertyName#>
    {
        get { return new DynamicType<<#=complexTypeName#>>(<#=dynamicTypeParameters#>); }
    }
    protected override IEnumerable<<#=customPropertyDescriptorTypeName#>> <#=customPropertyDescriptorsName#>
    {
        get { return DynamicType<<#=complexTypeName#>>.CustomProperties; }
    }
    #endregion 

    #region Simple Properties
<#+
    foreach(EdmProperty edmProperty in complexType.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == complexType && IsPublic(p)))
    {
        string propertyName = code.Escape(edmProperty);
        var hasPropertyDependences = AddOnPropertyChanged(specificationsElements, complexType, propertyName, true, edmxElements, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, true);
#>

    [DataMember]
<#+
        new WritingFunctions(Write).WriteCustomAttributes(PushIndent, PopIndent, propertyAttributes, propertyName, complexTypeName);
        if (IsConcurrencyFixed(edmProperty))
            DisplayAutoGenerateFilterAutoGenerateField(false, false);
#>
    public <#=code.Escape(edmProperty.TypeUsage)#> <#=propertyName#>
    {
        get { return <#=code.FieldName(edmProperty)#>; }
        set
        {
            if (<#=code.FieldName(edmProperty)#> == value)
            {
<#+
            bool isRequired = ! edmProperty.Nullable && (edmProperty.TypeUsage.ToString() == "Edm.String" || edmProperty.TypeUsage.ToString() == "Edm.Binary");
            var isNullableMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "IsNullable");
            if (isRequired || isNullableMetadata != null)
            {
#>
                Validate<#=propertyName#>Required(value);
<#+
            }
#>
                return;
            }

            if (! ChangeTracker.Saving)
                On<#=propertyName#>Changing(ref value);
<#+
        WAQSMetadata minValueMetadata, maxValueMetadata, minLengthMetadata, maxLengthMetadata, patternMetadata;
        int? maxLength;
        GetMetadataScalarProperties(edmProperty, propertyName, metadata, out minValueMetadata, out maxValueMetadata, out minLengthMetadata, out maxLengthMetadata, out patternMetadata, out maxLength);
#>
            OnComplexPropertyChanging();
            <#=code.FieldName(edmProperty)#> = value;
<#+
        if (hasPropertyDependences)
        {
#>
            On<#=propertyName#>Changed();
<#+
        }
        else
        {
#>
            On<#=propertyName#>Changed(value);
<#+
        }
#>
        }
    }
    private <#=code.Escape(edmProperty.TypeUsage)#> <#=code.FieldName(edmProperty)#><#=code.StringBefore(" = ", code.CreateLiteral(edmProperty.DefaultValue))#>;
    partial void On<#=propertyName#>Changing(ref <#=code.Escape(edmProperty.TypeUsage)#> value);
    partial void On<#=propertyName#>Changed(<#=code.Escape(edmProperty.TypeUsage)#> value);
<#+
        WriteValidateMethods(edmProperty, propertyName, code, isRequired, maxLength, isNullableMetadata, minValueMetadata, maxValueMetadata, minLengthMetadata, maxLengthMetadata, patternMetadata);
    }
#>
#endregion

#region Complex Properties
<#+
    foreach(EdmProperty edmProperty in complexType.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == complexType && IsPublic(p)))
    {
        var complexPropertyName = code.Escape(edmProperty);
        var complexPropertyFieldName = code.FieldName(edmProperty);
        var subComplexTypeName = code.Escape(edmProperty.TypeUsage);
        var hasPropertyDependences = AddOnPropertyChanged(specificationsElements, complexType, complexPropertyName, true, edmxElements, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, false);
#>
    [DataMember]
<#+
        new WritingFunctions(Write).WriteCustomAttributes(PushIndent, PopIndent, propertyAttributes, complexPropertyName, complexTypeName);
#>
    public <#=subComplexTypeName#> <#=complexPropertyName#>
    {
        get
        {
            if (!<#=InitializedTrackingField(edmProperty, code)#> && <#=code.FieldName(edmProperty)#> == null)
            {
                <#=complexPropertyFieldName#> = new <#=subComplexTypeName#>();
                ((INotifyComplexPropertyChanging)<#=code.FieldName(edmProperty)#>).ComplexPropertyChanging += HandleComplexPropertyChanging;
                On<#=complexPropertyName#>Changed(null, <#=complexPropertyFieldName#>);
                On<#=complexPropertyName#>PropertyChanging(null, <#=complexPropertyFieldName#>);
<#+
        if (hasPropertyDependences)
        {
#>
                On<#=complexPropertyName#>Changed(null, <#=complexPropertyFieldName#>, false);
<#+
        }
#>
            }
            <#=InitializedTrackingField(edmProperty, code)#> = true;
            return <#=code.FieldName(edmProperty)#>;
        }
        set
        {
            if (Equals(<#=complexPropertyFieldName#>, value))
                return;

            var old<#=complexPropertyName#> = <#=complexPropertyFieldName#>;
            if (! ChangeTracker.Saving)
                On<#=complexPropertyName#>Changing(ref value);
            <#=InitializedTrackingField(edmProperty, code)#> = true;
            if (<#=code.FieldName(edmProperty)#> != null)
                ((INotifyComplexPropertyChanging)<#=code.FieldName(edmProperty)#>).ComplexPropertyChanging -= HandleComplexPropertyChanging;
            OnComplexPropertyChanging();
            <#=code.FieldName(edmProperty)#> = value;
            On<#=complexPropertyName#>Changed(value);
            OnPropertyChanged("<#=complexPropertyName#>");
            if (value != null)
                ((INotifyComplexPropertyChanging)value).ComplexPropertyChanging += HandleComplexPropertyChanging;
            On<#=complexPropertyName#>PropertyChanging(old<#=complexPropertyName#>, <#=complexPropertyFieldName#>);
<#+
        if (hasPropertyDependences)
        {
#>
            On<#=complexPropertyName#>Changed(old<#=complexPropertyName#>, <#=complexPropertyFieldName#>);
<#+
        }
        else
        {
#>
            On<#=complexPropertyName#>Changed();
<#+
        }
#>
        }
    }
    private <#=subComplexTypeName#> <#=code.FieldName(edmProperty)#>;
    partial void On<#=complexPropertyName#>Changing(ref <#=subComplexTypeName#> value);
    partial void On<#=complexPropertyName#>Changed(<#=subComplexTypeName#> value);
    private bool <#=InitializedTrackingField(edmProperty, code)#>;
    protected virtual void On<#=complexPropertyName#>PropertyChanging(<#=complexTypeName#> oldValue, <#=complexTypeName#> newValue)
    {
        if (<#=complexPropertyName#>PropertyChanging != null)
            <#=complexPropertyName#>PropertyChanging(oldValue, newValue);
    }
    protected internal event Action<<#=complexTypeName#>, <#=complexTypeName#>> <#=complexPropertyName#>PropertyChanging;

<#+
    }
#>
    #endregion
<#+
    Task[] tasks;
    if (allTasks.TryGetValue(complexTypeName, out tasks))
        Task.WaitAll(tasks);

    WriteSpecifications(specificationsElements, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, complexType, edmxElements, allSpecificationGetMethodsPerClass[complexTypeName], metadata, allMembers[complexTypeName], allSpecificationsMembers[complexTypeName]);
#>
    #region ChangeTracking
    public bool IsDeserializing { get; internal set; }
    
    public ObjectChangeTracker ChangeTracker { get; internal set; }

    public string ComplexPropertyName { get; internal set; }

    private void OnComplexPropertyChanging()
    {
        if (_complexPropertyChanging != null)
            _complexPropertyChanging(this, new EventArgs());
    }

    event EventHandler INotifyComplexPropertyChanging.ComplexPropertyChanging { add { _complexPropertyChanging += value; } remove { _complexPropertyChanging -= value; } }
    private event EventHandler _complexPropertyChanging;

    private void OnPropertyChanged(string propertyName, bool isTracked = true)
    {
        if (isTracked && ChangeTracker.ChangeTrackingEnabled && ChangeTracker.State != ObjectState.Added && (ChangeTracker.State & ObjectState.Deleted) == 0)
        {
            ChangeTracker.State = ObjectState.Modified;
            if (!(IsDeserializing || ChangeTracker.ModifiedProperties.Contains(ComplexPropertyName)))
                ChangeTracker.ModifiedProperties.Add(ComplexPropertyName);
        }
        NotifyPropertyChanged.RaisePropertyChanged(propertyName);
    }

<#+
    if(complexType.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == complexType).Count() > 0)
    {
#>

    private void HandleComplexPropertyChanging(object sender, EventArgs args)
    {
        OnComplexPropertyChanging();
    }
<#+
    }
#>

    public static void RecordComplexOriginalValues(String parentPropertyName, <#=code.Escape(complexType)#> complexObject, ObjectChangeTracker changeTracker)
    {
        if (String.IsNullOrEmpty(parentPropertyName))
            throw new ArgumentException("String parameter cannot be null or empty.", "parentPropertyName");

        if (changeTracker == null)
            throw new ArgumentNullException("changeTracker");
<#+
        foreach(EdmProperty complexProperty in complexType.Properties.Where(p => IsPublic(p)))
        {
            if (complexProperty.TypeUsage.EdmType is ComplexType)
            {
#>
        <#=code.Escape(complexProperty.TypeUsage)#>.RecordComplexOriginalValues(String.Format(CultureInfo.InvariantCulture, "{0}.<#=complexProperty.Name#>", parentPropertyName), complexObject == null ? null : complexObject.<#=code.Escape(complexProperty)#>, changeTracker);
<#+
            }
            else
            {
#>
        changeTracker.RecordOriginalValue(String.Format(CultureInfo.InvariantCulture, "{0}.<#=complexProperty.Name#>", parentPropertyName), complexObject == null ? null : (object)complexObject.<#=code.Escape(complexProperty)#>);
<#+
            }
        }
#>
    }
    #endregion

    #region UISpecifications
<#+
    List<MethodDeclarationSyntax> entityTypeGetMethods;
    specificationsElements.GetMethods.TryGetValue(complexTypeName, out entityTypeGetMethods);
    WriteUISpecifications(code, complexType, string.Concat(namespaceName, ".", complexTypeName), entityTypeGetMethods, complexType.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == complexType && IsPublic(p)), new NavigationProperty[0], metadata);
#>
    #endregion
}
<#+
        new WritingFunctions(Write).WriteFooter(PopIndent, namespaceName);
        classesCode.TryAdd(complexTypeName + ".cs", CurrentFileStringBuilder);
        classesCodeARE.Set();
        })) : null;

var sharedClassTask = entityTypesSkip == 0 ? Task.Factory.StartNew(() =>
{
    if (! (string.IsNullOrEmpty(serverEntitiesPath.Sln) || string.IsNullOrEmpty(serverEntitiesPath.Csproj)))
    {
        var serverEntitiesSolution = LoadSolution(Path.GetFullPath(HostResolvePath(serverEntitiesPath.Sln)), Host);
        var serverEntitiesProject = serverEntitiesSolution.Projects.FirstOrDefault(p => p.FilePath == Path.GetFullPath(HostResolvePath(serverEntitiesPath.Csproj)));
        if (serverEntitiesPath.Folder != null)
            Parallel.ForEach (serverEntitiesProject.Documents.Where(d => d.Name.EndsWith(".shared.cs")), document => 
            {
                CurrentFileStringBuilder = new StringBuilder();
                var documentRoot = (SyntaxNode)GetSyntaxRoot(document);
                new WritingFunctions(Write).WriteHeader(PushIndent, namespaceName, code, new GetUsingsVisitor().Visit(documentRoot).ToArray());
                foreach (var sharedClass in new GetTypesVisitor().Visit(documentRoot))
                {
                    
#>
<#=sharedClass.NormalizeWhitespace().ToString()#>
<#+
                }
                new WritingFunctions(Write).WriteFooter(PopIndent, namespaceName);
                classesCode.TryAdd(document.Name, CurrentFileStringBuilder);
                classesCodeARE.Set();
            });
    }
}) : null;

var otherEntitiesTask = entityTypesSkip == 0 ? Task.Factory.StartNew(() =>
{
    var otherMethods = specificationsElements.NonExtensionMethods.Union(specificationsElements.NonEntitiesExtensionMethods).ToList();
    if (otherMethods.Any(m => specificationsElements.IsApplicableOnClient(m)))
    {
        CurrentFileStringBuilder = new StringBuilder();
        List<string> usings;
        specificationsElements.Usings.TryGetValue("@Other", out usings);
        if (usings == null)
            usings = new List<string>();
        else
        {
            bool withDto = false;
            usings = usings.Where(u => 
                {
                    var value = dtoNamespaces.Contains(u);
                    if (value)
                        withDto = true;
                    return ! value;
                }).Select(u => 
                {
                    string newUsing;
                    if (namespacesReplacement.TryGetValue(u, out newUsing))
                        return newUsing;
                    return u;
                }).ToList();
            if (withDto)
                usings.Add(dtoNamespace);		    
        }
        if (! usings.Contains("System"))
            usings.Insert(0, "System");

        new WritingFunctions(Write).WriteHeader(PushIndent, edmxElements.NamespaceName, edmxElements.Code, usings.OrderBy(u => u).ToArray());
        PushIndent(CodeRegion.GetIndent(1));
        var members = new ConcurrentDictionary<string, List<MemberDeclarationSyntax>>();
        foreach (var method in otherMethods)
            AddEntityMethod(members, null, method, specificationsElements.SemanticModelPerMethods[method], serverFxSpecificationsNamespace, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, serverEntitiesNamespace, specificationsElements, edmxElements, dtoTypes, dtoNamespace, false, namespacesReplacement);
        PopIndent();
#>
<#=SyntaxFactory.ClassDeclaration("EntitiesOtherSpecifications").WithMembers(SyntaxFactory.List<MemberDeclarationSyntax>(members.Values.SelectMany(m => m))).NormalizeWhitespace().ToString()#>
<#+
        new WritingFunctions(Write).WriteFooter(PopIndent, edmxElements.NamespaceName);
        classesCode.TryAdd("EntitiesOtherSpecifications.cs", CurrentFileStringBuilder);
        classesCodeARE.Set();
    }
}) : null;

var interfacesTask = entityTypesSkip == 0 ? Task.Factory.StartNew(() => 
{
    string fileName = null;
    new WritingFunctions(Write).WriteInterfaceSpecifications((ns, c, us) => new WritingFunctions(Write).WriteHeader(PushIndent, ns, c, us), n => 
    {
        new WritingFunctions(Write).WriteFooter(PopIndent, n);
        classesCode.TryAdd(fileName, CurrentFileStringBuilder);
        classesCodeARE.Set();
    }, specificationsElements, serverFxSpecificationsNamespace, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, namespaceName, f => 
    {
        CurrentFileStringBuilder = new StringBuilder();
        fileName = f;
    }, edmxElements, dtoTypes, dtoNamespace, namespacesReplacement);
}) : null;

bool finished = false;
Task.Factory.StartNew(() => 
{
if (entityTypesSkip == 0)
    WriteSpecificTypes(fileManager, itemCollection, code, edmxElements.EdmxName, namespaceName);

entityTypesTask.Wait();
if (entityTypesSkip == 0)
    Task.WaitAll(complexTypesTask, sharedClassTask, otherEntitiesTask, interfacesTask);

finished = true;
classesCodeARE.Set();
});

CurrentFileStringBuilder = null;
classesCodeARE.WaitOne();
for (;;)
{
    if (finished)
        break;
    classesCodeARE.WaitOne();
}

Process(fileManager, classesCode, _edmxElements, (newDocument, documentIdCode) => new ClientTestNull(GetSemanticModel(newDocument), documentIdCode, specificationsElements));
}

private SpecificationsElements _specificationsElements;
private EdmxElements _edmxElements;
[ThreadStatic]
private static StructuralType _currentEdmType;
private static StructuralType CurrentEdmType
{
    get { return _currentEdmType; }
    set 
    {
        _currentEdmType = value; 
        _currentEdmTypePropertyWithHandlers = _currentEdmType.Members.Where(p2 => ! (p2.TypeUsage.EdmType is SimpleType)).ToList();
    }
}
[ThreadStatic]
private static List<EdmMember> _currentEdmTypePropertyWithHandlers; 
private string _serverFxDALInterfacesNamespace;
private string _serverFxServiceInterfacesNamespace;

IEnumerable<Task> GetSpecifications(string edmxName, SpecificationsElements specificationsElements, string serverFxSpecificationsNamespace, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, string serverEntitiesNamespace, StructuralType edmType, IEnumerable<EdmProperty> properties, EdmxElements edmxElements, IEnumerable<TypeSymbol> dtoTypes, string dtoNamespace, ConcurrentDictionary<string, List<MemberDeclarationSyntax>> members, List<MemberDeclarationSyntax> specificationsMemberDeclarationSyntax, out List<MethodDeclarationSyntax> specificationGetMethodsPerClass, Dictionary<string, string> namespacesReplacement, string classInheritance = null, string propertyAttributes = null)
{
    CurrentEdmType = edmType;
    var code = edmxElements.Code;
    var className = code.Escape(edmType);
    var itemCollection = edmxElements.ItemCollection;
    var specificationGetMethods = specificationsElements.GetMethods;
    var semanticModelPerMethods = specificationsElements.SemanticModelPerMethods;
    var specificationsMembers = new ConcurrentDictionary<string, List<MemberDeclarationSyntax>>();
    List<WAQSMetadata> metadata;
    if (!specificationsElements.Metadata.TryGetValue(code.Escape(edmType), out metadata))
        metadata = new List<WAQSMetadata>();
    EntityType entityType = edmType as EntityType;
    List<MethodDeclarationSyntax> specificationGetMethodsPerClassValue;
    bool classNameSpecificationGetMethodsPerClassValue = specificationGetMethods.TryGetValue(className, out specificationGetMethodsPerClassValue);
    specificationGetMethodsPerClass = specificationGetMethodsPerClassValue;

    return new [] {
        Task.Factory.StartNew(
        () =>
            {
                if (classNameSpecificationGetMethodsPerClassValue)
                {
                    Parallel.ForEach(specificationGetMethodsPerClassValue, method =>
                    {
                        string methodName = method.Identifier.ValueText.Trim();
                        string propertyName = GetPropertyNameFromMethodName(methodName);
                        var semanticModel = semanticModelPerMethods[method];
                        bool isOverride = false;
                        var syntaxTokens = new List<SyntaxToken>() { SyntaxFactory.Token(SyntaxKind.PublicKeyword) };
                        if (specificationsElements.VirtualMethods.Contains(method) || specificationsElements.AbstractMethods.Contains(method))
                            syntaxTokens.Add(SyntaxFactory.Token(SyntaxKind.VirtualKeyword));
                        else if (isOverride = specificationsElements.OverrideMethods.Contains(method))
                            syntaxTokens.Add(SyntaxFactory.Token(SyntaxKind.OverrideKeyword));
                        var returnType = (TypeSyntax)new DTOAndInterfacesTypesRewriter(semanticModel, specificationsElements, dtoTypes, namespacesReplacement).Visit(method.ReturnType);
                        SpecificationMethodBodyRewriter bodyRewriter = new SpecificationGetMethodBodyRewriterClientEntity(specificationsElements, method, semanticModel, dtoTypes, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, method.ParameterList.Parameters[0].Identifier.ValueText, propertyName, returnType, namespacesReplacement);
                        var customAttributes = new List<AttributeListSyntax>();
                        if (propertyAttributes != null)
                            customAttributes.AddRange(((PropertyDeclarationSyntax)SyntaxFactory.ParseCompilationUnit(propertyAttributes.Replace("$PropertyName$", propertyName).Replace("$ClassName$", className) + "private int Foo;").Members[0]).AttributeLists);
                        List<MemberDeclarationSyntax> memberDeclarationSyntaxes = new List<MemberDeclarationSyntax>()
                        {
                            SyntaxFactory.PropertyDeclaration(returnType, propertyName)
                                .WithModifiers(
                                    SyntaxFactory.TokenList(syntaxTokens))
                                .WithAttributeLists(SyntaxFactory.List<AttributeListSyntax>(
                                    customAttributes))
                                .WithAccessorList(
                                    SyntaxFactory.AccessorList(
                                        SyntaxFactory.List(
                                            new[]
                                            {
                                                SyntaxFactory.AccessorDeclaration(
                                                    SyntaxKind.GetAccessorDeclaration,
                                                    ((MethodDeclarationSyntax) bodyRewriter.Visit(method)).Body),
                                                SyntaxFactory.AccessorDeclaration(
                                                    SyntaxKind.SetAccessorDeclaration,
                                                    SyntaxFactory.Block(
                                                        SyntaxFactory.ThrowStatement(
                                                            SyntaxFactory.ParseExpression("new System.InvalidOperationException();"))))
                                            })))
                        };
                        if (! syntaxTokens.Any(st => GetKind(st) == SyntaxKind.OverrideKeyword))
                            memberDeclarationSyntaxes.Insert(0,
                                SyntaxFactory.FieldDeclaration(
                                    SyntaxFactory.VariableDeclaration(returnType,
                                        SyntaxFactory.SeparatedList(
                                            new []
                                            {
                                                SyntaxFactory.VariableDeclarator(
                                                    "_previous" + propertyName)
                                            },
                                            new SyntaxToken[0])))
                                    .WithModifiers(
                                        SyntaxFactory.TokenList(
                                            new[] { SyntaxFactory.Token(SyntaxKind.PrivateKeyword) })));
                        members.TryAdd(propertyName, memberDeclarationSyntaxes);
                    if (! isOverride)
                    {
                        memberDeclarationSyntaxes.Add(
                            SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName("void"), SyntaxFactory.Identifier(string.Concat("On", propertyName, "PropertyChanging")))
                                .WithModifiers(
                                    SyntaxFactory.TokenList(
                                        SyntaxFactory.Token(SyntaxKind.ProtectedKeyword),
                                        SyntaxFactory.Token(SyntaxKind.VirtualKeyword)))
                                .WithBody(
                                    SyntaxFactory.Block(
                                        SyntaxFactory.IfStatement(
                                            SyntaxFactory.ParseExpression(propertyName + "PropertyChanging != null"),
                                            SyntaxFactory.Block(
                                                SyntaxFactory.ParseStatement(string.Concat("var value = ", propertyName, ";")),
                                                SyntaxFactory.IfStatement(
                                                    SyntaxFactory.ParseExpression("value == _previous" + propertyName),
                                                    SyntaxFactory.ReturnStatement()),
                                                SyntaxFactory.ParseStatement(string.Concat("var oldValue = _previous", propertyName, ";")),
                                                SyntaxFactory.ParseStatement(string.Concat("_previous", propertyName, " = value;")),
                                                SyntaxFactory.ParseStatement(propertyName + "PropertyChanging(oldValue, value);"))))));
                        memberDeclarationSyntaxes.Add(
                            SyntaxFactory.EventFieldDeclaration(
                                SyntaxFactory.VariableDeclaration(
                                    SyntaxFactory.GenericName(
                                        SyntaxFactory.Identifier("Action"), 
                                        SyntaxFactory.TypeArgumentList(
                                            SyntaxFactory.SeparatedList(
                                                new [] { returnType, returnType },
                                                new [] { SyntaxFactory.Token(SyntaxKind.CommaToken)}))))
                                    .WithVariables(
                                        SyntaxFactory.SeparatedList(
                                            new []
                                            {
                                                SyntaxFactory.VariableDeclarator(propertyName + "PropertyChanging")
                                            },
                                            new SyntaxToken[0])))
                                    .WithModifiers(
                                        SyntaxFactory.TokenList(
                                            SyntaxFactory.Token(SyntaxKind.ProtectedKeyword),
                                            SyntaxFactory.Token(SyntaxKind.InternalKeyword))));

                            var specificationsMembersValues = new List<MemberDeclarationSyntax>();
                            string valueFiedlName = string.Concat("_", code.CamelCase(propertyName));
                            specificationsMembersValues.Add(SyntaxFactory.FieldDeclaration(
                                SyntaxFactory.VariableDeclaration(
                                    returnType,
                                    SyntaxFactory.SeparatedList(
                                        new [] { SyntaxFactory.VariableDeclarator(valueFiedlName) },
                                        new SyntaxToken[0]))));

                            specificationsMembersValues.Add(SyntaxFactory.PropertyDeclaration(returnType, propertyName)
                                .WithModifiers(SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword)))
                                .WithAttributeLists(
                                    SyntaxFactory.List(
                                        new []
                                        {
                                            SyntaxFactory.AttributeList(
                                                SyntaxFactory.SeparatedList(
                                                    new []
                                                    {
                                                        SyntaxFactory.Attribute(
                                                            SyntaxFactory.ParseName("DataMember"))
                                                    },
                                                    new SyntaxToken[0]))
                                        }))
                                .WithAccessorList(
                                    SyntaxFactory.AccessorList(
                                        SyntaxFactory.List(
                                            new []
                                            {
                                                SyntaxFactory.AccessorDeclaration(
                                                    SyntaxKind.GetAccessorDeclaration,
                                                    SyntaxFactory.Block(
                                                        SyntaxFactory.ReturnStatement(
                                                            SyntaxFactory.ParseName(valueFiedlName)))),
                                                SyntaxFactory.AccessorDeclaration(
                                                    SyntaxKind.SetAccessorDeclaration,
                                                        SyntaxFactory.Block(
                                                            SyntaxFactory.List(
                                                                new []
                                                                {
                                                                    SyntaxFactory.ParseStatement(valueFiedlName + " = value;"),
                                                                    SyntaxFactory.ParseStatement("if (NotifyPropertyChanged != null)" + RaisePropertyChanged(propertyName, className))
                                                                })))
                                            }))));

                            string hasFieldName = "_has" + propertyName;
                            specificationsMembersValues.Add(SyntaxFactory.FieldDeclaration(
                                SyntaxFactory.VariableDeclaration(
                                    SyntaxFactory.ParseTypeName("bool"),
                                    SyntaxFactory.SeparatedList(
                                        new [] { SyntaxFactory.VariableDeclarator(hasFieldName) },
                                        new SyntaxToken[0]))));

                            specificationsMembersValues.Add(
                                SyntaxFactory.PropertyDeclaration(
                                    SyntaxFactory.ParseTypeName("bool"), 
                                    "Has" + propertyName)
                                        .WithModifiers(SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword)))
                                        .WithAccessorList(
                                            SyntaxFactory.AccessorList(
                                                SyntaxFactory.List(
                                                    new []
                                                    {
                                                        SyntaxFactory.AccessorDeclaration(
                                                            SyntaxKind.GetAccessorDeclaration,
                                                            SyntaxFactory.Block(
                                                                SyntaxFactory.ReturnStatement(
                                                                    SyntaxFactory.ParseName(hasFieldName)))),
                                                        SyntaxFactory.AccessorDeclaration(
                                                            SyntaxKind.SetAccessorDeclaration,
                                                                SyntaxFactory.Block(
                                                                    SyntaxFactory.List(
                                                                        new []
                                                                        {
                                                                            SyntaxFactory.ParseStatement(hasFieldName + " = value;"),
                                                                            SyntaxFactory.ParseStatement("if (NotifyPropertyChanged != null)" + RaisePropertyChanged(propertyName, className))
                                                                        })))
                                                    })))
                                        .WithAttributeLists(
                                            SyntaxFactory.List(
                                                new []
                                                {
                                                    SyntaxFactory.AttributeList(
                                                        SyntaxFactory.SeparatedList(
                                                            new []
                                                            {
                                                                SyntaxFactory.Attribute(
                                                                    SyntaxFactory.ParseName("DataMember"))
                                                            },
                                                            new SyntaxToken[0]))
                                                })));
                            specificationsMembers.TryAdd(propertyName, specificationsMembersValues);
                        }
                    });

                    if (specificationsMembers.Any())
                    {
                        if (classInheritance == null)
                            specificationsMembers.TryAdd("NotifyPropertyChanged", new List<MemberDeclarationSyntax>() {SyntaxFactory.ParseCompilationUnit("public NotifyPropertyChanged NotifyPropertyChanged { get; set; }").Members[0]});
                        var subTypesSB = new StringBuilder();
                        foreach(EntityType subType in GetSubEntityTypes(itemCollection, className))
                        {
                            var subTypeName = code.Escape(subType);
                            List<MethodDeclarationSyntax> subMethods;
                            if (specificationsElements.GetMethods.TryGetValue(subTypeName, out subMethods) && subMethods.Where(m => ! specificationsElements.OverrideMethods.Contains(m)).Any())
                            {
                                subTypesSB.Append("[KnownType(typeof(");
                                subTypesSB.Append(subTypeName);
                                subTypesSB.Append(".");
                                subTypesSB.Append(subTypeName);
                                subTypesSB.Append("Specifications))]");
                            }
                        }
                        var setSpecificationsIfNull = new StringBuilder();
                        var initSpecificationsFromBase = new StringBuilder();
                        if (classInheritance != null)
                        {
                            setSpecificationsIfNull.Append("if (_specifications == null && base.Specifications != null)_specifications = new ");
                            setSpecificationsIfNull.Append(className);
                            setSpecificationsIfNull.Append("Specifications { ");
                            initSpecificationsFromBase.Append("if (IsDeserializing && base.Specifications != null){");
                            var baseType = (EntityType)entityType.BaseType;
                            bool first = true;
                            while (baseType != null)
                            {
                                List<MethodDeclarationSyntax> baseGetMethods;
                                if (specificationGetMethods.TryGetValue(code.Escape(baseType), out baseGetMethods))
                                    foreach (var p in baseGetMethods.Where(m => ! specificationsElements.OverrideMethods.Contains(m)).Select(m => GetPropertyNameFromMethod(m)))
                                    {
                                        if (first)
                                            first = false;
                                        else
                                            setSpecificationsIfNull.Append(", ");
                                        setSpecificationsIfNull.AppendFormat("{0} = base.Specifications.{0}, Has{0} = base.Specifications.Has{0}", p);
                                        initSpecificationsFromBase.AppendFormat("value.{0} = base.Specifications.{0}; value.Has{0} = base.Specifications.Has{0};", p);
                                    }
                                baseType = (EntityType)baseType.BaseType;
                            }
                            setSpecificationsIfNull.Append(" };");
                            initSpecificationsFromBase.Append("}");
                        }
                        specificationsMemberDeclarationSyntax.AddRange(
                            new MemberDeclarationSyntax[] 
                                {
                                    ((ClassDeclarationSyntax)SyntaxFactory.ParseCompilationUnit(string.Concat("[DataContract(Namespace = \"http://", edmxName,"/Entities\")]", subTypesSB.ToString(), " public partial class ", className, "Specifications", classInheritance, "{}")).Members[0])
                                        .WithMembers(SyntaxFactory.List<MemberDeclarationSyntax>(specificationsMembers.Values.SelectMany(m => m))),
                                    (FieldDeclarationSyntax)SyntaxFactory.ParseCompilationUnit(string.Concat("private ", className, "Specifications _specifications;")).Members[0],
                                    (PropertyDeclarationSyntax)SyntaxFactory.ParseCompilationUnit(string.Concat("[DataMember", classInheritance == null ? "" : string.Concat("(Name = \"", className, "Specifications\")"), "]public ", classInheritance == null ? "" : "new ", className, "Specifications Specifications { get { ", setSpecificationsIfNull.ToString(), " return _specifications; } set { _specifications = value;", classInheritance == null ? "" : string.Concat("if (!(IsDeserializing && value == null)){", initSpecificationsFromBase.ToString(), "base.Specifications = value;}"), "if (_specifications != null)_specifications.NotifyPropertyChanged = NotifyPropertyChanged;} }")).Members[0]
                                });
                    }
                }
            }), 
            
        Task.Factory.StartNew(	
        () => AddServiceAndSubMethods(specificationsElements, edmxElements, className, serverFxSpecificationsNamespace, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, serverEntitiesNamespace, members, dtoTypes, dtoNamespace, false, namespacesReplacement)), 
        
        Task.Factory.StartNew(
        () =>
            {
                List<MethodDeclarationSyntax> validateMethods;
                EntityType edmTypeAsEntityType;
                if (specificationsElements.ValidateMethods.TryGetValue(code.Escape(edmType), out validateMethods))
                    validateMethods = validateMethods.Where(m => specificationsElements.IsApplicableOnClient(m)).ToList();
                var globalValidateMethodStatements = new List<StatementSyntax>();
                bool inheritedType = ! (entityType == null || entityType.BaseType == null);
                if (inheritedType)
                    globalValidateMethodStatements.Add(SyntaxFactory.ParseStatement("foreach (var er in base.ValidateOnClient()) yield return er;"));
                foreach (var complexProperty in properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == entityType && IsPublic(p)))
                    globalValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("foreach (var er in ", code.Escape(complexProperty), ".ValidateOnClient()) yield return er;")));
                foreach (var edmProperty in entityType.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == entityType && IsPublic(p)))
                {
                    bool hasError = false;
                    var propertyValidateMethodStatements = new List<StatementSyntax>();
                    var propertyName = code.Escape(edmProperty);
					var dependentProperties = metadata.Where(m => m.DependentProperties.Any(dp => dp.FirstOrDefault().Name == propertyName)).ToList();
                    bool isRequired = ! edmProperty.Nullable;
                    var isNullableMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "IsNullable");
                    if ((isRequired && (edmProperty.TypeUsage.ToString() == "Edm.String" || edmProperty.TypeUsage.ToString() == "Edm.Binary") || isNullableMetadata != null) && ! (entityType.KeyMembers.Contains(edmProperty) && GetCSDLIdentityProperties(entityType).Contains(edmProperty)))
                    {
                        string requiredType = edmProperty.TypeUsage.ToString() == "Edm.String" ? "String" : "Object";
                        propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("Error error = Validate", propertyName, "Required(", propertyName, ");")));
						if (isNullableMetadata == null || isNullableMetadata.DependentProperties.Count == 0)
						{
							propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (error != null)yield return error;")));
						}
						else
						{
							globalValidateMethodStatements.Insert(0, SyntaxFactory.ParseStatement(string.Concat("bool yield", propertyName, "Required = false;")));
							propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (! (error == null || yield", propertyName, "Required)){yield", propertyName, "Required = true;yield return error;}")));							
						}
                        hasError = true;
                    }
					foreach (var dependentIsNullable in dependentProperties.Where(m => m.MethodName == "IsNullable"))
					{
						var dependentPropertyName = dependentIsNullable.Property;
						var dependentProperty = entityType.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == entityType && IsPublic(p)).FirstOrDefault(p => code.Escape(p) == dependentPropertyName);
						if (dependentProperty == null)
						{
							continue;
						}
						string requiredType = dependentProperty.TypeUsage.ToString() == "Edm.String" ? "String" : "Object";
						propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat(hasError ? "" : "Error ", "error = Validate", dependentPropertyName, "Required(", dependentPropertyName, ");")));
						propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (! (error == null || yield", dependentPropertyName, "Required)){yield", dependentPropertyName, "Required = true;yield return error;}")));
                        hasError = true;
					}
                    var minValueMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMinValue");
                    if (minValueMetadata != null)
                    {
                        propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat(hasError ? "" : "Error ", "error = Validate", propertyName, "MinValue(", propertyName, ");")));
						if (minValueMetadata == null || minValueMetadata.DependentProperties.Count == 0)
						{
							propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (error != null)yield return error;")));
						}
						else
						{
							globalValidateMethodStatements.Insert(0, SyntaxFactory.ParseStatement(string.Concat("bool yield", propertyName, "MinValue = false;")));
							propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (! (error == null || yield", propertyName, "MinValue)){yield", propertyName, "MinValue = true;yield return error;}")));							
						}
                        hasError = true;
                    }
					foreach (var dependentMinValue in dependentProperties.Where(m => m.MethodName == "DefineMinValue"))
					{
						var dependentPropertyName = dependentMinValue.Property;
						var dependentProperty = entityType.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == entityType && IsPublic(p)).FirstOrDefault(p => code.Escape(p) == dependentPropertyName);
						if (dependentProperty == null)
						{
							continue;
						}
						string requiredType = dependentProperty.TypeUsage.ToString() == "Edm.String" ? "String" : "Object";
						propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat(hasError ? "" : "Error ", "error = Validate", dependentPropertyName, "MinValue(", dependentPropertyName, ");")));
						propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (! (error == null || yield", dependentPropertyName, "MinValue)){yield", dependentPropertyName, "MinValue = true;yield return error;}")));
                        hasError = true;
					}
                    var maxValueMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMaxValue");
                    if (maxValueMetadata != null)
                    {
                        propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat(hasError ? "" : "Error ", "error = Validate", propertyName, "MaxValue(", propertyName, ");")));
						if (maxValueMetadata == null || maxValueMetadata.DependentProperties.Count == 0)
						{
							propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (error != null)yield return error;")));
						}
						else
						{
							globalValidateMethodStatements.Insert(0, SyntaxFactory.ParseStatement(string.Concat("bool yield", propertyName, "MaxValue = false;")));
							propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (! (error == null || yield", propertyName, "MaxValue)){yield", propertyName, "MaxValue = true;yield return error;}")));							
						}
                        hasError = true;
                    }
					foreach (var dependentMaxValue in dependentProperties.Where(m => m.MethodName == "DefineMaxValue"))
					{
						var dependentPropertyName = dependentMaxValue.Property;
						var dependentProperty = entityType.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == entityType && IsPublic(p)).FirstOrDefault(p => code.Escape(p) == dependentPropertyName);
						if (dependentProperty == null)
						{
							continue;
						}
						string requiredType = dependentProperty.TypeUsage.ToString() == "Edm.String" ? "String" : "Object";
						propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat(hasError ? "" : "Error ", "error = Validate", dependentPropertyName, "MaxValue(", dependentPropertyName, ");")));
						propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (! (error == null || yield", dependentPropertyName, "MaxValue)){yield", dependentPropertyName, "MaxValue = true;yield return error;}")));
                        hasError = true;
					}
                    var minLengthMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMinLength");
                    if (minLengthMetadata != null)
                    {
                        propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat(hasError ? "" : "Error ", "error = Validate", propertyName, "MinLength(", propertyName, ");")));
						if (minLengthMetadata == null || minLengthMetadata.DependentProperties.Count == 0)
						{
							propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (error != null)yield return error;")));
						}
						else
						{
							globalValidateMethodStatements.Insert(0, SyntaxFactory.ParseStatement(string.Concat("bool yield", propertyName, "MinLength = false;")));
							propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (! (error == null || yield", propertyName, "MinLength)){yield", propertyName, "MinLength = true;yield return error;}")));							
						}
                        hasError = true;
                    }
					foreach (var dependentMinLength in dependentProperties.Where(m => m.MethodName == "DefineMinLength"))
					{
						var dependentPropertyName = dependentMinLength.Property;
						var dependentProperty = entityType.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == entityType && IsPublic(p)).FirstOrDefault(p => code.Escape(p) == dependentPropertyName);
						if (dependentProperty == null)
						{
							continue;
						}
						string requiredType = dependentProperty.TypeUsage.ToString() == "Edm.String" ? "String" : "Object";
						propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat(hasError ? "" : "Error ", "error = Validate", dependentPropertyName, "MinLength(", dependentPropertyName, ");")));
						propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (! (error == null || yield", dependentPropertyName, "MinLength)){yield", dependentPropertyName, "MinLength = true;yield return error;}")));
                        hasError = true;
					}
                    int? maxLength = MaxLength(edmProperty);
                    var maxLengthMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMaxLength");
                    if (maxLength.HasValue || maxLengthMetadata != null)
                    {
                        propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat(hasError ? "" : "Error ", "error = Validate", propertyName, "MaxLength(", propertyName, ");")));
						if (maxLengthMetadata == null || maxLengthMetadata.DependentProperties.Count == 0)
						{
							propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (error != null)yield return error;")));
						}
						else
						{
							globalValidateMethodStatements.Insert(0, SyntaxFactory.ParseStatement(string.Concat("bool yield", propertyName, "MaxLength = false;")));
							propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (! (error == null || yield", propertyName, "MaxLength)){yield", propertyName, "MaxLength = true;yield return error;}")));							
						}
                        hasError = true;
                    }
					foreach (var dependentMaxLength in dependentProperties.Where(m => m.MethodName == "DefineMaxLength"))
					{
						var dependentPropertyName = dependentMaxLength.Property;
						var dependentProperty = entityType.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == entityType && IsPublic(p)).FirstOrDefault(p => code.Escape(p) == dependentPropertyName);
						if (dependentProperty == null)
						{
							continue;
						}
						string requiredType = dependentProperty.TypeUsage.ToString() == "Edm.String" ? "String" : "Object";
						propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat(hasError ? "" : "Error ", "error = Validate", dependentPropertyName, "MaxLength(", dependentPropertyName, ");")));
						propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (! (error == null || yield", dependentPropertyName, "MaxLength)){yield", dependentPropertyName, "MaxLength = true;yield return error;}")));
                        hasError = true;
					}
                    var patternMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefinePattern");
                    if (patternMetadata != null)
                    {
                        propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat(hasError ? "" : "Error ", "error = Validate", propertyName, "Pattern(", propertyName, ");")));
						if (patternMetadata == null || patternMetadata.DependentProperties.Count == 0)
						{
							propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (error != null)yield return error;")));
						}
						else
						{
							globalValidateMethodStatements.Insert(0, SyntaxFactory.ParseStatement(string.Concat("bool yield", propertyName, "Pattern = false;")));
							propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (! (error == null || yield", propertyName, "Pattern)){yield", propertyName, "Pattern = true;yield return error;}")));							
						}
                        hasError = true;
                    }
					foreach (var dependentPattern in dependentProperties.Where(m => m.MethodName == "DefinePattern"))
					{
						var dependentPropertyName = dependentPattern.Property;
						var dependentProperty = entityType.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == entityType && IsPublic(p)).FirstOrDefault(p => code.Escape(p) == dependentPropertyName);
						if (dependentProperty == null)
						{
							continue;
						}
						string requiredType = dependentProperty.TypeUsage.ToString() == "Edm.String" ? "String" : "Object";
						propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat(hasError ? "" : "Error ", "error = Validate", dependentPropertyName, "Pattern(", dependentPropertyName, ");")));
						propertyValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Concat("if (! (error == null || yield", dependentPropertyName, "Pattern)){yield", dependentPropertyName, "Pattern = true;yield return error;}")));
                        hasError = true;
					}
                    if (propertyValidateMethodStatements.Count != 0)
                    {
                        if (entityType.KeyMembers.Contains(edmProperty))
                            globalValidateMethodStatements.Add(SyntaxFactory.Block(propertyValidateMethodStatements));
                        else
                            globalValidateMethodStatements.Add(
                                SyntaxFactory.IfStatement(SyntaxFactory.ParseExpression(string.Concat("force || ChangeTracker.State == ObjectState.Added || ChangeTracker.State == ObjectState.Modified && ChangeTracker.ModifiedProperties.Contains(\"", propertyName, "\")")), 
                                SyntaxFactory.Block(propertyValidateMethodStatements)));
                    }
                }
                if (validateMethods != null)
                {
                    var validateMethodsStatements = new List<StatementSyntax>();
                    AddValidateMethods(validateMethods, specificationsElements, edmxElements, members, className, serverFxSpecificationsNamespace, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, serverEntitiesNamespace, (method, statement) => 
                        {
                            bool hasNavigationProperties = (edmTypeAsEntityType = edmType as EntityType) != null && specificationsElements.MethodsDependentProperties[method].SelectMany(pds => pds.Take(1)).Any(p => edmTypeAsEntityType.NavigationProperties.Any(p2 => code.Escape(p2) == p.Name));
                            if (! hasNavigationProperties)
                                validateMethodsStatements.Add(statement);
                            var addErrorsSB = new StringBuilder();
                            var removeErrorsSB = new StringBuilder();
                            foreach (var dependence in specificationsElements.MethodsDependentProperties[method].Where(ps => ps.Count == 1 && entityType.Properties.Any(p => code.Escape(p) == ps[0].Name && p.TypeUsage.EdmType is SimpleType)).SelectMany(ps => ps))
                            {
                                addErrorsSB.Append(string.Concat("Errors.", dependence.Name, ".Add(newError);"));
                                removeErrorsSB.Append(string.Concat("Errors.", dependence.Name, ".Remove(existingError);"));
                            }
                            if (addErrorsSB.Length == 0)
                            {
                                addErrorsSB.Append("Errors.AllErrors.Add(newError);");
                                removeErrorsSB.Append("Errors.AllErrors.Remove(existingError);");
                            }
                            var methodName = method.Identifier.ValueText;
                            var validateMethod = SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName("Error"), methodName)
                                .WithModifiers(
                                    SyntaxFactory.TokenList(new[] { 
                                        SyntaxFactory.Token(hasNavigationProperties ? SyntaxKind.PublicKeyword : SyntaxKind.ProtectedKeyword), 
                                        SyntaxFactory.Token(SyntaxKind.VirtualKeyword) }))
                                .WithParameterList(
                                    SyntaxFactory.ParameterList(
                                        SyntaxFactory.SeparatedList(
                                            new []
                                            {
                                                SyntaxFactory.Parameter(
                                                    SyntaxFactory.Identifier("force"))
                                                .WithType(
                                                    SyntaxFactory.ParseTypeName("bool"))
                                                .WithDefault(
                                                    SyntaxFactory.EqualsValueClause(
                                                        SyntaxFactory.ParseExpression("true")))
                                            },
                                            new SyntaxToken[0])))
                                .WithBody(
                                    SyntaxFactory.Block(
                                        SyntaxFactory.ParseStatement(string.Concat("var existingError = Errors.AllErrors.FirstOrDefault(e => e.Key == \"", methodName, "\");")),
                                        SyntaxFactory.ParseStatement(string.Concat("var newError = Get", methodName, "Error(force);")),
                                        SyntaxFactory.ParseStatement(string.Concat("if (newError == null){if (existingError != null){", removeErrorsSB, "}} else { if (existingError == null) {", addErrorsSB, "} else newError = existingError;}")),
                                        SyntaxFactory.ParseStatement("return newError;")));
                            List<MemberDeclarationSyntax> validateMethodMembers;
                            if (members.TryGetValue(methodName, out validateMethodMembers))
                                validateMethodMembers.Add(validateMethod);
                            else
                                members.TryAdd(methodName, new List<MemberDeclarationSyntax>() { validateMethod });
                        }, dtoTypes, dtoNamespace, false, namespacesReplacement);
                    if (validateMethodsStatements.Count != 0)
                    {
                        validateMethodsStatements.Insert(0, SyntaxFactory.ParseStatement("Error error;"));
                        globalValidateMethodStatements.Add(
                            SyntaxFactory.Block(validateMethodsStatements));
                    }
                }
                foreach (var navigationProperty in entityType.NavigationProperties.Where(np => np.DeclaringType == entityType && IsPublic(np) && np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One))
                    globalValidateMethodStatements.Add(SyntaxFactory.ParseStatement(string.Format("if ((ChangeTracker.State & ObjectState.Deleted) == 0 && (force || ChangeTracker.OriginalValues.ContainsKey(\"{0}\"))) {{ Error error = Validate{0}Required({0}); if (error != null) yield return error; }}", code.Escape(navigationProperty))));

                globalValidateMethodStatements.Add(SyntaxFactory.ParseStatement("List<Error> errors = null;"));
                globalValidateMethodStatements.Add(SyntaxFactory.ParseStatement("GetCustomValidation(ref errors);"));
                globalValidateMethodStatements.Add(SyntaxFactory.ParseStatement("if(errors != null)foreach (var er in errors) yield return er;"));
                members.TryAdd("ValidateOnClient", 
                    new List<MemberDeclarationSyntax>() 
                    { 
                        SyntaxFactory.MethodDeclaration(
                            SyntaxFactory.ParseTypeName("IEnumerable<Error>"), 
                            "ValidateOnClient")
                            .WithParameterList(
                                SyntaxFactory.ParameterList(
                                    SyntaxFactory.SeparatedList(
                                        new []
                                        {
                                            SyntaxFactory.Parameter(
                                                SyntaxFactory.Identifier("force"))
                                            .WithType(
                                                SyntaxFactory.ParseTypeName("bool"))
                                            .WithDefault(
                                                SyntaxFactory.EqualsValueClause(
                                                    SyntaxFactory.ParseExpression("false")))
                                        },
                                        new SyntaxToken[0])))
                            .WithModifiers(
                                SyntaxFactory.TokenList(
                                    SyntaxFactory.Token(SyntaxKind.PublicKeyword), 
                                    SyntaxFactory.Token(
                                        inheritedType ? 
                                            SyntaxKind.OverrideKeyword : 
                                            SyntaxKind.VirtualKeyword)))
                            .WithBody(
                                SyntaxFactory.Block(globalValidateMethodStatements))});
                members.TryAdd("GetCustomValidation", new List<MemberDeclarationSyntax>() { SyntaxFactory.ParseCompilationUnit("partial void GetCustomValidation(ref List<Error> errors);").Members[0]});
            })};
}

void WriteSpecifications(SpecificationsElements specificationsElements, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, StructuralType edmType, EdmxElements edmxElements, List<MethodDeclarationSyntax> specificationGetMethodsPerClass, List<WAQSMetadata> metadata, ConcurrentDictionary<string, List<MemberDeclarationSyntax>> members, List<MemberDeclarationSyntax> specificationsMemberDeclarationSyntax)
{
    var code = edmxElements.Code;
    if (!specificationsElements.Metadata.TryGetValue(code.Escape(edmType), out metadata))
        metadata = new List<WAQSMetadata>();
    EntityType entityType = edmType as EntityType;
    if (members.Count != 0)
    {
        string specificationCodeValue = SyntaxFactory.CompilationUnit()
            .WithMembers(SyntaxFactory.List<MemberDeclarationSyntax>(
                members.Values.SelectMany(m => m).Union(specificationsMemberDeclarationSyntax)))
            .NormalizeWhitespace()
            .ToString();
#>
    #region Specifications
<#+
        PushIndent(CodeRegion.GetIndent(1));
#>
<#=specificationCodeValue#>
<#+
        PopIndent();
        if (specificationGetMethodsPerClass != null)
            foreach (var getMethod in specificationGetMethodsPerClass)
                AddOnPropertyChanged(specificationsElements, edmType, SpecificationMethods.GetPropertyNameFromMethod(getMethod), true, edmxElements, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, true, true, specificationsElements.OverrideMethods.Contains(getMethod), true);

        foreach (var metadataOnBaseProperties in metadata.Where(m => (entityType.Properties.First(p => code.Escape(p) == m.Property)).DeclaringType != entityType).GroupBy(m => entityType.Properties.First(p => code.Escape(p) == m.Property)))
            WriteValidateMethods(entityType, metadataOnBaseProperties.Key, code, metadataOnBaseProperties);		

#>
    #endregion
<#+
    }
}

IEnumerable<MethodDependencesInfo> GetPropertyDependences(SpecificationsElements specificationsElements, string className, string propertyName, CodeGenerationTools code, EdmItemCollection itemCollection, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, bool withSubTypes = true, bool useGetMethods = true)
{
    foreach (var dependencesInfo in GetPropertyDependencesInternal(specificationsElements, className, propertyName, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, useGetMethods))
        yield return dependencesInfo;
    if (withSubTypes)
        foreach (var subEntityType in GetSubEntityTypes(itemCollection, className))
            foreach (var dependencesInfo in GetPropertyDependencesInternal(specificationsElements, code.Escape(subEntityType), propertyName, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, useGetMethods))
                yield return dependencesInfo;
}

IEnumerable<MethodDependencesInfo> GetPropertyDependencesInternal(SpecificationsElements specificationsElements, string className, string propertyName, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, bool useGetMethods = true)
{
    List<MethodDeclarationSyntax> getMethods;
    if ((useGetMethods ? specificationsElements.GetMethods : specificationsElements.ValidateMethods).TryGetValue(className, out getMethods))
        foreach (var getMethod in getMethods.Where(m => useGetMethods ? specificationsElements.IsApplicableOnClient(m) : true))
        {
            var methodDependences = specificationsElements.MethodsDependentProperties[getMethod];
            if (methodDependences != null)
                foreach (var methodDependence in methodDependences)
                    if (methodDependence.Count == 1 && methodDependence[0].Name == propertyName)
                    {
                        yield return new MethodDependencesInfo { ClassName = className, Method = getMethod, Property = methodDependence[0], Properties = methodDependences.Where(mdss => mdss.Count > 1 && mdss[0].Name == propertyName).Select(mds => mds.Skip(1).ToList()).ToList() };
                        break;
                    }
        }
}

IEnumerable<MetadataDependencesInfo> GetMetadataPropertyDependences(SpecificationsElements specificationsElements, string className, string propertyName, CodeGenerationTools code, EdmItemCollection itemCollection, bool withSubTypes = true)
{
    foreach (var dependencesInfo in GetMetadataPropertyDependencesInternal(specificationsElements, className, propertyName))
        yield return dependencesInfo;
    if (withSubTypes)
        foreach (var subEntityType in GetSubEntityTypes(itemCollection, className))
            foreach (var dependencesInfo in GetMetadataPropertyDependencesInternal(specificationsElements, code.Escape(subEntityType), propertyName))
                yield return dependencesInfo;
}

IEnumerable<MetadataDependencesInfo> GetMetadataPropertyDependencesInternal(SpecificationsElements specificationsElements, string className, string propertyName)
{
    List<WAQSMetadata> waqsMetadata;
    if (specificationsElements.Metadata.TryGetValue(className, out waqsMetadata))
        foreach (var metadata in waqsMetadata)
        {
            if (metadata.Property == propertyName)
                yield return new MetadataDependencesInfo { ClassName = className, Metadata = metadata, Property = new PropertySymbolInfo(metadata.PropertySymbol), Properties = new List<List<PropertySymbolInfo>>() };
            foreach (var metadataDependence in metadata.DependentProperties)
                if (metadataDependence.Count == 1 && metadataDependence[0].Name == propertyName)
                {
                    yield return new MetadataDependencesInfo { ClassName = className, Metadata = metadata, Property = metadataDependence[0], Properties = metadata.DependentProperties.Where(mdss => mdss.Count > 1 && mdss[0].Name == propertyName).Select(mds => mds.Skip(1).ToList()).ToList() };
                    break;
                }
        }
}

abstract class DependencesInfo
{
    public string ClassName { get; set; }
    public PropertySymbolInfo Property { get; set; }
    public List<List<PropertySymbolInfo>> Properties { get; set; }
}

class MethodDependencesInfo : DependencesInfo
{
    public MethodDeclarationSyntax Method { get; set; }
}

class MetadataDependencesInfo : DependencesInfo
{
    public WAQSMetadata Metadata { get; set; }
}

bool AddOnPropertyChanged(SpecificationsElements specificationsElements, StructuralType edmType, string propertyName, bool entityTypeProperty, EdmxElements edmxElements, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, bool simpleProperty, bool raise = false, bool isOverride = false, bool isGetMethod = false)
{
    var code = edmxElements.Code;
    var getMethods = new List<MethodDeclarationSyntax>();
    var overridenGetMethods = new List<MethodDeclarationSyntax>();
    var validateMethods = new List<MethodDeclarationSyntax>();
    var overridenValidateMethods = new List<MethodDeclarationSyntax>();
    var metadata = new List<WAQSMetadata>();
    var overridenMetadata = new List<WAQSMetadata>();
    var entityType = edmType as EntityType;
    bool hasOverridenMethod = false;
    bool useOverridenMethod = false;
    List<MethodDeclarationSyntax> edmTypeGetMethods = null, edmTypeValidateMethods = null;
    List<WAQSMetadata> edmTypeMetadata = null;
    var overridenEdmTypeMetadata = new List<WAQSMetadata>();
    if (entityType != null)
    {
        var entityTypeLoop = entityType;
        do
        {
            List<MethodDeclarationSyntax> getMethodsLoop;
            if (specificationsElements.GetMethods.TryGetValue(code.Escape(entityTypeLoop), out getMethodsLoop))
            {
                getMethodsLoop = getMethodsLoop.Where(m => specificationsElements.IsApplicableOnClient(m)).ToList();
                if (edmType == entityTypeLoop)
                    getMethods.AddRange(edmTypeGetMethods = getMethodsLoop);
                else
                {
                    foreach (var getMethodLoop in getMethodsLoop)
                    {
                        foreach (var overridenMethod in specificationsElements.GetOverridenMethods(getMethodLoop, specificationsElements.MethodSymbolPerMethods[getMethodLoop]).Select(m => specificationsElements.MethodPerMethodSymbols[m.Method.ToString()]))
                        {
                            if (overridenGetMethods.Contains(overridenMethod))
                                goto nextGetMethod;
                            if (edmTypeGetMethods != null && edmTypeGetMethods.Contains(overridenMethod))
                            {
                                overridenGetMethods.Add(getMethodLoop);
                                goto nextGetMethod;
                            }
                        }
                        getMethods.Add(getMethodLoop);
                        nextGetMethod:;
                    }
                }
            }
            List<MethodDeclarationSyntax> validateMethodsLoop;
            if (specificationsElements.ValidateMethods.TryGetValue(code.Escape(entityTypeLoop), out validateMethodsLoop))
            {
                if (edmType == entityTypeLoop)
                    validateMethods.AddRange(edmTypeValidateMethods = validateMethodsLoop);
                else
                {
                    foreach (var validateMethodLoop in validateMethodsLoop)
                    {
                        foreach (var overridenMethod in specificationsElements.GetOverridenMethods(validateMethodLoop, specificationsElements.MethodSymbolPerMethods[validateMethodLoop]).Select(m => specificationsElements.MethodPerMethodSymbols[m.Method.ToString()]))
                        {
                            if (overridenValidateMethods.Contains(overridenMethod))
                                goto nextValidateMethod;
                            if (edmTypeValidateMethods != null && edmTypeValidateMethods.Contains(overridenMethod))
                            {
                                overridenValidateMethods.Add(validateMethodLoop);
                                goto nextValidateMethod;
                            }
                        }
                        validateMethods.Add(validateMethodLoop);
                        nextValidateMethod:;
                    }
                }
            }
            List<WAQSMetadata> metadataLoop;
            if (specificationsElements.Metadata.TryGetValue(code.Escape(entityTypeLoop), out metadataLoop))
            {
                if (edmType == entityTypeLoop)
                {
                    metadata.AddRange(edmTypeMetadata = metadataLoop);
                    foreach (var subEntity in GetSubEntityTypes(edmxElements.ItemCollection, code.Escape(entityType)))
                    {
                        List<WAQSMetadata> subEntityMetadataLoop;
                        if (specificationsElements.Metadata.TryGetValue(code.Escape(subEntity), out subEntityMetadataLoop) && subEntityMetadataLoop.Any(m => m.Property == propertyName && metadataLoop.Any(m2 => m2.Property == propertyName && m2.MethodName == m.MethodName)))
                            hasOverridenMethod = true;
                    }
                }
                else
                    foreach (var metatadataLoopItem in metadataLoop)
                    {
                        var overridenMetadataItem = metadata.FirstOrDefault(m => metatadataLoopItem.Property == m.Property && metatadataLoopItem.MethodName == m.MethodName);
                        if (overridenMetadataItem == null)
                        {
                            metadata.Add(metatadataLoopItem);
                            continue;
                        }
                        if (edmTypeMetadata != null && edmTypeMetadata.Contains(overridenMetadataItem) && overridenMetadataItem.Property == propertyName && overridenMetadataItem.TypeName == code.Escape(edmType))
                            overridenEdmTypeMetadata.Add(overridenMetadataItem);
                        if (overridenMetadata.Any(m => metatadataLoopItem.Property == m.Property && metatadataLoopItem.MethodName == m.MethodName))
                            continue;
                        overridenMetadata.Add(metatadataLoopItem);
                    }
            }
        } while ((entityTypeLoop = (EntityType)entityTypeLoop.BaseType) != null && ! entityTypeProperty);
    }
    string edmTypeName = code.Escape(edmType);
    string baseTypeName = edmTypeName;
    if (entityType != null)
    {
        var entityTypeLoop = entityType;
        while ((entityTypeLoop = (EntityType)entityTypeLoop.BaseType) != null)
            baseTypeName = code.Escape(entityTypeLoop);
    }
    var getPropertyDependences = GetPropertyDependences(specificationsElements, baseTypeName, propertyName, code, edmxElements.ItemCollection, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace).ToList();
    var validatePropertyDependences = GetPropertyDependences(specificationsElements, baseTypeName, propertyName, code, edmxElements.ItemCollection, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, useGetMethods:false).Where(m => ! entityType.NavigationProperties.Any(np => code.Escape(np) == m.Property.Name)).ToList();
    var metadataPropertyDependences = GetMetadataPropertyDependences(specificationsElements, baseTypeName, propertyName, code, edmxElements.ItemCollection).Where(m => ! entityType.NavigationProperties.Any(np => code.Escape(np) == m.Property.Name)).ToList();
    if (getPropertyDependences.Any(m => specificationsElements.OverrideMethods.Contains(m.Method)))
        useOverridenMethod = true;
    if (validatePropertyDependences.Any(m => specificationsElements.OverrideMethods.Contains(m.Method)))
        useOverridenMethod = true;
    var classGetPropertyDependences = getPropertyDependences.Where(pd => getMethods.Contains(pd.Method)).ToList();
    if (getPropertyDependences.Any(pd => overridenGetMethods.Contains(pd.Method)) || getPropertyDependences.Any(m => m.Property.ToString() == propertyName))
        hasOverridenMethod = true;
    if (getPropertyDependences.Any(pd => overridenGetMethods.Contains(pd.Method)) && getPropertyDependences.Any(m => m.Property.ToString() == propertyName))
        useOverridenMethod = true;
    if (validatePropertyDependences.Any(pd => overridenValidateMethods.Contains(pd.Method)) || validatePropertyDependences.Any(m => m.Property.ToString() == propertyName))
        hasOverridenMethod = true;
    if (validatePropertyDependences.Any(pd => overridenValidateMethods.Contains(pd.Method)) && validatePropertyDependences.Any(m => m.Property.ToString() == propertyName))
        useOverridenMethod = true;
    if (metadataPropertyDependences.Any(pd => overridenMetadata.Contains(pd.Metadata)) || metadataPropertyDependences.Any(m => m.Property.ToString() == propertyName))
        hasOverridenMethod = true;
    if (metadataPropertyDependences.Any(pd => overridenMetadata.Contains(pd.Metadata)) && metadataPropertyDependences.Any(m => m.Property.ToString() == propertyName))
        useOverridenMethod = true;
    var classValidationPropertyDependences = validatePropertyDependences.Where(pd => validateMethods.Contains(pd.Method)).ToList();
    var classMetadataPropertyDependences = metadataPropertyDependences.Where(pd => metadata.Contains(pd.Metadata)).ToList();
    var specificGetPropertyDependences = getPropertyDependences.Where(pd => edmTypeGetMethods != null && edmTypeGetMethods.Contains(pd.Method)).ToList();
    var specificValidationPropertyDependences = validatePropertyDependences.Where(pd => edmTypeValidateMethods != null && edmTypeValidateMethods.Contains(pd.Method)).ToList();
    var specificMetadataDependences = metadataPropertyDependences.Where(pd => edmTypeMetadata != null && edmTypeMetadata.Contains(pd.Metadata)).ToList();
    if (specificGetPropertyDependences.Count == 0 && specificValidationPropertyDependences.Count == 0 && specificMetadataDependences.Count == 0 && ! hasOverridenMethod && ! isGetMethod)
        return false;
    var dependentValidateMethods = classValidationPropertyDependences.Select(pd => pd.Method).ToList();
    var specificDependentValidateMethods = specificValidationPropertyDependences.Select(pd => pd.Method).ToList();
    bool addRemoveHandler;
    if (! raise && getPropertyDependences.Count == 0 && validatePropertyDependences.Count == 0 && metadataPropertyDependences.Count == 0)
        return false;
    if (classGetPropertyDependences.Count == 0 && classValidationPropertyDependences.Count == 0 && classMetadataPropertyDependences.Count == 0)
        addRemoveHandler = false;
    else
    {
        AddHandler(specificationsElements, (getPropertyDependences.Count == 0 ? (validatePropertyDependences.Count == 0 ? (DependencesInfo)metadataPropertyDependences[0] : validatePropertyDependences[0]) : getPropertyDependences[0]).Property, edmTypeName, classGetPropertyDependences, classValidationPropertyDependences, classMetadataPropertyDependences, edmxElements, validateMethods);
        addRemoveHandler = ! (simpleProperty || raise) && AddHandlers(specificationsElements, edmTypeName, classGetPropertyDependences, classValidationPropertyDependences, classMetadataPropertyDependences, edmxElements, validateMethods, propertyName, propertyName + "_", true);
    }
    string parametersTypeName = raise ? null : TypeSymbolInfo.GetBasicTypeName((getPropertyDependences.Count == 0 ? (validatePropertyDependences.Count == 0 ? (DependencesInfo)metadataPropertyDependences[0] : validatePropertyDependences[0]) : getPropertyDependences[0]).Property.Type.TypeSymbol);
    if ((specificGetPropertyDependences.Count == 0 && specificValidationPropertyDependences.Count == 0 && specificMetadataDependences.Count == 0) && ! entityTypeProperty)
        return false;
#>

    protected <#=(entityTypeProperty && ! isOverride) ? "virtual" : "override"#> void On<#=propertyName#>Changed(<#=(simpleProperty || raise) ? "" : string.Format("{0} oldValue, {0} newValue, ", parametersTypeName)#>bool raise = true, bool validate = true)
    {
<#+
    if (addRemoveHandler && ! isOverride)
    {
#>
        <#=propertyName#>RemoveHandler(oldValue);
        <#=propertyName#>AddHandler(newValue);
<#+
    }
    if (useOverridenMethod || entityTypeProperty && ! isOverride)
    {
        List<MethodDeclarationSyntax> edmTypeNameGetMethods;
        if (specificationsElements.GetMethods.TryGetValue(edmTypeName, out edmTypeNameGetMethods) && edmTypeNameGetMethods.Any(m => m.Identifier.ValueText == "Get" + propertyName))
        {
#>
        if (! IsDeserializing)
            On<#=propertyName#>PropertyChanging();
<#+
        }
#>
        if (raise)
            OnPropertyChanged("<#=propertyName#>"<#=(entityType == null ? ((ComplexType)edmType).Properties : entityType.Properties).Any(p => code.Escape(p) == propertyName) ? "" : ", false"#>);
<#+
        if (classGetPropertyDependences.Count != 0)
            OnGetPropertyChanged(classGetPropertyDependences);
        bool addNullable = false;
        bool addMaxLength = false;
        var edmProperty = ((EntityType)edmType).Properties.FirstOrDefault(p => code.Escape(p) == propertyName);
        if (edmProperty != null && edmProperty.DeclaringType == edmType && (edmProperty.TypeUsage.ToString() == "Edm.String" || edmProperty.TypeUsage.ToString() == "Edm.Binary"))
        {
            addNullable = ! (edmProperty.Nullable || classMetadataPropertyDependences.Any(mpd => mpd.Metadata.Property == propertyName && mpd.Metadata.MethodName == "IsNullable"));
            var maxLength = MaxLength(edmProperty);
            addMaxLength = maxLength.HasValue && ! classMetadataPropertyDependences.Any(mpd => mpd.Metadata.Property == propertyName && mpd.Metadata.MethodName == "DefineMaxLength");
        }
        if (! (classValidationPropertyDependences.Count == 0 && classMetadataPropertyDependences.Count == 0))
        {
#>
        if (validate)
        {
<#+
            PushIndent(CodeRegion.GetIndent(1));
            var validatedProperties = new List<string>();
            if (classValidationPropertyDependences.Count != 0)
                OnValidatePropertyChanged(specificationsElements, specificDependentValidateMethods, edmType, propertyName, addErrors:simpleProperty, validatedProperties: validatedProperties);
            if (classMetadataPropertyDependences.Count != 0)
                OnMetadataPropertyChanged(classMetadataPropertyDependences, methodPropertyName:propertyName, addNullable: addNullable, addMaxLength: addMaxLength, validatedProperties: validatedProperties);
            PopIndent();
#>
        }
<#+
        }
#>
    }

<#+
    }
    else
    {
#>
        base.On<#=propertyName#>Changed(<#=(simpleProperty || raise) ? "" : "oldValue, newValue, "#>raise);
<#+
        if (specificGetPropertyDependences.Count != 0)
            OnGetPropertyChanged(specificGetPropertyDependences);
        if (specificValidationPropertyDependences.Count != 0)
            OnValidatePropertyChanged(specificationsElements, specificDependentValidateMethods, edmType, propertyName, addErrors:simpleProperty);
        if (metadataPropertyDependences.Count != 0)
            OnMetadataPropertyChanged(specificMetadataDependences);
#>
    }

<#+
    }
    return true;
}

bool AddHandlers(SpecificationsElements specificationsElements, string edmTypeName, List<MethodDependencesInfo> getPropertyDependences, List<MethodDependencesInfo> validatePropertyDependences, List<MetadataDependencesInfo> metadataPropertyDependences, EdmxElements edmxElements, List<MethodDeclarationSyntax> validateMethods, string previousPropertyName, string prefix, bool fromHandlers = false)
{
    var getPropertyDependencesLoop = getPropertyDependences;
    var validatePropertyDependencesLoop = validatePropertyDependences;
    var metadataPropertyDependencesLoop = metadataPropertyDependences;
    bool result = false;
    string prefixValue;
    if (string.IsNullOrEmpty(prefix))
        prefixValue = string.Concat(prefix, previousPropertyName, "_");
    else
        prefixValue = prefix;
    while ((getPropertyDependencesLoop = getPropertyDependencesLoop.Where(pd => pd.Properties.Count != 0).ToList()).Count != 0 | (validatePropertyDependencesLoop = validatePropertyDependencesLoop.Where(pd => pd.Properties.Count != 0).ToList()).Count != 0 |
(metadataPropertyDependencesLoop = metadataPropertyDependencesLoop.Where(pd => pd.Properties.Count != 0).ToList()).Count != 0)
    {
        var property = (getPropertyDependencesLoop.Count == 0 ? (validatePropertyDependencesLoop.Count == 0 ? (IEnumerable<DependencesInfo>)metadataPropertyDependencesLoop : validatePropertyDependencesLoop) : getPropertyDependencesLoop).Select(pd => new { pd.Property, FirstProperty = pd.Properties.First(p => p.Count == 1).First() }).First();
        var propertyName = property.FirstProperty.Name;

        var getSubPropertyDependences = GetSubPropertyDependences(getPropertyDependences, propertyName);
        var validateSubPropertyDependences = GetSubPropertyDependences(validatePropertyDependences, propertyName);
        var metadataSubPropertyDependences = GetSubPropertyDependences(metadataPropertyDependences, propertyName);
        validateMethods = validateSubPropertyDependences.Select(pd => pd.Method).ToList();
        var propertyNames = getSubPropertyDependences.OfType<DependencesInfo>().Union(validateSubPropertyDependences).Union(metadataSubPropertyDependences).Select(p => p.Property.Name);
        if (propertyNames.Any())
            propertyNames = propertyNames.Union(new [] { previousPropertyName });
        result |= propertyNames.Any(p => _currentEdmTypePropertyWithHandlers.Any(p2 => p2.Name == p));
        string newPrefix = string.IsNullOrEmpty(prefix) ? string.Concat(prefixValue, property.Property.Name, "_") : prefixValue;
        string newNewPrefix = string.Concat(newPrefix, propertyName, "_");
        AddHandler(specificationsElements, property.FirstProperty, edmTypeName, getSubPropertyDependences, validateSubPropertyDependences, metadataSubPropertyDependences, edmxElements, validateMethods, newPrefix, propertyName, newNewPrefix);
        if (! fromHandlers)
            AddHandlers(specificationsElements, edmTypeName, getSubPropertyDependences, validateSubPropertyDependences, metadataSubPropertyDependences, edmxElements, validateMethods, propertyName, newNewPrefix);

        getPropertyDependencesLoop = getPropertyDependencesLoop.Select(pd => new MethodDependencesInfo { ClassName = pd.ClassName, Method = pd.Method, Properties = pd.Properties.Where(ps => ps[0].Name != propertyName).ToList(), Property = pd.Property }).ToList();
        validatePropertyDependencesLoop = validatePropertyDependencesLoop.Select(pd => new MethodDependencesInfo { ClassName = pd.ClassName, Method = pd.Method, Properties = pd.Properties.Where(ps => ps[0].Name != propertyName).ToList(), Property = pd.Property }).ToList();
        metadataPropertyDependencesLoop = metadataPropertyDependencesLoop.Select(pd => new MetadataDependencesInfo { ClassName = pd.ClassName, Metadata = pd.Metadata, Properties = pd.Properties.Where(ps => ps[0].Name != propertyName).ToList(), Property = pd.Property }).ToList();
    }
    return result;
}

void AddHandler(SpecificationsElements specificationsElements, PropertySymbolInfo property, string edmTypeName, List<MethodDependencesInfo> getPropertyDependences, List<MethodDependencesInfo> validatePropertyDependences, List<MetadataDependencesInfo> metadataPropertyDependences, EdmxElements edmxElements, List<MethodDeclarationSyntax> validateMethods, string prefix = "", string propertyName = null, string newPrefix = null)
{
    if (propertyName == null)
        propertyName = property.Name;
    if (newPrefix == null)
        newPrefix = string.Concat(prefix, propertyName, "_");
    bool isCollection = IsCollection(property);
    string propertyTypeElementName;
    if (isCollection)
    {
        if (getPropertyDependences.Count == 0)
            return;
        propertyTypeElementName = ((INamedTypeSymbol)(property.Type.TypeSymbol)).TypeArguments[0].Name;
#>
    private void <#=prefix#><#=propertyName#>CollectionChanged(object _, NotifyCollectionChangedEventArgs e)
    {
        switch (e.Action)
        {
            case NotifyCollectionChangedAction.Add:
                foreach (<#=propertyTypeElementName#> entity in e.NewItems)
                    <#=prefix#><#=propertyName#>AddHandler(entity);
<#+
        OnGetPropertyChanged(getPropertyDependences, 2);
        OnMetadataPropertyChanged(metadataPropertyDependences, 2);
#>
                break;
            case NotifyCollectionChangedAction.Remove:
                foreach (<#=propertyTypeElementName#> entity in e.OldItems)
                    <#=prefix#><#=propertyName#>RemoveHandler(entity);
<#+
        OnGetPropertyChanged(getPropertyDependences, 2);
#>
                break;
            case NotifyCollectionChangedAction.Replace:
                foreach (<#=propertyTypeElementName#> entity in e.NewItems)
                    <#=prefix#><#=propertyName#>AddHandler(entity);
                foreach (<#=propertyTypeElementName#> entity in e.OldItems)
                    <#=prefix#><#=propertyName#>RemoveHandler(entity);
<#+
        OnGetPropertyChanged(getPropertyDependences, 2);
#>
                break;
            case NotifyCollectionChangedAction.Reset:
                // Should not append because TrackableCollection uses Remove for each of them instead using real Clear method
                throw new InvalidOperationException();
        }
    }
<#+	
        string typeName = TypeSymbolInfo.GetBasicTypeName(getPropertyDependences[0].Property.Type.TypeSymbol);
        AddOrRemoveHandler(specificationsElements, prefix, propertyName, edmTypeName, true, typeName, getPropertyDependences, validatePropertyDependences, metadataPropertyDependences, edmxElements, newPrefix, true, validateMethods);
        AddOrRemoveHandler(specificationsElements, prefix, propertyName, edmTypeName, true, typeName, getPropertyDependences, validatePropertyDependences, metadataPropertyDependences, edmxElements, newPrefix, false, validateMethods);
    }
    else
        propertyTypeElementName = property.Type.Name;
    if (MustAddHandler(property, getPropertyDependences, edmxElements) || MustAddHandler(property, validatePropertyDependences, edmxElements))
    {
        AddOrRemoveHandler(specificationsElements, prefix, propertyName, edmTypeName, false, propertyTypeElementName, getPropertyDependences, validatePropertyDependences, metadataPropertyDependences, edmxElements, newPrefix, true, validateMethods);
        AddOrRemoveHandler(specificationsElements, prefix, propertyName, edmTypeName, false, propertyTypeElementName, getPropertyDependences, validatePropertyDependences, metadataPropertyDependences, edmxElements, newPrefix, false, validateMethods);
    }
}

bool IsCollection(PropertySymbolInfo property)
{
    return property.Type.AllInterfaces.Any(i => i.ToString() == "System.Collections.Specialized.INotifyCollectionChanged") && ((INamedTypeSymbol)(property.Type.TypeSymbol)).TypeArguments.OfType<TypeSymbol>().Count() == 1;
}

bool MustAddHandler(PropertySymbolInfo property, IEnumerable<DependencesInfo> propertyDependences, EdmxElements edmxElements)
{
    return IsCollection(property) || edmxElements.EdmTypes.Any(et => edmxElements.Code.Escape(et) == property.Type.Name) && propertyDependences.Any(pd => pd.Properties.Any(ps => ps.Count > 0));
}

List<MethodDependencesInfo> GetSubPropertyDependences(List<MethodDependencesInfo> propertyDependences, string propertyName)
{
    return propertyDependences.Where(pd => pd.Properties.Any(ps => ps[0].Name == propertyName)).Select(pd => new MethodDependencesInfo { ClassName = pd.ClassName, Method = pd.Method, Properties = pd.Properties.Where(ps => ps[0].Name == propertyName).Select(ps => ps.Skip(1).ToList()).Where(ps => ps.Count != 0).ToList(), Property = pd.Properties.First(ps => ps[0].Name == propertyName)[0] }).ToList();
}
List<MetadataDependencesInfo> GetSubPropertyDependences(List<MetadataDependencesInfo> propertyDependences, string propertyName)
{
    return propertyDependences.Where(pd => pd.Properties.Any(ps => ps[0].Name == propertyName)).Select(pd => new MetadataDependencesInfo { ClassName = pd.ClassName, Metadata = pd.Metadata, Properties = pd.Properties.Where(ps => ps[0].Name == propertyName).Select(ps => ps.Skip(1).ToList()).Where(ps => ps.Count != 0).ToList(), Property = pd.Properties.First(ps => ps[0].Name == propertyName)[0] }).ToList();
}

void AddOrRemoveHandler(SpecificationsElements specificationsElements, string prefix, string propertyName, string edmTypeName, bool isCollection, string propertyTypeElementName, List<MethodDependencesInfo> getSubPropertyDependences, List<MethodDependencesInfo> validateSubPropertyDependences, List<MetadataDependencesInfo> metadataSubPropertyDependences, EdmxElements edmxElements, string newPrefix, bool add, List<MethodDeclarationSyntax> validateMethods)
{
    string elt = isCollection ? "collection" : "entity";
#>

    private void <#=prefix#><#=propertyName#><#=add ? "Add" : "Remove"#>Handler(<#=propertyTypeElementName#> <#=elt#>)
    {
<#+
    bool getPropertyChangingPropertiesAdded = true;
    var getPropertyChangingProperties = new Dictionary<string, List<MethodDependencesInfo>>();
    var getPropertyChangingPropertiesPropertySymbolInfo = new Dictionary<string, PropertySymbolInfo>();
    bool getPropertyChangedPropertiesAdded = false;
    var getPropertyChangedProperties = new Dictionary<string, List<MethodDependencesInfo>>();
    bool validatePropertyChangingPropertiesAdded = true;
    var validatePropertyChangingProperties = new Dictionary<string, List<MethodDependencesInfo>>();
    bool validatePropertyChangedPropertiesAdded = false;
    var validatePropertyChangedProperties = new Dictionary<string, List<MethodDependencesInfo>>();
    var metadataPropertyChangingProperties = new Dictionary<string, List<MetadataDependencesInfo>>();
    bool metadataPropertyChangedPropertiesAdded = false;
    var metadataPropertyChangedProperties = new Dictionary<string, List<MetadataDependencesInfo>>();
    var subProperties = new Dictionary<PropertySymbolInfo, TypeSymbol>();
    if (isCollection)
    {
#>
        if (collection != null)
        {
            foreach (var entity in collection)
                <#=prefix#><#=propertyName#><#=add ? "Add" : "Remove"#>Handler(entity);
            collection.CollectionChanged <#=add ? "+" : "-"#>= <#=prefix#><#=propertyName#>CollectionChanged;
        }
<#+
    }
    else
    {
        bool first = true;
        var alreadyAdded = new List<string>();
        foreach (var subProperty in (getSubPropertyDependences.Cast<DependencesInfo>().Union(validateSubPropertyDependences).Union(metadataSubPropertyDependences)).SelectMany(subPropertyDependence => subPropertyDependence.Properties.Where(ps => ps.Count == 1).Select(ps => ps[0])))
        {
            var entityType = _edmxElements.EntityTypes.FirstOrDefault(et => et.Name == propertyTypeElementName);
            if (entityType != null)
            {
                var entityTypeLoop = entityType;
                while (entityTypeLoop != null && entityTypeLoop.Name != subProperty.ContainingType.Name)
                    entityTypeLoop = (EntityType)entityTypeLoop.BaseType;
                if (entityTypeLoop != null)
                {
                    if (! subProperties.ContainsKey(subProperty))
                        subProperties.Add(subProperty, null);
                }
                else
                    subProperties.Add(subProperty, subProperty.ContainingType.TypeSymbol);
            }
        }

        var additionalPropertiesChanging = new Dictionary<string, List<string>>();
        foreach (var subPropertyDependence in getSubPropertyDependences)
        {
            foreach (var subProperty in subPropertyDependence.Properties.Where(ps => ps.Count == 1).Select(ps => ps[0]))
            {
                if (! MustAddHandler(subProperty, getSubPropertyDependences, edmxElements))
                {
                    List<MethodDependencesInfo> propertyChangedPropertiesDependences;
                    if (! getPropertyChangedProperties.TryGetValue(subProperty.Name, out propertyChangedPropertiesDependences))
                        getPropertyChangedProperties.Add(subProperty.Name, propertyChangedPropertiesDependences = new List<MethodDependencesInfo>());
                    propertyChangedPropertiesDependences.AddRange(GetSubPropertyDependences(getSubPropertyDependences, subProperty.Name));
                    continue;
                }
                List<MethodDependencesInfo> propertyChangingPropertiesDependences;
                if (! getPropertyChangingProperties.TryGetValue(subProperty.Name, out propertyChangingPropertiesDependences))
                {
                    getPropertyChangingProperties.Add(subProperty.Name, propertyChangingPropertiesDependences = new List<MethodDependencesInfo>());
                    getPropertyChangingPropertiesPropertySymbolInfo.Add(subProperty.Name, subProperty);
                }
                else
                    getPropertyChangingPropertiesAdded = false;
                propertyChangingPropertiesDependences.AddRange(GetSubPropertyDependences(getSubPropertyDependences, subProperty.Name));
                if (getPropertyChangingPropertiesAdded)
                {
                    alreadyAdded.Add(subProperty.Name);
                    TypeSymbol containingType;
                    if (subProperties.TryGetValue(subProperty, out containingType) && containingType != null)
                    {
                        List<string> properties;
                        if (!additionalPropertiesChanging.TryGetValue(containingType.Name, out properties))
                            additionalPropertiesChanging.Add(containingType.Name, properties = new List<string>());
                        properties.Add(subProperty.Name);
                        continue;
                    }
                    if (first)
                    {
                        first = false;
#>
        if (entity != null)
        {			
<#+
                    }
#>
            entity.<#=subProperty.Name#>PropertyChanging <#=add ? "+" : "-"#>= <#=newPrefix#><#=subProperty.Name#>PropertyChanging;
<#+
                }
            }
        }
        foreach (var additionPropertyChanging in additionalPropertiesChanging)
        {
#>
        var entityAs<#=additionPropertyChanging.Key#> = entity as <#=additionPropertyChanging.Key#>;
        if (entityAs<#=additionPropertyChanging.Key#> != null)
        {
<#+
            foreach (var p in additionPropertyChanging.Value)
            {
#>
            entityAs<#=additionPropertyChanging.Key#>.<#=p#>PropertyChanging <#=add ? "+" : "-"#>= <#=newPrefix#><#=p#>PropertyChanging;
<#+
            }
#>
        }
<#+
        }
        if (! (getPropertyChangedProperties.Count == 0 || getPropertyChangedPropertiesAdded))
        {
            getPropertyChangedPropertiesAdded = true;
            alreadyAdded.Add(propertyName);		
            if (first)
            {
                first = false;
#>
        if (entity != null)
        {	
<#+
            }
#>
            entity.PropertyChanged <#=add ? "+" : "-"#>= <#=prefix#><#=propertyName#>PropertyChanged;
<#+
        }
        foreach (var subPropertyDependence in validateSubPropertyDependences)
        {
            foreach (var subProperty in subPropertyDependence.Properties.Where(ps => ps.Count == 1).Select(ps => ps[0]))
            {
                if (! MustAddHandler(subProperty, validateSubPropertyDependences, edmxElements))
                {
                    List<MethodDependencesInfo> propertyChangedPropertiesDependences;
                    if (! validatePropertyChangedProperties.TryGetValue(subProperty.Name, out propertyChangedPropertiesDependences))
                        validatePropertyChangedProperties.Add(subProperty.Name, propertyChangedPropertiesDependences = new List<MethodDependencesInfo>());
                    propertyChangedPropertiesDependences.AddRange(GetSubPropertyDependences(validateSubPropertyDependences, subProperty.Name));
                    continue;
                }
                List<MethodDependencesInfo> propertyChangingPropertiesDependences;
                if (! validatePropertyChangingProperties.TryGetValue(subProperty.Name, out propertyChangingPropertiesDependences))
                {
                    validatePropertyChangingProperties.Add(subProperty.Name, propertyChangingPropertiesDependences = new List<MethodDependencesInfo>());
                    if (! getPropertyChangingPropertiesPropertySymbolInfo.ContainsKey(subProperty.Name))
                        getPropertyChangingPropertiesPropertySymbolInfo.Add(subProperty.Name, subProperty);
                }
                else
                    validatePropertyChangingPropertiesAdded = false;
                propertyChangingPropertiesDependences.AddRange(GetSubPropertyDependences(validateSubPropertyDependences, subProperty.Name));
                if (validatePropertyChangingPropertiesAdded)
                {
                    if (first)
                    {
                        first = false;
#>
        if (entity != null)
        {			
<#+
                    }
#>
            entity.<#=subProperty.Name#>PropertyChanging <#=add ? "+" : "-"#>= <#=newPrefix#><#=subProperty.Name#>PropertyChanging;
<#+
                }
            }
        }
        if (! (validatePropertyChangedProperties.Count == 0 || validatePropertyChangedPropertiesAdded))
        {
            validatePropertyChangedPropertiesAdded = true;
            if (! alreadyAdded.Contains(propertyName))
            {
                alreadyAdded.Add(propertyName);		
                if (first)
                {
                    first = false;
#>
        if (entity != null)
        {			
<#+
                }
#>
            entity.PropertyChanged <#=add ? "+" : "-"#>= <#=prefix#><#=propertyName#>PropertyChanged;
<#+
            }
        }
        foreach (var subPropertyDependence in metadataSubPropertyDependences)
        {
            foreach (var subProperty in subPropertyDependence.Properties.Where(ps => ps.Count == 1).Select(ps => ps[0]))
            {
                if (! MustAddHandler(subProperty, metadataSubPropertyDependences, edmxElements))
                {
                    List<MetadataDependencesInfo> propertyChangedPropertiesDependences;
                    if (! metadataPropertyChangedProperties.TryGetValue(subProperty.Name, out propertyChangedPropertiesDependences))
                        metadataPropertyChangedProperties.Add(subProperty.Name, propertyChangedPropertiesDependences = new List<MetadataDependencesInfo>());
                    propertyChangedPropertiesDependences.AddRange(GetSubPropertyDependences(metadataSubPropertyDependences, subProperty.Name));
                    continue;
                }
            }
        }
        if (! (metadataPropertyChangedProperties.Count == 0 || metadataPropertyChangedPropertiesAdded))
        {
            metadataPropertyChangedPropertiesAdded = true;
            if (! alreadyAdded.Contains(propertyName))
            {
                alreadyAdded.Add(propertyName);		
                if (first)
                {
                    first = false;
#>
        if (entity != null)
        {			
<#+
                }
#>
            entity.PropertyChanged <#=add ? "+" : "-"#>= <#=prefix#><#=propertyName#>PropertyChanged;
<#+
            }
        }
        if (! first)
        {
#>
        }
<#+
        }
    }
#>
    }
<#+
    if (add)
    {
        if (getPropertyChangingProperties.Count != 0 | validatePropertyChangingProperties.Count != 0 | metadataPropertyChangingProperties.Count != 0)
        {
            foreach (var key in getPropertyChangingProperties.Keys.Union(validatePropertyChangingProperties.Keys).Union(metadataPropertyChangingProperties.Keys).Distinct())
            {
                List<MethodDependencesInfo> getValues, validateValues;
                List<MetadataDependencesInfo> metadataValues;
                if (! getPropertyChangingProperties.TryGetValue(key, out getValues))
                    getValues = new List<MethodDependencesInfo>();
                if (! validatePropertyChangingProperties.TryGetValue(key, out validateValues))
                    validateValues = new List<MethodDependencesInfo>();
                if (! metadataPropertyChangingProperties.TryGetValue(key, out metadataValues))
                    metadataValues = new List<MetadataDependencesInfo>();
                var propertyInfo = getPropertyChangingPropertiesPropertySymbolInfo[key];
                string typeName = TypeSymbolInfo.GetBasicTypeName(propertyInfo.Type.TypeSymbol);
                bool addRemoveHandler = AddHandlers(specificationsElements, edmTypeName, getValues, validateValues, metadataValues, edmxElements, validateMethods, propertyName, prefix);
#>
    private void <#=newPrefix#><#=key#>PropertyChanging(<#=typeName#> oldValue, <#=typeName#> newValue)
    {
<#+
    if (addRemoveHandler)
    {
#>
        <#=newPrefix#><#=key#>RemoveHandler(oldValue);
        <#=newPrefix#><#=key#>AddHandler(newValue);
<#+
    }
    if (getValues != null)
        OnGetPropertyChanged(getValues);
    if (metadataValues != null)
        OnMetadataPropertyChanged(metadataValues);
#>
    }
<#+
            }
        }
        if (! (getPropertyChangedProperties.Count == 0 && validatePropertyChangedProperties.Count == 0))
        {
#>

    private void <#=prefix#><#=propertyName#>PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
<#+
            foreach (var propertiesPerType in  
                from pr in getPropertyChangedProperties.Select(p => new { Properties = new { Key = p.Key, Value = p.Value.Cast<DependencesInfo>() }, DependenceType = DependenceType.Get })
                    .Union(validatePropertyChangedProperties.Select(p => new { Properties = new { Key = p.Key, Value = p.Value.Cast<DependencesInfo>() }, DependenceType = DependenceType.Validate }))
                    .Union(metadataPropertyChangedProperties.Select(p => new { Properties = new { Key = p.Key, Value = p.Value.Cast<DependencesInfo>() }, DependenceType = DependenceType.Metadata}))
                group pr by subProperties[pr.Properties.Value.First().Property] into groupByType
                orderby groupByType.Key
                select new { Type = groupByType.Key, Properties = groupByType.GroupBy(p => p.Properties.Key) })
            {
                if (! (propertiesPerType.Type == null || propertiesPerType.Type.IsAnonymousType))
                {
                    string typeName = propertiesPerType.Type.Name;
                    List<string> classes;
                    if (_specificationsElements.ClassesPerInterfaces.TryGetValue(propertiesPerType.Type.ToString(), out classes))
                        typeName = classes.Single();
                        if (typeName == "Collection")
                            typeName = "ICollection";
#>
        if (sender is <#=typeName#>)
        {
<#+
                    PushIndent(CodeRegion.GetIndent(1));
                }
#>
        switch (e.PropertyName)
        {
<#+
                foreach (var gp in propertiesPerType.Properties)
                {
#>
            case "<#=gp.Key#>":
<#+
                    foreach (var p in gp)
                        switch(p.DependenceType)
                        {
                            case DependenceType.Get:
                                OnGetPropertyChanged(p.Properties.Value.Cast<MethodDependencesInfo>(), 2);
                                break;
                            case DependenceType.Validate:
                                OnValidatePropertyChanged(specificationsElements, gp.SelectMany(pds => pds.Properties.Value.Select(pd => ((MethodDependencesInfo)pd).Method)).Distinct(), CurrentEdmType, propertyName, 2, false);
                                break;
                            case DependenceType.Metadata:
                                OnMetadataPropertyChanged(p.Properties.Value.Cast<MetadataDependencesInfo>(), 2);
                                break;
                        }
#>
                break;
<#+
                }
#>
        }
<#+
                if (! (propertiesPerType.Type == null || propertiesPerType.Type.IsAnonymousType))
                {
                    PopIndent();
#>
        }
<#+
                }
            }
#>
    }
<#+
        }
    }
}

enum DependenceType
{
    Get,
    Validate,
    Metadata
}

void OnGetPropertyChanged(IEnumerable<MethodDependencesInfo> dependences, int tab = 0)
{
    PushIndent(CodeRegion.GetIndent(tab));
    foreach (var propertyDependence in dependences.Select(dp => SpecificationMethods.GetPropertyNameFromMethod(dp.Method)).Distinct())
    {
#>
        On<#=propertyDependence#>Changed();
<#+
    }
    PopIndent();
} 

void OnValidatePropertyChanged(SpecificationsElements specificationsElements, IEnumerable<MethodDeclarationSyntax> validateMethods, EdmType edmType, string propertyName, int tab = 0, bool addErrors = true, List<string> validatedProperties = null)
{
    PushIndent(CodeRegion.GetIndent(tab));
    if (addErrors && validateMethods.Any())
    {
        EntityType edmTypeAsEntityType;
        var validateMethodsEnumerator = validateMethods.Where(m => specificationsElements.IsApplicableOnClient(m) && ((edmTypeAsEntityType = edmType as EntityType) == null || !_specificationsElements.MethodsDependentProperties[m].SelectMany(pds => pds.Take(1)).Any(p => edmTypeAsEntityType.NavigationProperties.Any(p2 => _edmxElements.Code.Escape(p2) == p.Name)))).GetEnumerator();
        if (validateMethodsEnumerator.MoveNext())
        {
#>
        var validateMessageSB = new StringBuilder();
        Error error;
<#+
            for(;;)
            {
#>
        error = <#=validateMethodsEnumerator.Current.Identifier.ValueText#>();
        if (error != null && (error.Criticity & Criticity.Error) != 0)
        {
            validateMessageSB.Append(error.Message);
<#+
                if (validateMethodsEnumerator.MoveNext())
                {
#>
            validateMessageSB.Append(Environment.NewLine);
        }
<#+
                }
                else
                {
#>
        }
<#+
                    break;
                }
            }
#>
        Validators.DefineErrors(validateMessageSB.ToString(), () => <#=propertyName#>, DataErrorInfo);
<#+
        }
        IEnumerable<EdmMember> properties;
        var entityType = CurrentEdmType as EntityType;
        ComplexType complexType;
        if (entityType != null)
            properties = entityType.Properties.OfType<EdmMember>().Union(entityType.NavigationProperties);
        else if ((complexType = CurrentEdmType as ComplexType) != null)
            properties = complexType.Properties;
        else
            throw new NotImplementedException();
        var otherProperties = validateMethods.SelectMany(m => _specificationsElements.MethodsDependentProperties[m]).Where(pds => pds.Count == 1).Select(pds => pds[0]).Select(p => p.Name).Where(p => ! properties.Any(p2 => _edmxElements.Code.Escape(p2) == p && ! (p2.TypeUsage.EdmType is SimpleType && IsPublic(p2)))).ToList();
        if (otherProperties.Count != 0)
        {
            foreach (var pName in otherProperties.Distinct())
            {
                if (pName == propertyName)
                    continue;
                if (! (entityType.KeyMembers.Any(k => _edmxElements.Code.Escape(k) == pName) || validatedProperties == null || validatedProperties.Contains(propertyName)))
                {
                    validatedProperties.Add(pName);
#>
        AddValidationProperty("<#=pName#>"); 
<#+
                }
            }
        }
    }
    PopIndent();
} 

void OnMetadataPropertyChanged(IEnumerable<MetadataDependencesInfo> dependences, int tab = 0, string methodPropertyName = null, bool addNullable = false, bool addMaxLength = false, List<string> validatedProperties = null)
{
    PushIndent(CodeRegion.GetIndent(tab));
    foreach (var propertyDependence in dependences)
    {
        string methodName = propertyDependence.Metadata.MethodName.Replace("Define", "").Replace("IsNullable", "Required");
        string propertyName = propertyDependence.Metadata.Property;
#>
        Validate<#=propertyName#><#=methodName#>(<#=propertyName#>);
<#+
        foreach (var dp in propertyDependence.Metadata.DependentProperties.Where(dps => dps.Count == 1).SelectMany(dps => dps))
        {
            string dpName = dp.Name;
            if (! (methodPropertyName == dpName || validatedProperties == null || validatedProperties.Contains(dpName)))
            {
                validatedProperties.Add(dpName);
#>
        AddValidationProperty("<#=dpName#>"); 
<#+
            }
#>
        NotifyPropertyChanged.RaisePropertyChanged("<#=propertyName#><#=propertyDependence.Metadata.MethodName.Replace("Define", "").Replace("IsNullable", "IsMandatory")#>");
<#+
        }
    }
    if (addNullable)
    {
#>
        Validate<#=methodPropertyName#>Required(<#=methodPropertyName#>);
<#+
    }
    if (addMaxLength)
    {
#>
        Validate<#=methodPropertyName#>MaxLength(<#=methodPropertyName#>);
<#+
    }
    PopIndent();
} 

void WriteUISpecifications(CodeGenerationTools code, StructuralType edmType, string edmTypeFullName, List<MethodDeclarationSyntax> getMethods, IEnumerable<EdmProperty> properties, IEnumerable<NavigationProperty> navigationProperties, List<WAQSMetadata> metadata)
{
    bool hasProperty = IsEntityWithErrors(properties, navigationProperties, getMethods);
    bool @override = false;
    string baseTypeName = null;
    if (hasProperty)
    {
        AddPropertyDescriptorsOnType(code, edmType, properties, navigationProperties, getMethods);
        var className = code.Escape(edmType);
#>
    private UISpecificationsInfo _uiSpecifications;
    private UISpecificationsInfo UISpecifications
    {
        get { return _uiSpecifications ?? (_uiSpecifications = Create<#=className#>UISpecifications()); }
    }

    protected virtual UISpecificationsInfo Create<#=className#>UISpecifications()
    {
        return new UISpecificationsInfo();
    }
<#+
        }
        if (hasProperty || metadata != null && metadata.Count != 0)
        {
            EntityType edmTypeLoop = edmType as EntityType;
            if (edmTypeLoop != null)
                while ((edmTypeLoop = edmTypeLoop.BaseType as EntityType) != null)
                {
                    string edmTypeLoopName = code.Escape(edmTypeLoop);
                    List<MethodDeclarationSyntax> typeLoopGetMethods;
                    if (! (edmTypeLoop.Properties.Any(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == edmTypeLoop && IsPublic(p)) || edmTypeLoop.NavigationProperties.Any(np => np.DeclaringType == edmTypeLoop && IsPublic(np) && np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One) || (_specificationsElements.GetMethods.TryGetValue(code.Escape(edmTypeLoop), out typeLoopGetMethods) && typeLoopGetMethods.Count != 0)))
                        continue;
                    @override = true;
                    if (baseTypeName == null)
                        baseTypeName = code.Escape(edmTypeLoop);
#>
    protected override <#=edmTypeLoopName#>.UISpecificationsInfo Create<#=edmTypeLoopName#>UISpecifications()
    {
        return new UISpecificationsInfo();
    }
<#+
                }

#>

    public <#=string.IsNullOrEmpty(baseTypeName) ? "" : "new "#>partial class UISpecificationsInfo<#=string.IsNullOrEmpty(baseTypeName) ? "" : string.Concat(" : ", baseTypeName, ".", "UISpecificationsInfo")#>
    {
<#+
        var entityType = edmType as EntityType;
        foreach (var edmProperty in entityType == null ? properties : entityType.Properties.Where(p => p.DeclaringType == edmType || metadata.Any(m => m.Property == code.Escape(p))))
        {
            bool specificProperty = edmProperty.DeclaringType == edmType;
            string virtualOverride = specificProperty ? "virtual" : "override";
            string propertyName = code.Escape(edmProperty);
            string propertyTypeName = code.Escape(edmProperty.DeclaringType);
            bool isRequired;
            int? maxLength, minLength;
            WAQSMetadata isNullableMatadata, minValueMetadata, maxValueMetadata, minLengthMetadata, maxLengthMetadata, patternMetadata;
            SyntaxNode metadataLambdaIsNullable, metadataLambdaMinValue, metadataLambdaMaxValue, metadataLambdaMinLength, metadataLambdaMaxLength, metadataLambdaPattern;
            GetValidateMetadata(edmProperty, propertyName, metadata, out isRequired, out isNullableMatadata, out minLengthMetadata, out maxLength, out maxLengthMetadata, out minValueMetadata, out maxValueMetadata, out patternMetadata, out metadataLambdaIsNullable, out metadataLambdaMinValue, out metadataLambdaMaxValue, out metadataLambdaMinLength, out metadataLambdaMaxLength, out metadataLambdaPattern, out minLength, SyntaxFactory.IdentifierName("entity"));
            if (specificProperty || isNullableMatadata != null)
            {
#>
        public <#=virtualOverride#> bool Get<#=propertyName#>IsMandatory(<#=propertyTypeName#> <#=! specificProperty && metadataLambdaIsNullable != null ? "baseE" : "e"#>ntity)
        {
<#+
                if (! specificProperty && metadataLambdaIsNullable != null)
                {
#>
            var entity = (<#=code.Escape(entityType)#>)baseEntity;
<#+
                }
#>
            return <#=isRequired ? "true" : metadataLambdaIsNullable == null ? "false" : SyntaxFactory.PrefixUnaryExpression(SyntaxKind.LogicalNotExpression, SyntaxFactory.ParenthesizedExpression((ExpressionSyntax)metadataLambdaIsNullable)).NormalizeWhitespace().ToString()#>;
        }	
        
<#+
            }
            if ((specificProperty || maxLengthMetadata != null) && (edmProperty.TypeUsage.ToString() == "Edm.String" || edmProperty.TypeUsage.ToString() == "Edm.Binary"))
            {
#>
        public <#=virtualOverride#> int? Get<#=propertyName#>MaxLength(<#=propertyTypeName#>  <#=! specificProperty && metadataLambdaMaxLength != null ? "baseE" : "e"#>ntity)
        {
<#+
            if (metadataLambdaMaxLength != null)
            {
                if (! specificProperty)
                {
#>
            var subEntity = entity as <#=code.Escape(entityType)#>;
<#+
                }
#>
            int? maxLength = <#=metadataLambdaMaxLength.NormalizeWhitespace().ToString()#>;
<#+
            }
#>
            return <#=metadataLambdaMaxLength == null ? (maxLength.HasValue ? maxLength.ToString() : "null") : maxLength.HasValue ? string.Format("maxLength.HasValue ? Math.Min({0}, maxLength.Value) : {0}", maxLength) : "maxLength"#>;
        }

<#+
            if (specificProperty || minLengthMetadata != null)
            {
#>
        public <#=virtualOverride#> int? Get<#=propertyName#>MinLength(<#=propertyTypeName#>  <#=! specificProperty && metadataLambdaMinLength != null ? "baseE" : "e"#>ntity)
        {
<#+
                if (! specificProperty && metadataLambdaMinLength != null)
                {
#>
            var subEntity = entity as <#=code.Escape(entityType)#>;
<#+
                }
#>
            return <#=minLength.HasValue ? minLength.Value.ToString() : metadataLambdaMinLength == null ? "null" : metadataLambdaMinLength.NormalizeWhitespace().ToString()#>;
        }

<#+
            }
            if ((specificProperty || patternMetadata != null) && edmProperty.TypeUsage.ToString() == "Edm.String")
            {
#>
        public <#=virtualOverride#> string Get<#=propertyName#>Pattern(<#=propertyTypeName#>  <#=! specificProperty && metadataLambdaPattern != null ? "baseE" : "e"#>ntity)
        {
<#+
                if (! specificProperty && metadataLambdaPattern != null)
                {
#>
            var subEntity = entity as <#=code.Escape(entityType)#>;
<#+
                }
#>
            return <#=metadataLambdaPattern == null ? (patternMetadata == null ? "null" : patternMetadata.ConstantExpression.NormalizeWhitespace().ToString()) : metadataLambdaPattern.NormalizeWhitespace().ToString()#>;
        }

<#+
            }
        }
        else
        {
            string typeName;
            switch (edmProperty.TypeUsage.ToString())
            {
                case "Edm.Byte":
                    typeName = "byte";
                    break;
                case "Edm.DateTime":
                    typeName = "DateTime";
                    break;
                case "Edm.DateTimeOffset":
                    typeName = "DateTimeOffset";
                    break;
                case "Edm.Time":
                    typeName = "TimeSpan";
                    break;
                case "Edm.Decimal":
                    typeName = "decimal";
                    break;
                case "Edm.Double":
                    typeName = "double";
                    break;
                case "Edm.Single":
                    typeName = "float";
                    break;
                case "Edm.Int16":
                    typeName = "short";
                    break;
                case "Edm.Int32":
                    typeName = "int";
                    break;
                case "Edm.Int64":
                    typeName = "long";
                    break;
                case "Edm.SByte":
                    typeName = "sbyte";
                    break;
                default:
                    typeName = null;
                    break;
            }
            if (typeName != null)
            {
                if (specificProperty || minValueMetadata != null)
                {
#>
        public <#=virtualOverride#> <#=typeName#>? Get<#=propertyName#>MinValue(<#=propertyTypeName#> entity)
        {
<#+
                if (! specificProperty && metadataLambdaMinValue != null)
                {
#>
            var subEntity = entity as <#=code.Escape(entityType)#>;
<#+
                }
#>
            return <#=metadataLambdaMinValue == null ? (minValueMetadata == null ? "null" : minValueMetadata.ConstantExpression.NormalizeWhitespace().ToString()) : metadataLambdaMinValue.NormalizeWhitespace().ToString()#>;
        }

<#+
                }
                if (specificProperty || maxValueMetadata != null)
                {
#>
        public <#=virtualOverride#> <#=typeName#>? Get<#=propertyName#>MaxValue(<#=propertyTypeName#> entity)
        {
<#+
                if (! specificProperty && metadataLambdaMaxValue != null)
                {
#>
            var subEntity = entity as <#=code.Escape(entityType)#>;
<#+
                }
#>
            return <#=metadataLambdaMaxValue == null ? (maxValueMetadata == null ? "null" : maxValueMetadata.ConstantExpression.NormalizeWhitespace().ToString()) : metadataLambdaMaxValue.NormalizeWhitespace().ToString()#>;
        }

<#+
                }
            }
        }
    }
    foreach (var navigationProperty in navigationProperties.Where(np => np.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many))
    {
        string propertyName = code.Escape(navigationProperty);
#>
        public virtual bool Get<#=propertyName#>IsMandatory(<#=edmTypeFullName#> entity)
        {
            return <#=navigationProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One ? "true" : "false"#>;
        }	
        
<#+		
        }
#>
    }
<#+
    }
    if (hasProperty)
    {
#>

    private ErrorsSpecifications _errors;
    protected <#=string.IsNullOrEmpty(baseTypeName) ? "" : "new "#>ErrorsSpecifications Errors
    {
        get { return _errors ?? (_errors = new ErrorsSpecifications()); }
    }

    bool IEntityWithErrors.HasErrors
    {
        get { return Errors.AllErrors.Count != 0; }
    }

    event Action IEntityWithErrors.HasErrorsChanged
    {
        add { Errors.HasErrorChanged += value; }
        remove { Errors.HasErrorChanged += value; }
    }

    public <#=@override ? "new " : ""#>partial class ErrorsSpecifications<#=string.IsNullOrEmpty(baseTypeName) ? "" : string.Concat(" : ", baseTypeName, ".", "ErrorsSpecifications")#>
    {
<#+
        foreach (var edmProperty in properties)
        {
            string fieldName = code.FieldName(edmProperty);
#>
        private ObservableCollection<Error> <#=fieldName#>;
        public ObservableCollection<Error> <#=code.Escape(edmProperty)#>
        {
            get { return <#=fieldName#> ?? (<#=fieldName#> = new ObservableCollection<Error>()); }
        }
<#+
        }
        foreach (var navigationProperty in navigationProperties.Where(np => np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One))
        {
            string fieldName = code.FieldName(navigationProperty);
#>
        private ObservableCollection<Error> <#=fieldName#>;
        public ObservableCollection<Error> <#=code.Escape(navigationProperty)#>
        {
            get { return <#=fieldName#> ?? (<#=fieldName#> = new ObservableCollection<Error>()); }
        }
<#+
        }
        if (getMethods != null)
            foreach (var getMethod in getMethods)
            {
                string getPropertyName = SpecificationMethods.GetPropertyNameFromMethod(getMethod);
                string fieldName = "_" + code.CamelCase(getPropertyName);
#>
        private ObservableCollection<Error> <#=fieldName#>;
        public ObservableCollection<Error> <#=getPropertyName#>
        {
            get { return <#=fieldName#> ?? (<#=fieldName#> = new ObservableCollection<Error>()); }
        }
<#+
            }
            if (edmType.BaseType == null)
            {
#>
        private ObservableCollection<Error> _allErrors;
        public ObservableCollection<Error> AllErrors
        {
            get
            {
                if (_allErrors == null)
                {
                    _allErrors = new ObservableCollection<Error>();
                    NotifyCollectionChangedEventHandler errorsCollectionChanged = (_, e) =>
                        {
                            if (e.NewItems != null)
                                foreach (Error error in e.NewItems)
                                {
                                    if (! _allErrors.Any(er => er.Key == error.Key))
                                        _allErrors.Add(error);
                                }
                            if (e.OldItems != null)
                                foreach (Error error in e.OldItems)
                                    _allErrors.Remove(error);
                        };
                    AddAllErrorsHandlers(errorsCollectionChanged);
                }
                return _allErrors;
            }
        }
<#+
        }
#>

        protected <#=edmType.BaseType == null ? "virtual" : "override"#> void AddAllErrorsHandlers(NotifyCollectionChangedEventHandler errorsCollectionChanged)
        {
<#+
        if (edmType.BaseType != null)
        {
#>
            base.AddAllErrorsHandlers(errorsCollectionChanged);
<#+
        }
#>
            NotifyCollectionChangedEventHandler specificErrorsCollectionChanged = (sender, e) =>
                {
                    errorsCollectionChanged(sender, e);
                    switch (e.Action)
                    {
                        case NotifyCollectionChangedAction.Add:
                            if (AllErrors.Count == e.NewItems.Count)
                                OnHasErrorChanged();
                            break;
                        case NotifyCollectionChangedAction.Remove:
                            if (AllErrors.Count == 0)
                                OnHasErrorChanged();
                            break;
                    }
                };
<#+
        foreach (var edmProperty in properties)
        {
#>
            <#=code.Escape(edmProperty)#>.CollectionChanged += specificErrorsCollectionChanged;
<#+
        }
        foreach (var navigationProperty in navigationProperties.Where(np => np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One))
        {
#>
            <#=code.Escape(navigationProperty)#>.CollectionChanged += specificErrorsCollectionChanged;
<#+
        }
        if (getMethods != null)
            foreach (var getMethod in getMethods)
            {
#>
            <#=SpecificationMethods.GetPropertyNameFromMethod(getMethod)#>.CollectionChanged += specificErrorsCollectionChanged;
<#+
            }
#>
        }
<#+
    if (!@override)
    {
#>
        protected void OnHasErrorChanged()
        {
            if (HasErrorChanged != null)
                OnHasErrorChanged();
        }
        public event Action HasErrorChanged;
<#+
    }
#>
    }
<#+
    }
}

class GetTypesVisitor : SyntaxVisitorOfIEnumerableOfSyntaxNode
{
    public override IEnumerable<SyntaxNode> Visit(SyntaxNode node)
    {
        return base.Visit(node) ?? new SyntaxNode[0];
    }

    public override IEnumerable<SyntaxNode> VisitCompilationUnit(CompilationUnitSyntax node)
    {
        return node.ChildNodes().SelectMany(n => Visit(n));
    }

    public override IEnumerable<SyntaxNode> VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
        return node.ChildNodes().SelectMany(n => Visit(n));
    }

    public override IEnumerable<SyntaxNode> VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
        return new [] { node };
    }

    public override IEnumerable<SyntaxNode> VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        return new [] { node };
    }

    public override IEnumerable<SyntaxNode> VisitStructDeclaration(StructDeclarationSyntax node)
    {
        return new [] { node };
    }

    public override IEnumerable<SyntaxNode> VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
        return new [] { node };
    }

    public override IEnumerable<SyntaxNode> VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
        return new [] { node };
    }
}
class GetUsingsVisitor : SyntaxVisitorOfIEnumerableOfString
{
    public override IEnumerable<string> Visit(SyntaxNode node)
    {
        return base.Visit(node) ?? new string[0];
    }

    public override IEnumerable<string> VisitCompilationUnit(CompilationUnitSyntax node)
    {
        return node.ChildNodes().SelectMany(n => Visit(n));
    }

    public override IEnumerable<string> VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
        return node.ChildNodes().SelectMany(n => Visit(n));
    }

    public override IEnumerable<string> VisitUsingDirective(UsingDirectiveSyntax node)
    {
        return new[] { Regex.Match(node.NormalizeWhitespace().ToString(), @"^\s*using\s+([^;]+);").Groups[1].Value } ;
    }
}

void GetMetadataScalarProperties(EdmProperty edmProperty, string propertyName, List<WAQSMetadata> metadata, out WAQSMetadata minValueMetadata, out WAQSMetadata maxValueMetadata, out WAQSMetadata minLengthMetadata, out WAQSMetadata maxLengthMetadata, out WAQSMetadata patternMetadata, out int? maxLength)
{
    minValueMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMinValue");
    maxValueMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMaxValue");
    minLengthMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMinLength");
    maxLength = MaxLength(edmProperty);
    maxLengthMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMaxLength");
    patternMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefinePattern");
}
void WriteMetadataTestScalarPropertiesConstant(EdmProperty edmProperty, string propertyName, List<WAQSMetadata> metadata, bool isRequired, WAQSMetadata isNullableMetadata, out WAQSMetadata minValueMetadata, out WAQSMetadata maxValueMetadata, out WAQSMetadata minLengthMetadata, out WAQSMetadata maxLengthMetadata, out WAQSMetadata patternMetadata, out int? maxLength)
{
    GetMetadataScalarProperties(edmProperty, propertyName, metadata, out minValueMetadata, out maxValueMetadata, out minLengthMetadata, out maxLengthMetadata, out patternMetadata, out maxLength);
    int fixedLength = 0;
    if (FixedLength(edmProperty) && edmProperty.TypeUsage.ToString() == "Edm.String")
        fixedLength = maxLength.Value;
    bool hasAny = (isRequired || isNullableMetadata != null && isNullableMetadata.DependentProperties.Count == 0) || (minValueMetadata != null && minValueMetadata.DependentProperties.Count == 0) || (maxValueMetadata != null && maxValueMetadata.DependentProperties.Count == 0) || (minLengthMetadata != null && minLengthMetadata.DependentProperties.Count == 0) || (maxLength.HasValue || maxLengthMetadata != null && maxLengthMetadata.DependentProperties.Count == 0) || (patternMetadata != null && patternMetadata.DependentProperties.Count == 0) || (fixedLength != 0 && edmProperty.TypeUsage.ToString() == "Edm.String");
    if (hasAny)
    {
#>
            if (! (IsDeserializing || ChangeTracker.Saving))
            {
<#+
    }
    if (isRequired || isNullableMetadata != null && isNullableMetadata.DependentProperties.Count == 0)
    {
#>
                Validate<#=propertyName#>Required(value);
<#+
    }
    if (minValueMetadata != null && minValueMetadata.DependentProperties.Count == 0)
    {
#>
                Validate<#=propertyName#>MinValue(value);
<#+
    }
    if (maxValueMetadata != null && maxValueMetadata.DependentProperties.Count == 0)
    {
#>
                Validate<#=propertyName#>MaxValue(value);
<#+
    }
    if (minLengthMetadata != null && minLengthMetadata.DependentProperties.Count == 0)
    {
#>
                Validate<#=propertyName#>MinLength(value);
<#+
    }
    if (maxLength.HasValue || maxLengthMetadata != null && maxLengthMetadata.DependentProperties.Count == 0)
    {
#>
                Validate<#=propertyName#>MaxLength(value);
<#+
    }
    if (patternMetadata != null && patternMetadata.DependentProperties.Count == 0)
    {
#>
                Validate<#=propertyName#>Pattern(value);
<#+
    }
    if (fixedLength != 0 && edmProperty.TypeUsage.ToString() == "Edm.String")
    {
#>
                if (value != null)
                    value = value.PadRight(<#=fixedLength#>);
<#+
    }
    if (hasAny)
    {
#>
            }
<#+
    }}

void GetValidateMetadata(EdmProperty edmProperty, string propertyName, List<WAQSMetadata> metadata, out bool isRequired, out WAQSMetadata isNullableMetadata, out WAQSMetadata minLengthMetadata, out int? maxLength, out WAQSMetadata maxLengthMetadata, out WAQSMetadata minValueMetadata, out WAQSMetadata maxValueMetadata, out WAQSMetadata patternMetadata, out SyntaxNode metadataLambdaIsNullable, out SyntaxNode metadataLambdaMinValue, out SyntaxNode metadataLambdaMaxValue, out SyntaxNode metadataLambdaMinLength, out SyntaxNode metadataLambdaMaxLength, out SyntaxNode metadataLambdaPattern, out int? minLength, SyntaxNode replaceNode)
{
    isRequired = ! edmProperty.Nullable;
    maxLength = MaxLength(edmProperty);
    isNullableMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "IsNullable");
    minValueMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMinValue"); 
    maxValueMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMaxValue");
    minLengthMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMinLength");
    maxLengthMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMaxLength");
    patternMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefinePattern");
    GetValidateMetadata(edmProperty, propertyName, ref isRequired, ref maxLength, isNullableMetadata, minValueMetadata, maxValueMetadata, minLengthMetadata, maxLengthMetadata, patternMetadata, out metadataLambdaIsNullable, out metadataLambdaMinValue, out metadataLambdaMaxValue, out metadataLambdaMinLength, out metadataLambdaMaxLength, out metadataLambdaPattern, out minLength, replaceNode);
}

void GetValidateMetadata(EdmProperty edmProperty, string propertyName, ref bool isRequired, ref int? maxLength, WAQSMetadata isNullableMetadata, WAQSMetadata minValueMetadata, WAQSMetadata maxValueMetadata, WAQSMetadata minLengthMetadata, WAQSMetadata maxLengthMetadata, WAQSMetadata patternMetadata, out SyntaxNode metadataLambdaIsNullable, out SyntaxNode metadataLambdaMinValue, out SyntaxNode metadataLambdaMaxValue, out SyntaxNode metadataLambdaMinLength, out SyntaxNode metadataLambdaMaxLength, out SyntaxNode metadataLambdaPattern, out int? minLength, SyntaxNode replaceNode = null)
{
    if (replaceNode == null)
        replaceNode = SyntaxFactory.ThisExpression();
    metadataLambdaIsNullable = null;
    if (isRequired || isNullableMetadata != null)
    {
        if (isNullableMetadata != null)
        {
            if (isNullableMetadata.ConstantExpression != null)
            {
                if (! bool.Parse(isNullableMetadata.ConstantExpression.ToString()))
                    isRequired = true;
            }
            else
                metadataLambdaIsNullable = GetTransformedLambda(isNullableMetadata, replaceNode);
        }
    }
    metadataLambdaMinValue = null;
    if (minValueMetadata != null && minValueMetadata != null && minValueMetadata.ConstantExpression == null)
        metadataLambdaMinValue = GetTransformedLambda(minValueMetadata, replaceNode);
    metadataLambdaMaxValue = null;
    if (maxValueMetadata != null && maxValueMetadata != null && maxValueMetadata.ConstantExpression == null)
        metadataLambdaMaxValue = GetTransformedLambda(maxValueMetadata, replaceNode);
    metadataLambdaMinLength = null;
    minLength = null;
    if (minLengthMetadata != null)
    {
        if (minLengthMetadata.ConstantExpression != null)
            minLength = int.Parse(minLengthMetadata.ConstantExpression.ToString());
        else
            metadataLambdaMinLength = GetTransformedLambda(minLengthMetadata, replaceNode);
    }
    metadataLambdaMaxLength = null;
    if (maxLength.HasValue || maxLengthMetadata != null)
    {
        if (maxLengthMetadata != null)
        {
            if (maxLengthMetadata.ConstantExpression != null)
            {
                int maxLengthMetadataValue = int.Parse(maxLengthMetadata.ConstantExpression.ToString());
                if (! maxLength.HasValue || maxLengthMetadataValue < maxLength.Value)
                    maxLength = maxLengthMetadataValue;
            }
            else
                metadataLambdaMaxLength = GetTransformedLambda(maxLengthMetadata, replaceNode);
        }
    }
    metadataLambdaPattern = null;
    if (patternMetadata != null && patternMetadata != null && patternMetadata.ConstantExpression == null)
        metadataLambdaPattern = GetTransformedLambda(patternMetadata, replaceNode);
}

public void WriteValidateMethods(EntityType entityType, EdmProperty edmProperty, CodeGenerationTools code, IEnumerable<WAQSMetadata> metadata)
{
    string propertyName = code.Escape(edmProperty);
    bool isRequired = ! edmProperty.Nullable && (edmProperty.TypeUsage.ToString() == "Edm.String" || edmProperty.TypeUsage.ToString() == "Edm.Binary");
    var isNullableMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "IsNullable");
    var minValueMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMinValue");
    var maxValueMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMaxValue");
    var minLengthMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMinLength");
    var maxLengthMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefineMaxLength");
    var patternMetadata = metadata.FirstOrDefault(m => m.Property == propertyName && m.MethodName == "DefinePattern");
    int? maxLength = maxLengthMetadata == null ? (int?)null : MaxLength(edmProperty);
    var baseMetadata = new List<WAQSMetadata>();
    EntityType entityTypeLoop = entityType;
    while ((entityTypeLoop = (EntityType)entityTypeLoop.BaseType) != null)
    {
        List<WAQSMetadata> entityTypeLoopMetadata;
        if (_specificationsElements.Metadata.TryGetValue(code.Escape(entityTypeLoop), out entityTypeLoopMetadata))
            baseMetadata.AddRange(entityTypeLoopMetadata);
    }
    WriteValidateMethods(edmProperty, propertyName, code, isRequired, maxLength, isNullableMetadata, minValueMetadata, maxValueMetadata, minLengthMetadata, maxLengthMetadata, patternMetadata, m => baseMetadata.Any(m2 => m2.Property == m.Property && m2.MethodName == m.MethodName));		
}

public void WriteValidateMethods(EdmProperty edmProperty, string propertyName, CodeGenerationTools code, bool isRequired, int? maxLength, WAQSMetadata isNullableMetadata, WAQSMetadata minValueMetadata, WAQSMetadata maxValueMetadata, WAQSMetadata minLengthMetadata, WAQSMetadata maxLengthMetadata, WAQSMetadata patternMetadata, Func<WAQSMetadata, bool> @override = null)
{
    SyntaxNode metadataLambdaIsNullable, metadataLambdaMinValue, metadataLambdaMaxValue, metadataLambdaMinLength, metadataLambdaMaxLength, metadataLambdaPattern;
    int? minLength;
    GetValidateMetadata(edmProperty, propertyName, ref isRequired, ref maxLength, isNullableMetadata, minValueMetadata, maxValueMetadata, minLengthMetadata, maxLengthMetadata, patternMetadata, out metadataLambdaIsNullable, out metadataLambdaMinValue, out metadataLambdaMaxValue, out metadataLambdaMinLength, out metadataLambdaMaxLength, out metadataLambdaPattern, out minLength);	

    string propertyTypeName = code.Escape(edmProperty.TypeUsage);
    if (isRequired || isNullableMetadata != null)
    {
        if (isRequired || metadataLambdaIsNullable != null)
            WriteValidateMethod(propertyTypeName, () => 
                {
#>
        var errorInfo = <#=metadataLambdaIsNullable == null ? "" : metadataLambdaIsNullable.NormalizeWhitespace().ToString() + " ? (ErrorInfo)null : "#><#+
                    switch (edmProperty.TypeUsage.ToString())
                    {
                        case "Edm.String":
#>Validators.ValidateRequiredStringProperty(value, () => <#=propertyName#>, <#=dataErrorInfoTypeName#>)<#+
                            break;
                        case "Edm.Binary":
#>Validators.ValidateRequiredObjectProperty(value, () => <#=propertyName#>, <#=dataErrorInfoTypeName#>)<#+
                            break;
                        case "Edm.Boolean":
                        case "Edm.Byte":
                        case "Edm.DateTime":
                        case "Edm.DateTimeOffset":
                        case "Edm.Time":
                        case "Edm.Decimal":
                        case "Edm.Double":
                        case "Edm.Single":
                        case "Edm.Guid":
                        case "Edm.Int16":
                        case "Edm.Int32":
                        case "Edm.Int64":
                        case "Edm.SByte":
#>Validators.ValidateRequiredProperty(value, () => <#=propertyName#>, <#=dataErrorInfoTypeName#>)<#+
                            break;
                    }
        #>;
<#+
            }, "Required", propertyName, "Mandatory", (@override == null || isNullableMetadata == null) ? false : @override(isNullableMetadata));
        else
        {
#>
    protected virtual Error Validate<#=propertyName#>Required(<#=code.Escape(edmProperty.TypeUsage)#> value)
    {
        return null;
    }

<#+
        }
    }
    if (minValueMetadata != null)
        WriteValidateMethod(propertyTypeName, () => 
            {
                if (edmProperty.Nullable)
                {
#>
        if (value == null)
            return null;
<#+
                }
                if (metadataLambdaMinValue != null)
                {
#>
        <#=code.Escape(edmProperty.TypeUsage)#><#=edmProperty.Nullable ? "" : "?"#> minValue = <#=metadataLambdaMinValue.NormalizeWhitespace().ToString()#>;
<#+
                }
#>
        var errorInfo = <#=metadataLambdaMinValue == null ? "" : "minValue.HasValue ? "#>Validators.ValidateMinValue(value, <#=metadataLambdaMinValue == null ? minValueMetadata.ConstantExpression.NormalizeWhitespace().ToString() : "minValue.Value"#>, () => <#=propertyName#>, <#=dataErrorInfoTypeName#>)<#=metadataLambdaMinValue == null ? "" : " : null"#>;
<#+
            }, "MinValue", propertyName, @override: @override == null ? false : @override(minValueMetadata));
    if (maxValueMetadata != null)
        WriteValidateMethod(propertyTypeName, () => 
            {
        if (edmProperty.Nullable)
        {
#>
        if (value == null)
            return null;
<#+
        }
        if (metadataLambdaMaxValue != null)
        {
#>
        <#=code.Escape(edmProperty.TypeUsage)#><#=edmProperty.Nullable ? "" : "?"#> maxValue = <#=metadataLambdaMaxValue.NormalizeWhitespace().ToString()#>;
<#+
        }
#>
        var errorInfo = <#=metadataLambdaMaxValue == null ? "" : "maxValue.HasValue ? "#>Validators.ValidateMaxValue(value, <#=metadataLambdaMaxValue == null ? maxValueMetadata.ConstantExpression.NormalizeWhitespace().ToString() : "maxValue.Value"#>, () => <#=propertyName#>, <#=dataErrorInfoTypeName#>)<#=metadataLambdaMaxValue == null ? "" : " : null"#>;
<#+
            }, "MaxValue", propertyName, @override: @override == null ? false : @override(maxValueMetadata));
    if (minLengthMetadata != null)
        WriteValidateMethod(propertyTypeName, () => 
            {
#>
        if (value == null)
            return null;
<#+
        if (metadataLambdaMinLength != null)
        {
#>
        int? minLength = <#=metadataLambdaMinLength.NormalizeWhitespace().ToString()#>;
<#+
        }
#>
        var errorInfo = <#=metadataLambdaMinLength == null ? "" : "minLength.HasValue ? "#>Validators.Validate<#=edmProperty.TypeUsage.ToString().Substring(4)#>MinLength(value, <#=metadataLambdaMinLength == null ? minLength.ToString() : "minLength.Value"#>, () => <#=propertyName#>, <#=dataErrorInfoTypeName#>)<#=metadataLambdaMinLength == null ? "" : " : null"#>;
<#+
            }, "MinLength", propertyName, @override: @override == null ? false : @override(minLengthMetadata));
    if (maxLength.HasValue || maxLengthMetadata != null)
        WriteValidateMethod(propertyTypeName, () => 
            {
#>
        if (value == null)
            return null;
<#+
        if (metadataLambdaMaxLength != null)
        {
#>
        int? maxLength = <#=metadataLambdaMaxLength.NormalizeWhitespace().ToString()#>;
<#+
        }
#>
        var errorInfo = <#=maxLength.HasValue ? "" : "maxLength.HasValue ? "#>Validators.Validate<#=edmProperty.TypeUsage.ToString().Substring(4)#>MaxLength(value, <#=metadataLambdaMaxLength == null ? maxLength.ToString() : maxLength.HasValue ? string.Format("maxLength.HasValue ? Math.Min({0}, maxLength.Value) : {0}", maxLength) : "maxLength.Value"#>, () => <#=propertyName#>, <#=dataErrorInfoTypeName#>)<#=maxLength.HasValue ? "" : " : null"#>;
<#+
            }, "MaxLength", propertyName, @override: (@override == null || maxLengthMetadata == null) ? false : @override(maxLengthMetadata));
    if (patternMetadata != null)
        WriteValidateMethod(propertyTypeName, () => 
            {
#>
        if (value == null)
            return null;
<#+
        if (metadataLambdaPattern != null)
        {
#>
        string pattern = <#=metadataLambdaPattern.NormalizeWhitespace().ToString()#>;
<#+
        }
#>
        var errorInfo = <#=metadataLambdaPattern == null ? "" : "pattern != null ? "#>Validators.ValidatePattern(value, <#=metadataLambdaPattern == null ? patternMetadata.ConstantExpression.NormalizeWhitespace().ToString() : "pattern"#>, () => <#=propertyName#>, <#=dataErrorInfoTypeName#>)<#=metadataLambdaPattern == null ? "" : " : null"#>;
<#+
            }, "Pattern", propertyName, @override: @override == null ? false : @override(patternMetadata));
}

void WriteValidateMethod(string propertyTypeName, Action writeGetError, string key, string propertyName, string errorType = "Error", bool @override = false)
{
#>
    protected <#=@override ? "override" : "virtual"#> Error Validate<#=propertyName#><#=key#>(<#=propertyTypeName#> value)
    {
<#+
    writeGetError();
#>
        var error = Errors.<#=propertyName#>.FirstOrDefault(e => e.Key == "<#=propertyName#><#=key#>");
        if (errorInfo == null)
        {
            if (error != null)
                Errors.<#=propertyName#>.Remove(error);
            return null;
        }
        if (error == null)
            Errors.<#=propertyName#>.Add(error = new MetadataError { Criticity = Criticity.<#=errorType#>, Key = "<#=propertyName#><#=key#>", Message = errorInfo.Message, ErrorInfo = errorInfo });
        return error;
    }

<#+
}

SyntaxNode GetTransformedLambda(WAQSMetadata metadata, SyntaxNode replaceNode)
{
    return GetTransformedLambda(metadata, _ => replaceNode);
}

SyntaxNode GetTransformedLambda(WAQSMetadata metadata, Func<SyntaxNode, SyntaxNode> replaceNode)
{
    return new SpecificationsRewriter((n, _) => 
                {
                    var identifier = n as IdentifierNameSyntax;
                    if (identifier != null && identifier.Identifier.ValueText == metadata.LambdaExpression.Parameter.Identifier.ValueText)
                        return replaceNode(identifier);
                    return n;
                }).Visit(metadata.LambdaExpression.Body);
}
}

class SpecificationGetMethodBodyRewriterClientEntity : SpecificationGetMethodBodyRewriterClient
{
    private string _serverFxDALInterfacesNamespace;
    private string _propertyName;
    private TypeSyntax _returnType;

    public SpecificationGetMethodBodyRewriterClientEntity(SpecificationsElements specificationsElements, MethodDeclarationSyntax method, ISemanticModel semanticModel, IEnumerable<TypeSymbol> dtoTypes, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, string parameterName, string propertyName, TypeSyntax returnType, Dictionary<string, string> namespacesReplacement)
        : base(specificationsElements, method, semanticModel, dtoTypes, serverFxServiceInterfacesNamespace, parameterName, namespacesReplacement)
    {
        _serverFxDALInterfacesNamespace = serverFxDALInterfacesNamespace;
        _propertyName = propertyName;
        _returnType = returnType;
    }

    public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        if (node == null)
            return null;
        if (SpecificationsElements.IsApplicableOnClient(node))
        {
            var nodeBody = node.Body;
            return node.ReplaceNode(nodeBody,
                SyntaxFactory.Block(
                    SyntaxFactory.TryStatement(
                        SyntaxFactory.Block(
                            SyntaxFactory.List<StatementSyntax>(
                                new StatementSyntax[] { 
                                    SyntaxFactory.IfStatement(
                                        SyntaxFactory.ParseExpression("Specifications != null && Specifications.Has" + _propertyName),
                                        SyntaxFactory.ReturnStatement(
                                            SyntaxFactory.ParseExpression("Specifications." + _propertyName))) }
                                .Union(SpecificationsElements.IsApplicableOnClient(node) && ! SpecificationsElements.AbstractMethods.Contains(node) ? 
                                    nodeBody.Statements.Select(s => (StatementSyntax)Visit(s)) : 
                                    new [] { 
                                        SyntaxFactory.ReturnStatement(
                                            SyntaxFactory.DefaultExpression(_returnType)) }))),
                        SyntaxFactory.List(
                            new[]
                            {
                                SyntaxFactory.CatchClause()
                                    .WithDeclaration(
                                        SyntaxFactory.CatchDeclaration(
                                            SyntaxFactory.ParseTypeName("System.NullReferenceException")))
                                    .WithBlock(
                                        SyntaxFactory.Block(
                                            SyntaxFactory.ReturnStatement(
                                                SyntaxFactory.DefaultExpression(_returnType)))), 
                                SyntaxFactory.CatchClause()
                                    .WithDeclaration(
                                        SyntaxFactory.CatchDeclaration(
                                            SyntaxFactory.ParseTypeName("System.InvalidOperationException")))
                                    .WithBlock(
                                        SyntaxFactory.Block(
                                            SyntaxFactory.ReturnStatement(
                                                SyntaxFactory.DefaultExpression(_returnType))))
                            }),
                        null)));
        }
        return node.ReplaceNode(node.Body,
            SyntaxFactory.Block(
                SyntaxFactory.ReturnStatement(
                    SyntaxFactory.ConditionalExpression(
                        SyntaxFactory.ParseExpression("Specifications != null && Specifications.Has" + _propertyName),
                        SyntaxFactory.ParseExpression("Specifications." + _propertyName),
                        SyntaxFactory.DefaultExpression(_returnType)))));
    }
}

public static List<MethodDeclarationSyntax> GetNonOverridenGetMethods(SpecificationsElements specificationsElements, List<MethodDeclarationSyntax> getMethods)
{
    return getMethods == null ? null : getMethods.Where(m => ! specificationsElements.OverrideMethods.Contains(m)).ToList();
}

public static bool IsEntityWithErrors(IEnumerable<EdmProperty> properties, IEnumerable<NavigationProperty> navigationProperties, List<MethodDeclarationSyntax> getMethods)
{
    return properties.Any() || navigationProperties.Any(np => np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One) || (getMethods != null && getMethods.Count != 0);
}

class ClientTestNull : SpecificationsTestNull
{
    public ClientTestNull(ISemanticModel semanticModel, string classPath, SpecificationsElements specificationsElements)
        : base(semanticModel, classPath, specificationsElements)
    {
    }

    protected override void Init()
    {
        base.Init();
        AddAlreadyTestedNullableExpressions("Specifications");
    }

    public override SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
        List<MethodDeclarationSyntax> getMethods;
        if (SpecificationsElements.GetMethods.TryGetValue(ClassName, out getMethods) && getMethods.Any(m => m.Identifier.ValueText == "Get" + node.Identifier.ValueText))
        {
            var newProperty = (PropertyDeclarationSyntax)base.VisitPropertyDeclaration(node);
            var getAccessor = node.AccessorList.Accessors.First(a => GetKind(a) == SyntaxKind.GetAccessorDeclaration);
            var tryStatement = getAccessor.Body.Statements.First() as TryStatementSyntax;
            if (tryStatement == null)
                return node;
            var newGetAccessor = newProperty.AccessorList.Accessors.First(a => GetKind(a) == SyntaxKind.GetAccessorDeclaration);
            var newTryStatementBlock = ((TryStatementSyntax)newGetAccessor.Body.Statements.First()).Block;
            var setAccessor = node.AccessorList.Accessors.First(a => GetKind(a) == SyntaxKind.SetAccessorDeclaration);
            return node.WithAccessorList(
                SyntaxFactory.AccessorList(
                    SyntaxFactory.List(
                        new []
                        {
                            SyntaxFactory.AccessorDeclaration(
                                SyntaxKind.GetAccessorDeclaration, 
                                SyntaxFactory.Block(
                                    newTryStatementBlock.Statements)), 
                            setAccessor 
                        })));

        }
        return node;
    }
}
#>
