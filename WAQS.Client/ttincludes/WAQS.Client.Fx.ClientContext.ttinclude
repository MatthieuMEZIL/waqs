<#@ template language="C#" debug="false" hostspecific="true"#>
<#@ output extension=".txt"#>
<#+
// Copyright (c) Matthieu MEZIL.  All rights reserved.
void WriteClientFxClientContext(string clientFxComponentModelNamespace, string clientFxEntitiesTrackingNamespace, string clientFxClientContextInterfacesNamespace, string expressionVisitorNamespace, string namespaceName = null, bool useAsyncPrefix = true)
{
    string asyncSuffix = useAsyncPrefix ? "Async" : "";
    CodeGenerationTools code = new CodeGenerationTools(this);
    MetadataLoader loader = new MetadataLoader(this);
    CodeRegion region = new CodeRegion(this, 1);
    if (namespaceName == null)
        namespaceName = code.VsNamespaceSuggestion();

    EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);

    string expressionNamespace = clientFxClientContextInterfacesNamespace + ".ExpressionSerialization";

    fileManager.StartNewFile("ClientEntitySetBase.cs");
    WriteHeader(namespaceName, code, "System", "System.Collections", "System.Collections.Generic", "System.Collections.Specialized", "System.Linq", clientFxEntitiesTrackingNamespace, expressionNamespace, clientFxClientContextInterfacesNamespace);
#>
public abstract class ClientEntitySetBase<ClientContext> : IClientEntitySet<ClientContext>, IDisposable, INotifyCollectionChanged
    where ClientContext : class, IClientContext
{
    public ClientEntitySetBase(string entitySetName, ClientContext context, IList entities, HashSet<IObjectWithChangeTracker> hashSet, Func<IObjectWithChangeTracker, object> getEntityKey)
    {
        EntitySetName = entitySetName;
        Context = context;
        Entities = entities;
        HashSet = hashSet;
        GetEntityKey = getEntityKey;
    }
                                        
    ~ClientEntitySetBase()
    {
        Dispose(false);
    }
        
    protected internal virtual bool EntitiesContains(IObjectWithChangeTracker entity)
    {
        return HashSet.Contains(entity);
    }
        
    protected virtual void EntitiesAdd(IObjectWithChangeTracker entity)
    {
        HashSet.Add(entity);
        Entities.Add(entity);
    }
        
    protected virtual void EntitiesRemove(IObjectWithChangeTracker entity)
    {
        HashSet.Remove(entity);
        Entities.Remove(entity);
    }
                                    
    public string EntitySetName { get; private set; }
                                    
    private SerializableExpression _expression;
    protected internal virtual SerializableExpression Expression 
    { 
        get { return _expression ?? (_expression = new SerializableEntitySetExpression(EntitySetName));}
    }
    SerializableExpression IClientEntitySet.Expression
    {
        get { return Expression; }
    }
                                    
    public ClientContext Context { get; private set; }
    IClientContext IClientEntitySet.Context
    {
        get { return Context; }
    }
    private Dictionary<object, IObjectWithChangeTracker> _entitiesDico;
    private Dictionary<object, IObjectWithChangeTracker> EntitiesDico 
    {
        get { return _entitiesDico ?? (_entitiesDico = new Dictionary<object, IObjectWithChangeTracker>()); }
    }
    protected internal IList Entities { get; private set; }
    protected internal HashSet<IObjectWithChangeTracker> HashSet { get; private set; }
    public Func<IObjectWithChangeTracker, object> GetEntityKey { get; private set; }
    
    protected virtual bool Add(IObjectWithChangeTracker entity, bool checkIfAlreadyExist = true)
    {
        entity.ChangeTracker.ChangeTrackingEnabled = true;
        entity.ChangeTracker.State = ObjectState.Added;
        return AddEntity(entity, checkIfAlreadyExist);
    }
                
    protected virtual bool Attach(IObjectWithChangeTracker entity, bool checkIfAlreadyExist = true)
    {
        entity.ChangeTracker.AcceptChanges();
        entity.ChangeTracker.ChangeTrackingEnabled = true;
        return AddEntity(entity, checkIfAlreadyExist);
    }
                
    protected bool AddEntity(IObjectWithChangeTracker entity, bool checkIfAlreadyExist = true)
    {
        if (checkIfAlreadyExist && EntitiesContains(entity))
                return false;
        bool notifyCollectionChanged = false;        
        var entityKey = GetEntityKey(entity);                                   
        IObjectWithChangeTracker entityInEntitySet;
        if (checkIfAlreadyExist && (entityInEntitySet = Entities.Cast<IObjectWithChangeTracker>().FirstOrDefault(e => e == entity || GetEntityKey(e).Equals(entityKey))) != null && (entityInEntitySet == entity || !(entity.HasTemporaryKey && entity.ChangeTracker.State == ObjectState.Added)))
        {
            if (entityInEntitySet == entity)
                    return false;
            throw new InvalidOperationException("Another entity with the same key already exists in the context");
        }
        else
        {
            EntitiesAdd(entity);            
            notifyCollectionChanged = true;
        }
        entity.StateChanged += EntityStateChanged;
        if (notifyCollectionChanged)
                NotifyCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, entity));
        return true;
    }
        
    protected virtual bool Replace(ref IObjectWithChangeTracker entity)
    {
        var entityKey = GetEntityKey(entity);
        var entityDeleted = Entities.Cast<IObjectWithChangeTracker>().FirstOrDefault(e => (GetEntityKey(e).Equals(entityKey)) && (e.ChangeTracker.State == ObjectState.Deleted));
        if (entityDeleted != null)
            return AttachDeletedEntity(ref entity, entityDeleted);
        return Add(entity);
    }
            
    protected virtual bool AttachDeletedEntity(ref IObjectWithChangeTracker entity, IObjectWithChangeTracker entityDeleted)
    {
        entity = entityDeleted;
        return Attach(entity, true);
    }
                        
    void EntityStateChanged(IObjectWithChangeTracker entity, ObjectState state)
    {
        switch (state)
        {
            case ObjectState.CascadeDeleted:
                RemoveCascade(entity);
                break;
        }
    }
                                        
    protected virtual void Remove(IObjectWithChangeTracker entity)
    {
        if (entity.ChangeTracker.State == ObjectState.Added)
            Detach(entity);
        else
            entity.ChangeTracker.State = ObjectState.Deleted;
        if (EntitiesContains(entity)) 
		{
            NotifyCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, entity));
		}
    }
                                        
    protected virtual void RemoveCascade(IObjectWithChangeTracker entity)
    {
        if (entity.ChangeTracker.State == ObjectState.Added)
            Detach(entity);
        else if (entity.ChangeTracker.State != ObjectState.CascadeDeleted)
        {
            entity.StateChanged -= EntityStateChanged;
            entity.ChangeTracker.State = ObjectState.CascadeDeleted;
            entity.StateChanged += EntityStateChanged;
        }
        if (EntitiesContains(entity)) 
		{
            NotifyCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, entity));
		}
    }
                        
    private int? GetIndex(IObjectWithChangeTracker entity)
    {
        int index = 0;
        foreach (var e in Entities.OfType<IObjectWithChangeTracker>().Where(e => (e.ChangeTracker.State & ObjectState.Deleted) == 0 || e == entity))
        {
            if (e == entity)
                return index;
            index++;
        }
        return null;
    }
                                        
    protected virtual void Detach(IObjectWithChangeTracker entity)
    {
        entity.ChangeTracker.DetachedPreviousState = entity.ChangeTracker.State;       
        entity.StateChanged -= EntityStateChanged;
        bool hasFound = EntitiesContains(entity);
        EntitiesRemove(entity);
        entity.ChangeTracker.AcceptChanges(false);
        entity.ChangeTracker.State = ObjectState.Detached;
        entity.ChangeTracker.ChangeTrackingEnabled = false;
        if (hasFound) 
		{
            NotifyCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, entity));
		}
    }
                                        
    void IClientEntitySet<ClientContext>.Add(IObjectWithChangeTracker entity)
    {
        Add(entity);
    }
            
    public void AddWithoutCheckingIfAlreadyExist(IObjectWithChangeTracker entity)
    {
        Add(entity, false);
    }							
                
    void IClientEntitySet<ClientContext>.Attach(IObjectWithChangeTracker entity)
    {
        Attach(entity);
    }
                
    public void AttachWithoutCheckingIfAlreadyExist(IObjectWithChangeTracker entity)
    {
        Attach(entity, false);
    }
                                        
    void IClientEntitySet<ClientContext>.Remove(IObjectWithChangeTracker entity)
    {
        Remove(entity);
    }
                                        
    void IClientEntitySet<ClientContext>.Detach(IObjectWithChangeTracker entity)
    {
        Detach(entity);
    }
        
    void IClientEntitySet<ClientContext>.Replace(ref IObjectWithChangeTracker entity)
    {
        Replace(ref entity);
    }
                                        
    public bool AttachWithoutChangingState(IObjectWithChangeTracker entity, ObjectState? defaultState = ObjectState.Unchanged)
    {
        if (EntitiesContains(entity))
            return false;
        if (entity.ChangeTracker.State == ObjectState.Detached)
        {
            entity.ChangeTracker.ChangeTrackingEnabled = true;
            if (entity.ChangeTracker.IsAttaching)
            {
                entity.ChangeTracker.State = ObjectState.Unchanged;
                entity.ChangeTracker.IsAttaching = false;
            }
            else
                entity.ChangeTracker.State = defaultState ?? ObjectState.Added;
        }
        AddEntity(entity);
        if (entity.ChangeTracker.State == ObjectState.Added)
            OnAdded(entity);
        else
            OnAttached(entity);
        return true;
    }
    protected virtual void OnAdded(IObjectWithChangeTracker entity)
    {
    }
    protected virtual void OnAttached(IObjectWithChangeTracker entity)
    {
    }
    public virtual int Count
    {
        get
        {
            var enumerator = GetEnumerable().GetEnumerator();
            int value = 0;
            while (enumerator.MoveNext()) value++;
            return value;
        }
    }
                            
    protected IEnumerable<IObjectWithChangeTracker> AllEntities
    {
        get
        {
            if (Entities == null)
                return new IObjectWithChangeTracker[0];
            return Entities.Cast<IObjectWithChangeTracker>();
        }
    }
                                        
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerable().GetEnumerator();
    }
    protected virtual IEnumerable GetEnumerable()
    {
        return Entities.OfType<IObjectWithChangeTracker>().Where(e => (e.ChangeTracker.State & ObjectState.Deleted) == 0);
    }
    protected abstract Type GetEntityType();
                                        
    public event NotifyCollectionChangedEventHandler CollectionChanged;
    protected void NotifyCollectionChanged(NotifyCollectionChangedEventArgs arg)
    {
        if (CollectionChanged != null)
            CollectionChanged(this, arg);
    }
                                        
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
                                        
    protected internal virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            foreach (var entity in AllEntities.ToList())
            {
                entity.ChangeTracker.AcceptChanges(false); 
                entity.ChangeTracker.ChangeTrackingEnabled = false;
                entity.StateChanged -= EntityStateChanged;
                entity.ChangeTracker.ClientContextDispose();
            }
            _entitiesDico = null;
            GetEntityKey = null;
        }
    }
}
<#+
WriteFooter(namespaceName);

fileManager.StartNewFile("ClientEntitySet.cs");
WriteHeader(namespaceName, code, "System", "System.Collections", "System.Collections.Generic", "System.Collections.Specialized", "System.Linq", clientFxEntitiesTrackingNamespace, expressionNamespace, clientFxClientContextInterfacesNamespace);
#>
public class ClientEntitySet<ClientContext, EntityType> : ClientEntitySetBase<ClientContext>, IClientEntitySet<ClientContext, EntityType>, IEnumerable<EntityType>
    where ClientContext : class, IClientContext
    where EntityType : class, IObjectWithChangeTracker
{
    private HashSet<EntityType> _hashSet = new HashSet<EntityType>();
    private List<KeyValuePair<IObjectWithChangeTracker, EventHandler<ObjectStateChangedEventArgs>>> _entitiesStateChanged = new List<KeyValuePair<IObjectWithChangeTracker, EventHandler<ObjectStateChangedEventArgs>>>();
    
    public ClientEntitySet(string entitySetName, ClientContext context, Func<EntityType, object> getEntityKey)
        : base(entitySetName, context, new List<EntityType>(), new HashSet<IObjectWithChangeTracker>(), e => getEntityKey((EntityType)e))
    {
    }

    protected ClientEntitySet(string entitySetName, ClientContext context, IList entities, HashSet<IObjectWithChangeTracker> hashSet, Func<IObjectWithChangeTracker, object> getEntityKey)
        : base(entitySetName, context, entities, hashSet, getEntityKey)
    {
    }
    
    public new IEnumerable<EntityType> AllEntities
    {
        get { return base.AllEntities.OfType<EntityType>(); }
    }
    
    public virtual void Add(EntityType entity)
    {
        if (base.Add(entity))
            OnEntityAdded(entity);
    }
    
    public virtual void AddWithoutCheckingIfAlreadyExist(EntityType entity)
    {
        if (base.Add(entity, false))
            OnEntityAdded(entity);
    }
    
    public virtual void Attach(EntityType entity)
    {
        if (base.Attach(entity))
            OnEntityAttached(entity);
    }
    
    public virtual void AttachWithoutCheckingIfAlreadyExist(EntityType entity)
    {
        if (base.Attach(entity, false))
            OnEntityAttached(entity);
    }
    
    public virtual void Remove(EntityType entity)
    {
        OnEntityRemoving(entity);
        base.Remove(entity);
        OnEntityRemoved(entity);
    }
    
    public virtual void RemoveCascade(EntityType entity)
    {
        OnEntityRemoving(entity);
        base.RemoveCascade(entity);
        OnEntityRemoved(entity);
    }
    
    public virtual void Detach(EntityType entity)
    {
        base.Detach(entity);
    }
    
    protected override void EntitiesAdd(IObjectWithChangeTracker entity)
    {
        base.EntitiesAdd(entity);
        EventHandler<ObjectStateChangedEventArgs> entityChangeTrackerObjectStateChanged = null;
        entityChangeTrackerObjectStateChanged = (_, e) =>
            {
                if (e.NewState == ObjectState.Detached)
                {
                    entity.ChangeTracker.ObjectStateChanged -= entityChangeTrackerObjectStateChanged;
                    var entityStateChanged = _entitiesStateChanged.FirstOrDefault(esc => esc.Key == e);
                    if (entityStateChanged.Key != null)
                        _entitiesStateChanged.Remove(entityStateChanged);
                    OnEntityDetached((EntityType)entity);
                }
            };
        entity.ChangeTracker.ObjectStateChanged += entityChangeTrackerObjectStateChanged;
        _entitiesStateChanged.Add(new KeyValuePair<IObjectWithChangeTracker, EventHandler<ObjectStateChangedEventArgs>>(entity, entityChangeTrackerObjectStateChanged));
    }
    
    public bool Contains(EntityType entity)
    {
        return EntitiesContains(entity);
    }
    
    public virtual void Replace(ref EntityType entity)
    {            
        IObjectWithChangeTracker owct = entity;
        if (base.Replace(ref owct))
        {
            if (owct == entity)
                OnEntityAdded(entity);
            else
                OnEntityAttached((EntityType)owct);
        }

        entity = (EntityType)owct;
    }
    
    protected override bool AttachDeletedEntity(ref IObjectWithChangeTracker entity, IObjectWithChangeTracker entityDeleted)
    {
        var originalEntity = entity;
        var result = base.AttachDeletedEntity(ref entity, entityDeleted);
        if (result)
            OnEntityReplaced((EntityType)entityDeleted, (EntityType)originalEntity);
        else
            OnEntityAdded((EntityType)entityDeleted);
        return result;
    }
    
    protected virtual void OnEntityAdded(EntityType entity)
    {
        if (EntityAdded != null)
            EntityAdded(entity);
    }
    public event Action<EntityType> EntityAdded;
    protected override void OnAdded(IObjectWithChangeTracker entity)
    {
        base.OnAdded(entity);
        OnEntityAdded((EntityType)entity);
    }
    
    protected virtual void OnEntityAttached(EntityType entity)
    {
        var isInitializingRelationships = entity.IsInitializingRelationships;
        entity.IsInitializingRelationships = true;
        if (EntityAttached != null)
            EntityAttached(entity);
        entity.IsInitializingRelationships = isInitializingRelationships;
    }
    public event Action<EntityType> EntityAttached;
        
    protected override void OnAttached(IObjectWithChangeTracker entity)
    {
        base.OnAttached(entity);
        OnEntityAttached((EntityType)entity);
    }
    
    protected virtual void OnEntityRemoving(EntityType entity)
    {
        if (EntityRemoving != null)
            EntityRemoving(entity);
    }
    public event Action<EntityType> EntityRemoving;
    
    protected virtual void OnEntityRemoved(EntityType entity)
    {
        if (EntityRemoved != null)
            EntityRemoved(entity);
    }
    public event Action<EntityType> EntityRemoved;
    
    protected virtual void OnEntityDetached(EntityType entity)
    {
        if (EntityDetached != null)
            EntityDetached(entity);
    }
    public event Action<EntityType> EntityDetached;
    
    protected virtual void OnEntityReplaced(EntityType entityRemoved, EntityType entity)
    {
        if (EntityReplaced != null)
            EntityReplaced(entityRemoved, entity);
    }
    public event Action<EntityType, EntityType> EntityReplaced;
    
    public virtual EntityType this[int index]
    {
        get { return (EntityType)Entities[index]; }
    }
    
    protected new virtual IEnumerable<EntityType> GetEnumerable()
    {
        return base.GetEnumerable().OfType<EntityType>();
    }
    
    public IEnumerator<EntityType> GetEnumerator()
    {
        return GetEnumerable().Cast<EntityType>().GetEnumerator();
    }
    
    protected override Type GetEntityType()
    {
        return typeof(EntityType);
    }

    protected internal override void Dispose(bool disposing)
    {
        if (disposing)
        {
            foreach (var item in _entitiesStateChanged)
                item.Key.ChangeTracker.ObjectStateChanged -= item.Value;
            _entitiesStateChanged.Clear();
        }
        base.Dispose(disposing);
    }
}
<#+
WriteFooter(namespaceName);

fileManager.StartNewFile("ClientSubEntitySet.cs");
WriteHeader(namespaceName, code, "System", "System.Collections", "System.Collections.Generic", "System.Collections.Specialized", "System.Linq", clientFxEntitiesTrackingNamespace, expressionNamespace, clientFxClientContextInterfacesNamespace);
#>
public class ClientSubEntitySet<ClientContext, EntityType, EntityTypeBase> : ClientEntitySet<ClientContext, EntityType>, IEnumerable<EntityType>, IDisposable
    where ClientContext : class, IClientContext
    where EntityTypeBase : class, IObjectWithChangeTracker
    where EntityType : class, EntityTypeBase
{
    private ClientEntitySet<ClientContext, EntityTypeBase> _entitySet;
            
    public ClientSubEntitySet(ClientEntitySet<ClientContext, EntityTypeBase> entitySet)
        : base(entitySet.EntitySetName, entitySet.Context, entitySet.Entities, entitySet.HashSet, e => entitySet.GetEntityKey(e))
    {
        _entitySet = entitySet;
        _entitySet.CollectionChanged += EntitySetCollectionChanged;
        _entitySet.EntityRemoving += EntitySetEntityRemoving;
    }
            
    private SerializableExpression _expression;
    protected internal override SerializableExpression Expression 
    { 
        get { return _expression ?? (_expression = new SerializableMethodCallExpression(null, new[] { base.Expression }, typeof(Queryable).GetMethod("OfType").MakeGenericMethod(typeof(EntityType)))); }
    }
            
    private void EntitySetCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
    {
        NotifyCollectionChanged(e);
    }
    
    private void EntitySetEntityRemoving(EntityTypeBase entity)
    {
        var entityAsEntityType = entity as EntityType;
        if (entityAsEntityType != null)
            OnEntityRemoving(entityAsEntityType);
    }
            
    public override void Add(EntityType entity)
    {
        _entitySet.Add(entity);
        OnEntityAdded(entity);
    }
            
    public override void Attach(EntityType entity)
    {
        _entitySet.Attach(entity);
        OnEntityAttached(entity);
    }
            
    public override void AttachWithoutCheckingIfAlreadyExist(EntityType entity)
    {
        _entitySet.Attach(entity);
        OnEntityAttached(entity);
    }
            
    public override void Remove(EntityType entity)
    {
        _entitySet.Remove(entity);
        OnEntityRemoved(entity);
    }
            
    public override void Detach(EntityType entity)
    {
        _entitySet.Detach(entity);
        OnEntityDetached(entity);
    }
            
    public override EntityType this[int index]
    {
        get
        {
            return GetEnumerable().ElementAt(index);
        }
    }
            
    public override int Count
    {
        get
        {
            return GetEnumerable().Count();
        }
    }
            
    protected override IEnumerable<EntityType> GetEnumerable()
    {
        return _entitySet.OfType<EntityType>();
    }
            
    IEnumerator<EntityType> IEnumerable<EntityType>.GetEnumerator()
    {
        return GetEnumerable().GetEnumerator();
    }
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerable().GetEnumerator();
    }
            
    protected internal override void Dispose(bool disposing)
    {
        if (disposing)
        {
            _entitySet.CollectionChanged -= EntitySetCollectionChanged;
            _entitySet.EntityRemoving -= EntitySetEntityRemoving;
            _entitySet = null;
        }
        base.Dispose(disposing);
    }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("ExpressionExtension.cs");
    WriteHeader(namespaceName + ".ExpressionSerialization", code, "System", "System.Linq.Expressions");
#>
public static class ExpressionExtension
{
    public static Expression ReplaceExpression(this Expression expression, Expression source, Expression replace)
    {
        return ReplaceExpression(expression, e => e == source ? replace : e);
    }
                    
    public static Expression ReplaceExpression(this Expression expression, Func<Expression, Expression> replace)
    {
        return new ExpressionReplaceRewriter { ReplaceExpressionFunc = replace }.Visit(expression);
    }
                
    public static Expression ReplaceParameter(this Expression expression, ParameterExpression parameter, Expression replace)
    {
        return ReplaceParameter(expression, n => n == parameter ? replace : n);
    }
                
    public static Expression ReplaceParameter(this Expression expression, Func<ParameterExpression, Expression> replace)
    {
        return new ExpressionReplaceRewriter { ReplaceParameterFunc = replace }.Visit(expression);
    }
                
    public static Expression ReplaceBodyParameter(this LambdaExpression expression, Expression replace)
    {
        return ReplaceParameter(expression.Body, n => n == expression.Parameters[0] ? replace : n);
    }
                
    public static Expression ReplaceMethodCall(this Expression expression, MethodCallExpression methodCall, Expression replace)
    {
        return ReplaceMethodCall(expression, n => n == methodCall ? replace : n);
    }
                
    public static Expression ReplaceMethodCall(this Expression expression, Func<MethodCallExpression, Expression> replace)
    {
        return new ExpressionReplaceRewriter { ReplaceMethodCallFunc = replace }.Visit(expression);
    }
            
    public static Expression ReplaceConstant(this Expression expression, ConstantExpression constant, Expression replace)
    {
        return ReplaceConstant(expression, n => n == constant ? replace : n);
    }
            
    public static Expression ReplaceConstant(this Expression expression, Func<ConstantExpression, Expression> replace)
    {
        return new ExpressionReplaceRewriter { ReplaceConstantFunc = replace }.Visit(expression);
    }
        
    public static Expression ReplaceInvocation(this Expression expression, InvocationExpression invocation, Expression replace)
    {
        return ReplaceInvocation(expression, n => n == invocation ? replace : n);
    }
        
    public static Expression ReplaceInvocation(this Expression expression, Func<InvocationExpression, Expression> replace)
    {
        return new ExpressionReplaceRewriter { ReplaceInvocationFunc = replace }.Visit(expression);
    }
        
    public static Expression ReplaceBinary(this Expression expression, BinaryExpression invocation, Expression replace)
    {
        return ReplaceBinary(expression, n => n == invocation ? replace : n);
    }
        
    public static Expression ReplaceBinary(this Expression expression, Func<BinaryExpression, Expression> replace)
    {
        return new ExpressionReplaceRewriter { ReplaceBinaryFunc = replace }.Visit(expression);
    }
    
    public static Expression ReplaceMember(this Expression expression, MemberExpression invocation, Expression replace)
    {
        return ReplaceMember(expression, n => n == invocation ? replace : n);
    }
    
    public static Expression ReplaceMember(this Expression expression, Func<MemberExpression, Expression> replace)
    {
        return new ExpressionReplaceRewriter { ReplaceMemberFunc = replace }.Visit(expression);
    }
                
    public class ExpressionReplaceRewriter : ExpressionVisitor
    {
        public Func<Expression, Expression> ReplaceExpressionFunc { get; set; }
        public override Expression Visit(Expression node)
        {
            if (ReplaceExpressionFunc != null)
            {
                var value = ReplaceExpressionFunc(node);
                if (value != node)
                    return value;
            }
            return base.Visit(node);
        }
                
        public Func<ParameterExpression, Expression> ReplaceParameterFunc { get; set; }
        protected override Expression VisitParameter(ParameterExpression node)
        {
            if (ReplaceParameterFunc != null)
            {
                var value = ReplaceParameterFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitParameter(node);
        }
                
        public Func<MethodCallExpression, Expression> ReplaceMethodCallFunc { get; set; }
        protected override Expression VisitMethodCall(MethodCallExpression node)
        {
            if (ReplaceMethodCallFunc != null)
            {
                var value = ReplaceMethodCallFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitMethodCall(node);
        }
            
        public Func<ConstantExpression, Expression> ReplaceConstantFunc { get; set; }
        protected override Expression VisitConstant(ConstantExpression node)
        {
            if (ReplaceConstantFunc != null)
            {
                var value = ReplaceConstantFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitConstant(node);
        }
        
        public Func<InvocationExpression, Expression> ReplaceInvocationFunc { get; set; }
        protected override Expression VisitInvocation(InvocationExpression node)
        {
            if (ReplaceInvocationFunc != null)
            {
                var value = ReplaceInvocationFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitInvocation(node);
        }
        
        public Func<BinaryExpression, Expression> ReplaceBinaryFunc { get; set; }
        protected override Expression VisitBinary(BinaryExpression node)
        {
            if (ReplaceBinaryFunc != null)
            {
                var value = ReplaceBinaryFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitBinary(node);
        }
    
        public Func<MemberExpression, Expression> ReplaceMemberFunc { get; set; }
        protected override Expression VisitMember(MemberExpression node)
        {
            if (ReplaceMemberFunc != null)
            {
                var value = ReplaceMemberFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitMember(node);
        }
    }
}
<#+
WriteFooter(namespaceName + ".ExpressionSerialization");

fileManager.StartNewFile("AsyncQueryableExtensions.cs");
WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Linq", "System.Linq.Expressions", "System.Reflection", "System.Threading.Tasks", expressionNamespace, namespaceName + ".ExpressionSerialization", clientFxEntitiesTrackingNamespace, clientFxClientContextInterfacesNamespace);
#>
public static class AsyncQueryableExtensions
{
    public static Task<IEnumerable<T>> Execute<#=asyncSuffix#><T>(this IAsyncQueryable<T> query, MergeOption? mergeOption = null)
    {
        return query.Context.ExecuteQuery<#=asyncSuffix#>(query, mergeOption);
    }
    public static Task<T> Execute<#=asyncSuffix#><T>(this IAsyncQueryableValue<T> query, MergeOption? mergeOption = null)
    {
        return query.Context.ExecuteQuery<#=asyncSuffix#>(query, mergeOption);
    }
        
    public static IAsyncQueryableValue<bool> All<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethod("All").MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<bool> All<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethod("All").MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<bool> Any<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Any" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<bool> Any<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return Any<TSource>(source, serializablePredicateReference.Value);
    }
        
    public static IAsyncQueryableValue<bool> Any<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return Any<TSource>(source, serializablePredicateReference.Value);
    }
        
    public static IAsyncQueryableValue<bool> Any<TSource>(IAsyncQueryable<TSource> source, SerializableExpression serializablePredicate)
    {
        return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicate }, typeof(Queryable).GetMethods().First(m => m.Name == "Any" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<decimal?> Average(this IAsyncQueryable<decimal?> source)
    {
        return Average<decimal?>(source);
    }
    public static IAsyncQueryableValue<decimal> Average(this IAsyncQueryable<decimal> source)
    {
        return Average<decimal>(source);
    }
    public static IAsyncQueryableValue<double?> Average(this IAsyncQueryable<double?> source)
    {
        return Average<double?>(source);
    }
    public static IAsyncQueryableValue<double> Average(this IAsyncQueryable<double> source)
    {
        return Average<double>(source);
    }
    public static IAsyncQueryableValue<float?> Average(this IAsyncQueryable<float?> source)
    {
        return Average<float?>(source);
    }
    public static IAsyncQueryableValue<float> Average(this IAsyncQueryable<float> source)
    {
        return Average<float>(source);
    }
    public static IAsyncQueryableValue<double?> Average(this IAsyncQueryable<int?> source)
    {
        return Average<int?, double?>(source);
    }
    public static IAsyncQueryableValue<double> Average(this IAsyncQueryable<int> source)
    {
        return Average<int, double>(source);
    }
    public static IAsyncQueryableValue<double?> Average(this IAsyncQueryable<long?> source)
    {
        return Average<long?, double?>(source);
    }
    public static IAsyncQueryableValue<double> Average(this IAsyncQueryable<long> source)
    {
        return Average<long, double>(source);
    }
    private static IAsyncQueryableValue<T> Average<T>(this IAsyncQueryable<T> source)
    {
        return Average<T, T>(source);
    }
    private static IAsyncQueryableValue<TResult> Average<TSource, TResult>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Average" && m.GetParameters()[0].ParameterType == typeof(IQueryable<TSource>))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<decimal?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, decimal?>> selector)
    {
        return Average<TSource, decimal?>(source, selector);
    }
    public static IAsyncQueryableValue<decimal> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, decimal>> selector)
    {
        return Average<TSource, decimal>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, double?>> selector)
    {
        return Average<TSource, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, double>> selector)
    {
        return Average<TSource, double>(source, selector);
    }
    public static IAsyncQueryableValue<float?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, float?>> selector)
    {
        return Average<TSource, float?>(source, selector);
    }
    public static IAsyncQueryableValue<float> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, float>> selector)
    {
        return Average<TSource, float>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, int?>> selector)
    {
        return Average<TSource, int?, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, int>> selector)
    {
        return Average<TSource, int, double>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, long?>> selector)
    {
        return Average<TSource, long?, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, long>> selector)
    {
        return Average<TSource, long, double>(source, selector);
    }
    private static IAsyncQueryableValue<T> Average<TSource, T>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, T>> selector)
    {
        return Average<TSource, T, T>(source, selector);
    }
    private static IAsyncQueryableValue<TResult> Average<TSource, T, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, T>> selector)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Average" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.ToString() == string.Format("System.Linq.Expressions.Expression`1[System.Func`2[TSource,{0}]]", typeof(T).ToString())).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<decimal?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<decimal?>>> selector)
    {
        return AverageAsyncQueryable<TSource, decimal?>(source, selector);
    }
    public static IAsyncQueryableValue<decimal> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<decimal>>> selector)
    {
        return AverageAsyncQueryable<TSource, decimal>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<double?>>> selector)
    {
        return AverageAsyncQueryable<TSource, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<double>>> selector)
    {
        return AverageAsyncQueryable<TSource, double>(source, selector);
    }
    public static IAsyncQueryableValue<float?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<float?>>> selector)
    {
        return AverageAsyncQueryable<TSource, float?>(source, selector);
    }
    public static IAsyncQueryableValue<float> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<float>>> selector)
    {
        return AverageAsyncQueryable<TSource, float>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<int?>>> selector)
    {
        return AverageAsyncQueryable<TSource, int?, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<int>>> selector)
    {
        return AverageAsyncQueryable<TSource, int, double>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<long?>>> selector)
    {
        return AverageAsyncQueryable<TSource, long?, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<long>>> selector)
    {
        return AverageAsyncQueryable<TSource, long, double>(source, selector);
    }
    private static IAsyncQueryableValue<T> AverageAsyncQueryable<TSource, T>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<T>>> selector)
    {
        return AverageAsyncQueryable<TSource, T, T>(source, selector);
    }
    private static IAsyncQueryableValue<TResult> AverageAsyncQueryable<TSource, T, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<T>>> selector)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Average" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.ToString() == string.Format("System.Linq.Expressions.Expression`1[System.Func`2[TSource,{0}]]", typeof(T).ToString())).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> Cast<TResult>(this IAsyncQueryable source)
    {
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethod("Cast").MakeGenericMethod(typeof(TResult))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties.Where(p => typeof(TResult).GetProperty(p) != null), source.SelectedProperties.Where(p => typeof(TResult).GetProperty(p) != null));
    }
        
    public static IAsyncQueryableValue<bool> Contains<T>(this IAsyncQueryable<T> source, T value)
    {
        return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, new SerializableConstantExpression(value, typeof(T)) }, typeof(Queryable).GetMethods().First(m => m.Name == "Contains" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<bool> Contains<T>(this IAsyncQueryable<T> source, IAsyncQueryableValue<T> value)
    {
        return new AsyncQueryableValue<bool>(source.Context, Contains<T>(source.Expression, value.Expression), source.ParameterMode);
    }
    public static SerializableExpression Contains<T>(SerializableExpression source, SerializableExpression value)
    {
        return new SerializableMethodCallExpression(null, new[] { source, value }, typeof(Queryable).GetMethods().First(m => m.Name == "Contains" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T)));
    }
        
    public static IAsyncQueryableValue<int> Count<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<int>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Count" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<int> Count<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<int>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Count" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<int> Count<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<int>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Count" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TSource> DefaultIfEmpty<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "DefaultIfEmpty" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TSource> Distinct<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Distinct" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> Except<TSource>(this IAsyncQueryable<TSource> source1, IAsyncQueryable<TSource> source2)
    {
        return new AsyncQueryable<TSource>(source1.Context, new SerializableMethodCallExpression(null, new[] { source1.Expression, source2.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Except" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source1.ParameterMode);
    }
        
    public static IAsyncQueryableValue<TSource> First<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "First" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> First<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "First" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> First<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "First" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> FirstOrDefault<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "FirstOrDefault" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> FirstOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "FirstOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> FirstOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "FirstOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
    {
        var serializableKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
        return new AsyncQueryable<IGrouping<TKey, TSource>>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "GroupBy" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<TKey>>> keySelector)
    {
        var serializableKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
        return new AsyncQueryable<IGrouping<TKey, TSource>>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "GroupBy" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IAsyncQueryable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector)
    {
        var serializableOuterKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableOuterKeySelectorReference, outer.ParameterMode, outer.Context).Visit(outerKeySelector);
        var serializableInnerKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableInnerKeySelectorReference, outer.ParameterMode, outer.Context).Visit(innerKeySelector);
        var serializableResultSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableResultSelectorReference, outer.ParameterMode, outer.Context).Visit(resultSelector);
        return new AsyncQueryable<TResult>(outer.Context, new SerializableMethodCallExpression(null, new[] { outer.Expression, inner.Expression, serializableOuterKeySelectorReference.Value, serializableInnerKeySelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "GroupJoin" && m.GetParameters().Length == 5).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult))), outer.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<int> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<int, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<int>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, int, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<uint> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<uint, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<uint>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, uint, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<short> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<short, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<short>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, short, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ushort> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ushort, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<ushort>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, ushort, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<byte> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<byte, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<byte>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, byte, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<long> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<long, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<long>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, long, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ulong> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ulong, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<ulong>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, ulong, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<decimal> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<decimal, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<decimal>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, decimal, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<double> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<double, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<double>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, double, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<char> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<char, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<char>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, char, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<DateTime> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<DateTime, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<DateTime>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, DateTime, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TimeSpan> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TimeSpan, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TimeSpan>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, TimeSpan, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<int?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<int?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<int?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, int?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<uint?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<uint?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<uint?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, uint?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<short?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<short?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<short?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, short?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ushort?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ushort?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<ushort?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, ushort?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<byte?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<byte?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<byte?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, byte?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<long?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<long?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<long?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, long?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ulong?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ulong?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<ulong?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, ulong?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<decimal?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<decimal?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<decimal?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, decimal?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<double?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<double?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<double?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, double?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<char?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<char?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<char?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, char?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<DateTime?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<DateTime?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<DateTime?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, DateTime?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TimeSpan?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TimeSpan?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TimeSpan?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, TimeSpan?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<string> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<string, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<string>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, string, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    private static IAsyncQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector)
    {
        var serializableOuterKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableOuterKeySelectorReference, outer.ParameterMode, outer.Context).Visit(outerKeySelector);
        var serializableInnerKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableInnerKeySelectorReference, outer.ParameterMode, outer.Context).Visit(innerKeySelector);
        var serializableResultSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableResultSelectorReference, outer.ParameterMode, outer.Context).Visit(resultSelector);
        return new AsyncQueryable<TResult>(outer.Context, new SerializableMethodCallExpression(null, new[] { outer.Expression, outer.ParameterMode == ParameterMode.OnDefinition ? new SerializableConstantExpression(inner, typeof(IEnumerable<TInner>)) : new SerializableConstantExpression((Delegate)(Func<IEnumerable<TInner>>)(() => inner), typeof(IEnumerable<TInner>)), serializableOuterKeySelectorReference.Value, serializableInnerKeySelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "GroupJoin" && m.GetParameters().Length == 5).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult))), outer.ParameterMode);
    }
        
    public static IAsyncQueryable<TSource> Intersect<TSource>(this IAsyncQueryable<TSource> source1, IAsyncQueryable<TSource> source2)
    {
        return new AsyncQueryable<TSource>(source1.Context, new SerializableMethodCallExpression(null, new[] { source1.Expression, source2.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Intersect" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source1.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IAsyncQueryable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector)
    {
        var serializableOuterKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableOuterKeySelectorReference, outer.ParameterMode, outer.Context).Visit(outerKeySelector);
        var serializableInnerKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableInnerKeySelectorReference, outer.ParameterMode, outer.Context).Visit(innerKeySelector);
        var serializableResultSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableResultSelectorReference, outer.ParameterMode, outer.Context).Visit(resultSelector);
        return new AsyncQueryable<TResult>(outer.Context, new SerializableMethodCallExpression(null, new[] { outer.Expression, inner.Expression, serializableOuterKeySelectorReference.Value, serializableInnerKeySelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Join" && m.GetParameters().Length == 5).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult))), outer.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<int> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<int, TKey>> innerKeySelector, Expression<Func<TOuter, int, TResult>> resultSelector)
    {
        return Join<TOuter, int, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<uint> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<uint, TKey>> innerKeySelector, Expression<Func<TOuter, uint, TResult>> resultSelector)
    {
        return Join<TOuter, uint, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<short> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<short, TKey>> innerKeySelector, Expression<Func<TOuter, short, TResult>> resultSelector)
    {
        return Join<TOuter, short, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ushort> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ushort, TKey>> innerKeySelector, Expression<Func<TOuter, ushort, TResult>> resultSelector)
    {
        return Join<TOuter, ushort, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<byte> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<byte, TKey>> innerKeySelector, Expression<Func<TOuter, byte, TResult>> resultSelector)
    {
        return Join<TOuter, byte, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<long> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<long, TKey>> innerKeySelector, Expression<Func<TOuter, long, TResult>> resultSelector)
    {
        return Join<TOuter, long, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ulong> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ulong, TKey>> innerKeySelector, Expression<Func<TOuter, ulong, TResult>> resultSelector)
    {
        return Join<TOuter, ulong, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<decimal> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<decimal, TKey>> innerKeySelector, Expression<Func<TOuter, decimal, TResult>> resultSelector)
    {
        return Join<TOuter, decimal, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<double> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<double, TKey>> innerKeySelector, Expression<Func<TOuter, double, TResult>> resultSelector)
    {
        return Join<TOuter, double, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<char> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<char, TKey>> innerKeySelector, Expression<Func<TOuter, char, TResult>> resultSelector)
    {
        return Join<TOuter, char, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<DateTime> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<DateTime, TKey>> innerKeySelector, Expression<Func<TOuter, DateTime, TResult>> resultSelector)
    {
        return Join<TOuter, DateTime, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TimeSpan> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TimeSpan, TKey>> innerKeySelector, Expression<Func<TOuter, TimeSpan, TResult>> resultSelector)
    {
        return Join<TOuter, TimeSpan, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<int?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<int?, TKey>> innerKeySelector, Expression<Func<TOuter, int?, TResult>> resultSelector)
    {
        return Join<TOuter, int?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<uint?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<uint?, TKey>> innerKeySelector, Expression<Func<TOuter, uint?, TResult>> resultSelector)
    {
        return Join<TOuter, uint?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<short?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<short?, TKey>> innerKeySelector, Expression<Func<TOuter, short?, TResult>> resultSelector)
    {
        return Join<TOuter, short?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ushort?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ushort?, TKey>> innerKeySelector, Expression<Func<TOuter, ushort?, TResult>> resultSelector)
    {
        return Join<TOuter, ushort?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<byte?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<byte?, TKey>> innerKeySelector, Expression<Func<TOuter, byte?, TResult>> resultSelector)
    {
        return Join<TOuter, byte?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<long?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<long?, TKey>> innerKeySelector, Expression<Func<TOuter, long?, TResult>> resultSelector)
    {
        return Join<TOuter, long?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ulong?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ulong?, TKey>> innerKeySelector, Expression<Func<TOuter, ulong?, TResult>> resultSelector)
    {
        return Join<TOuter, ulong?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<decimal?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<decimal?, TKey>> innerKeySelector, Expression<Func<TOuter, decimal?, TResult>> resultSelector)
    {
        return Join<TOuter, decimal?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<double?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<double?, TKey>> innerKeySelector, Expression<Func<TOuter, double?, TResult>> resultSelector)
    {
        return Join<TOuter, double?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<char?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<char?, TKey>> innerKeySelector, Expression<Func<TOuter, char?, TResult>> resultSelector)
    {
        return Join<TOuter, char?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<DateTime?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<DateTime?, TKey>> innerKeySelector, Expression<Func<TOuter, DateTime?, TResult>> resultSelector)
    {
        return Join<TOuter, DateTime?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TimeSpan?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TimeSpan?, TKey>> innerKeySelector, Expression<Func<TOuter, TimeSpan?, TResult>> resultSelector)
    {
        return Join<TOuter, TimeSpan?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<string> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<string, TKey>> innerKeySelector, Expression<Func<TOuter, string, TResult>> resultSelector)
    {
        return Join<TOuter, string, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    private static IAsyncQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector)
    {
        var serializableOuterKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableOuterKeySelectorReference, outer.ParameterMode, outer.Context).Visit(outerKeySelector);
        var serializableInnerKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableInnerKeySelectorReference, outer.ParameterMode, outer.Context).Visit(innerKeySelector);
        var serializableResultSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableResultSelectorReference, outer.ParameterMode, outer.Context).Visit(resultSelector);
        return new AsyncQueryable<TResult>(outer.Context, new SerializableMethodCallExpression(null, new[] { outer.Expression, outer.ParameterMode == ParameterMode.OnDefinition ? new SerializableConstantExpression(inner, typeof(IEnumerable<TInner>)) : new SerializableConstantExpression((Delegate)(Func<IEnumerable<TInner>>)(() => inner), typeof(IEnumerable<TInner>)), serializableOuterKeySelectorReference.Value, serializableInnerKeySelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Join" && m.GetParameters().Length == 5).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult))), outer.ParameterMode);
    }
        
    public static IAsyncQueryableValue<TSource> Last<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Last" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> Last<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Last" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> Last<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Last" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> LastOrDefault<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "LastOrDefault" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> LastOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "LastOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> LastOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "LastOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<long> LongCount<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<long>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "LongCount" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<long> LongCount<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<long>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "LongCount" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<long> LongCount<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<long>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "LongCount" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<TSource> Max<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Max" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<TResult> Max<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
    {
        var serializableSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Max" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<TSource> Min<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Min" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<TResult> Min<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
    {
        var serializableSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Min" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> OfType<TResult>(this IAsyncQueryable source)
    {
        if (source.Type == typeof(TResult))
            return (IAsyncQueryable<TResult>)source;
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethod("OfType").MakeGenericMethod(typeof(TResult))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties.Where(p => typeof(TResult).GetProperty(p) != null), source.SelectedProperties.Where(p => typeof(TResult).GetProperty(p) != null));
    }
        
    public static IAsyncQueryable<TSource> OrderBy<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
    {
        var serializableKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "OrderBy" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> OrderByDescending<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
    {
        var serializableKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "OrderByDescending" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> Reverse<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethod("Reverse").MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TResult> Select<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
    {
        if (selector.Body == selector.Parameters[0])
            return (IAsyncQueryable<TResult>)source;
        var memberInit = selector.Body as MemberInitExpression;
        var serializableSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Select" && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode, selectedProperties: memberInit == null ? null : memberInit.Bindings.Select(mb => mb.Member.Name));
    }
        
    public static IAsyncQueryable<TResult> Select<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<TResult>>> selector)
    {
        if (selector.Body == selector.Parameters[0])
            return (IAsyncQueryable<TResult>)source;
        var memberInit = selector.Body as MemberInitExpression;
        var serializableSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Select" && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode, selectedProperties: memberInit == null ? null : memberInit.Bindings.Select(mb => mb.Member.Name));
    }
        
    public static IAsyncQueryable<IEnumerable<TResult>> Select<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryable<TResult>>> selector)
    {
        if (selector.Body == selector.Parameters[0])
            return (IAsyncQueryable<IEnumerable<TResult>>)source;
        var memberInit = selector.Body as MemberInitExpression;
        var serializableSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryable<IEnumerable<TResult>>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Select" && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(IEnumerable<TResult>))), source.ParameterMode, selectedProperties: memberInit == null ? null : memberInit.Bindings.Select(mb => mb.Member.Name));
    }
        
    public static IAsyncQueryable<TResult> SelectMany<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TResult>>> selector)
    {
        var serializableSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> SelectMany<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryable<TResult>>> selector)
    {
        var serializableSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector)
    {
        var serializableCollectionSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableCollectionSelectorReference, source.ParameterMode, source.Context).Visit(collectionSelector);
        var serializableResultSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableResultSelectorReference, source.ParameterMode, source.Context).Visit(resultSelector);
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableCollectionSelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 3 && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TCollection), typeof(TResult))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector)
    {
        var serializableCollectionSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableCollectionSelectorReference, source.ParameterMode, source.Context).Visit(collectionSelector);
        ((SerializableLambdaExpression)serializableCollectionSelectorReference.Value).ReturnType = new SerializableType(typeof(IEnumerable<TCollection>));
        var serializableResultSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableResultSelectorReference, source.ParameterMode, source.Context).Visit(resultSelector);
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableCollectionSelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 3 && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TCollection), typeof(TResult))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<TSource> Single<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Single" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> Single<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Single" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> Single<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Single" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> SingleOrDefault<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "SingleOrDefault" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> SingleOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SingleOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> SingleOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SingleOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> Skip<TSource>(this IAsyncQueryable<TSource> source, int count)
    {
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, new SerializableConstantExpression(count, typeof(int)) }, typeof(Queryable).GetMethod("Skip").MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<decimal?> Sum(this IAsyncQueryable<decimal?> source)
    {
        return Sum<decimal?>(source);
    }
    public static IAsyncQueryableValue<decimal> Sum(this IAsyncQueryable<decimal> source)
    {
        return Sum<decimal>(source);
    }
    public static IAsyncQueryableValue<double?> Sum(this IAsyncQueryable<double?> source)
    {
        return Sum<double?>(source);
    }
    public static IAsyncQueryableValue<double> Sum(this IAsyncQueryable<double> source)
    {
        return Sum<double>(source);
    }
    public static IAsyncQueryableValue<float?> Sum(this IAsyncQueryable<float?> source)
    {
        return Sum<float?>(source);
    }
    public static IAsyncQueryableValue<float> Sum(this IAsyncQueryable<float> source)
    {
        return Sum<float>(source);
    }
    public static IAsyncQueryableValue<int?> Sum(this IAsyncQueryable<int?> source)
    {
        return Sum<int?>(source);
    }
    public static IAsyncQueryableValue<int> Sum(this IAsyncQueryable<int> source)
    {
        return Sum<int>(source);
    }
    public static IAsyncQueryableValue<long?> Sum(this IAsyncQueryable<long?> source)
    {
        return Sum<long?>(source);
    }
    public static IAsyncQueryableValue<long> Sum(this IAsyncQueryable<long> source)
    {
        return Sum<long>(source);
    }
    private static IAsyncQueryableValue<T> Sum<T>(this IAsyncQueryable<T> source)
    {
        return new AsyncQueryableValue<T>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Sum" && m.GetParameters()[0].ParameterType == typeof(IQueryable<T>))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<decimal?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, decimal?>> selector)
    {
        return Sum<TSource, decimal?>(source, selector);
    }
    public static IAsyncQueryableValue<decimal> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, decimal>> selector)
    {
        return Sum<TSource, decimal>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, double?>> selector)
    {
        return Sum<TSource, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, double>> selector)
    {
        return Sum<TSource, double>(source, selector);
    }
    public static IAsyncQueryableValue<float?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, float?>> selector)
    {
        return Sum<TSource, float?>(source, selector);
    }
    public static IAsyncQueryableValue<float> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, float>> selector)
    {
        return Sum<TSource, float>(source, selector);
    }
    public static IAsyncQueryableValue<int?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, int?>> selector)
    {
        return Sum<TSource, int?>(source, selector);
    }
    public static IAsyncQueryableValue<int> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, int>> selector)
    {
        return Sum<TSource, int>(source, selector);
    }
    public static IAsyncQueryableValue<long?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, long?>> selector)
    {
        return Sum<TSource, long?>(source, selector);
    }
    public static IAsyncQueryableValue<long> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, long>> selector)
    {
        return Sum<TSource, long>(source, selector);
    }
    private static IAsyncQueryableValue<T> Sum<TSource, T>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, T>> selector)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryableValue<T>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Sum" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.ToString() == string.Format("System.Linq.Expressions.Expression`1[System.Func`2[TSource,{0}]]", typeof(T).ToString())).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<decimal?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<decimal?>>> selector)
    {
        return SumAsyncQueryable<TSource, decimal?>(source, selector);
    }
    public static IAsyncQueryableValue<decimal> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<decimal>>> selector)
    {
        return SumAsyncQueryable<TSource, decimal>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<double?>>> selector)
    {
        return SumAsyncQueryable<TSource, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<double>>> selector)
    {
        return SumAsyncQueryable<TSource, double>(source, selector);
    }
    public static IAsyncQueryableValue<float?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<float?>>> selector)
    {
        return SumAsyncQueryable<TSource, float?>(source, selector);
    }
    public static IAsyncQueryableValue<float> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<float>>> selector)
    {
        return SumAsyncQueryable<TSource, float>(source, selector);
    }
    public static IAsyncQueryableValue<int?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<int?>>> selector)
    {
        return SumAsyncQueryable<TSource, int?>(source, selector);
    }
    public static IAsyncQueryableValue<int> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<int>>> selector)
    {
        return SumAsyncQueryable<TSource, int>(source, selector);
    }
    public static IAsyncQueryableValue<long?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<long?>>> selector)
    {
        return SumAsyncQueryable<TSource, long?>(source, selector);
    }
    public static IAsyncQueryableValue<long> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<long>>> selector)
    {
        return SumAsyncQueryable<TSource, long>(source, selector);
    }
    private static IAsyncQueryableValue<T> SumAsyncQueryable<TSource, T>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<T>>> selector)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryableValue<T>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Sum" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.ToString() == string.Format("System.Linq.Expressions.Expression`1[System.Func`2[TSource,{0}]]", typeof(T).ToString())).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TSource> Take<TSource>(this IAsyncQueryable<TSource> source, int count)
    {
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, new SerializableConstantExpression(count, typeof(int)) }, typeof(Queryable).GetMethod("Take").MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> ThenBy<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
    {
        var serializableKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "ThenBy" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> ThenByDescending<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
    {
        var serializableKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "ThenByDescending" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> Union<TSource>(this IAsyncQueryable<TSource> source1, IAsyncQueryable<TSource> source2)
    {
        return new AsyncQueryable<TSource>(source1.Context, new SerializableMethodCallExpression(null, new[] { source1.Expression, source2.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Union" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source1.ParameterMode);
    }
        
    public static IAsyncQueryable<TSource> Where<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return Where(source, serializablePredicateReference.Value);
    }
        
    public static IAsyncQueryable<TSource> Where<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return Where(source, serializablePredicateReference.Value);
    }
        
    public static IAsyncQueryable<TSource> Where<TSource>(IAsyncQueryable<TSource> source, SerializableExpression predicate)
    {
        return CreateAsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, predicate }, typeof(Queryable).GetMethods().First(m => m.Name == "Where" && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
        
        
    public static Expression<Func<T, bool>> BuildOr<T>(IEnumerable<Expression<Func<T, bool>>> exps)
    {
        if (exps == null || !exps.Any())
            return Expression.Lambda<Func<T, bool>>(Expression.Constant(true, typeof(bool)), Expression.Parameter(typeof(T), "p" + Guid.NewGuid().ToString("N")));
        var parameterExpression = Expression.Parameter(typeof(T), "p" + Guid.NewGuid().ToString("N"));
        return Expression.Lambda<Func<T, bool>>(exps.Select(e => e.ReplaceBodyParameter(parameterExpression)).Aggregate((e1, e2) => Expression.OrElse(e1, e2)), parameterExpression);
    }
        
        
        
        
    public static IAsyncQueryable<TSource> Include<TSource, TInclude>(IAsyncQueryable<TSource> source, params Func<IAsyncQueryableBase, AsyncQueryableInclude>[] includes)
    {
        return CreateAsyncQueryable<TSource>(source.Context, source.Expression, source.ParameterMode, source.Includes.Union(includes), source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> Include<TSource, TInclude>(IAsyncQueryableValue<TSource> source, params Func<IAsyncQueryableBase, AsyncQueryableInclude>[] includes)
    {
        return CreateAsyncQueryableValue<TSource>(source.Context, source.Expression, source.ParameterMode, source.Includes.Union(includes), source.WithSpecificationsProperties, source.SelectedProperties);
    }
    
    public static IAsyncQueryable<OneT> IncludeOneToMany<OneT, ManyT>(IAsyncQueryable<OneT> source, IAsyncQueryable<ManyT> manyEntitySet, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<OneT, ManyT, bool>> anyExp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeOneToMany<OneT, OneT, ManyT>(source, manyEntitySet, exp, anyExp, queryTransform, fkTest, getTrackableCollection);
    }
    
    public static IAsyncQueryable<OneBaseT> IncludeOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryable<OneBaseT> source, IAsyncQueryable<ManyT> manyEntitySet, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<OneT, ManyT, bool>> anyExp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
        where OneT : OneBaseT
        where OneBaseT : IEntity
        where ManyT : IEntity
    {
        return Include<OneBaseT, ManyT>(source, onesQuery =>
            {
                var include = new AsyncQueryableInclude();
                var onesQueryAsAsyncQueryable = onesQuery as IAsyncQueryable<OneBaseT>;
                IAsyncQueryableBase subQuery;
                Func<object, object[], MergeOption, object> load;
                if (onesQueryAsAsyncQueryable == null)
                {
                    subQuery = CreateQuery(qt => CreateOneToOne((IAsyncQueryableValue<OneBaseT>)onesQuery, exp, q => qt == null ? q.Select(e => e.Select(e2 => e2)) : q.Select(qt).Select(e => e.Select(e2 => e2))), queryTransform);
                    load = (oneValues, manyValues, mergeOption) => IncludeOneOneToMany(oneValues, manyValues, mergeOption, getTrackableCollection);
                }
                else
                {
                    subQuery = CreateOneToManyQuery(onesQueryAsAsyncQueryable.OfType<OneT>(), manyEntitySet, anyExp, ref queryTransform);
                    if (queryTransform == null || queryTransform.Body is ParameterExpression)
                    {
                        string path = ((MemberExpression)exp.Body).Member.Name;
                        include.Path = path;
                    }
                    load = (oneValues, manyValues, mergeOption) => IncludeOneToMany(oneValues, manyValues, mergeOption, fkTest, getTrackableCollection);
                }
                include.Queries = new IAsyncQueryableBase[] { subQuery };
                include.Load = load;
                return include;
            });
    }
        
    public static IAsyncQueryable<OneT> IncludeOneToMany<OneT, ManyT>(IAsyncQueryable<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, fkTest, getTrackableCollection);
    }
        
    public static IAsyncQueryable<OneBaseT> IncludeOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryable<OneBaseT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
        where OneT : OneBaseT
        where OneBaseT : IEntity
        where ManyT : IEntity
    {
        return Include<OneBaseT, ManyT>(source, onesQuery =>
        {
            var include = new AsyncQueryableInclude();
            var onesQueryAsAsyncQueryable = onesQuery as IAsyncQueryable<OneBaseT>;
            IAsyncQueryableBase subQuery;
            Func<object, object[], MergeOption, object> load;
            if (onesQueryAsAsyncQueryable == null)
            {
                subQuery = CreateQuery(qt => CreateOneToOne((IAsyncQueryableValue<OneBaseT>)onesQuery, exp, q => q.Select(qt)), queryTransform);
                load = (oneValues, manyValues, mergeOption) => IncludeOneOneToMany(oneValues, manyValues, mergeOption, getTrackableCollection);
            }
            else
            {
                subQuery = CreateOneToManyQuery(onesQueryAsAsyncQueryable.OfType<OneT>(), exp, ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                load = (oneValues, manyValues, mergeOption) => IncludeOneToMany(oneValues, manyValues, mergeOption, fkTest, getTrackableCollection);
            }
            include.Queries = new IAsyncQueryableBase[] { subQuery };
            include.Load = load;
            return include;
        });
    }
        
    private static QueryT CreateQuery<QueryT, ExpressionT>(Func<Expression<ExpressionT>, QueryT> getQuery, Expression<ExpressionT> queryTransform)
        where QueryT : IAsyncQueryableBase
    {
        return CreateQuery<QueryT, ExpressionT>(getQuery, ref queryTransform);
    }
        
    private static QueryT CreateQuery<QueryT, ExpressionT>(Func<Expression<ExpressionT>, QueryT> getQuery, ref Expression<ExpressionT> queryTransform)
        where QueryT : IAsyncQueryableBase
    {
        var includeExpressionVisitor = new IncludeExpressionVisitor<QueryT>();
        queryTransform = (Expression<ExpressionT>)includeExpressionVisitor.Visit(queryTransform);
        var value = getQuery(queryTransform);
        foreach (var includeAction in includeExpressionVisitor.IncludeActions)
            value = includeAction(value);
        return value;
    }

    private static IAsyncQueryable<ManyT> CreateOneToManyQuery<OneT, ManyT>(IAsyncQueryable<OneT> source, IAsyncQueryable<ManyT> manyEntitySet, Expression<Func<OneT, ManyT, bool>> exp, ref Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform)
    {
        var oParameter = new SerializableParameterExpression { Name = "o" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(OneT)) };
        var mParameter = new SerializableParameterExpression { Name = "m" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(ManyT)) };
        var serializableExpReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableExpReference, source.ParameterMode, source.Context).Visit(exp);
        var anyLambda = (SerializableLambdaExpression)serializableExpReference.Value;
        var serializableExp = Where(manyEntitySet, new SerializableLambdaExpression(new List<SerializableParameterExpression>() { mParameter }, new SerializableType(typeof(bool)), Any(source, new SerializableUnaryExpression(new SerializableLambdaExpression(new List<SerializableParameterExpression>() { oParameter }, new SerializableType(typeof(bool)), anyLambda.Body.ReplaceParameter(spe =>
        {
            switch (anyLambda.Parameters.IndexOf(spe))
            {
                case 0:
                    return oParameter;
                case 1:
                    return mParameter;
                default:
                    throw new InvalidOperationException();
            }
        })), ExpressionType.Quote, typeof(Expression<Func<OneT, bool>>))).Expression));
        return CreateQuery(qt => AddTransformExp<ManyT>(source, (LambdaExpression)qt, serializableExp.Expression), queryTransform);
    }

    private static IAsyncQueryable<T> AddTransformExp<T>(IAsyncQueryable source, LambdaExpression qt, SerializableExpression serializableExp)
    {
        MethodCallExpression qtMethodCall;
        if (qt != null && (qtMethodCall = qt.Body as MethodCallExpression) != null)
        {
            var serializableReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableReference, source.ParameterMode, new Dictionary<ParameterExpression, SerializableParameterExpression>(), source.Context, p => p == qt.Parameters[0] ? serializableExp : null) { UseQueryable = true }.Visit(qtMethodCall);
            var serializableMethodCallExpression = (SerializableMethodCallExpression)serializableReference.Value;
            serializableExp = serializableMethodCallExpression;
        }
        return CreateAsyncQueryable<T>(source.Context, serializableExp, source.ParameterMode);
    }

    private static IAsyncQueryable<ManyT> CreateOneToManyQuery<OneT, ManyT>(IAsyncQueryable<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, ref Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform)
    {
        return CreateQuery(qt => CreateAsyncQueryable<ManyT>(source.Context, source.RemoveSelectFromSource().Select(exp).Select(qt).Expression, source.ParameterMode), ref queryTransform);
    }
        
    private static IAsyncQueryableValue<ToTResult> CreateOneToOne<FromBaseT, FromT, ToT, ToTResult>(IAsyncQueryableValue<FromBaseT> source, Expression<Func<FromT, ToT>> exp, Func<IAsyncQueryable<ToT>, IAsyncQueryable<ToTResult>> queryTransform)
        where FromT : FromBaseT
    {
        var sourceValue = source.RemoveSelectFromSource();
        var serializableMethodCallExpression = (SerializableMethodCallExpression)sourceValue.Expression;
        MethodInfo method;
        var baseQuery = CreateToOne<FromBaseT>(sourceValue, serializableMethodCallExpression, out method).OfType<FromT>();
        return CreateAsyncQueryableValue<ToTResult>(source.Context, new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { queryTransform(baseQuery.Select(exp)).Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(ToTResult))), source.ParameterMode);
    }
        
    private static SerializableExpression AddOfType<BaseT, T>(IAsyncQueryableValue<BaseT> source)
        where T : BaseT
    {
        if (typeof(BaseT) == typeof(T))
            return source.Expression;
        var sourceValue = source.RemoveSelectFromSource();
        var serializableMethodCallExpression = (SerializableMethodCallExpression)sourceValue.Expression;
        MethodInfo method;
        var baseQuery = CreateToOne<BaseT>(sourceValue, serializableMethodCallExpression, out method).OfType<T>();
        return new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { baseQuery.Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)));
    }
        
    private static IAsyncQueryable<FromT> CreateToOne<FromT>(IAsyncQueryableBase source, SerializableMethodCallExpression serializableMethodCallExpression, out MethodInfo method)
    {
        switch (serializableMethodCallExpression.MemberName)
        {
            case "First":
            case "FirstOrDefault":
            case "Single":
            case "SingleOrDefault":
            case "Last":
            case "LastOrDefault":
                var baseQuery = CreateAsyncQueryable<FromT>(source.Context, serializableMethodCallExpression.Parameters[0], source.ParameterMode);
                switch (serializableMethodCallExpression.Parameters.Count)
                {
                    case 1:
                        method = serializableMethodCallExpression.Method;
                        break;
                    case 2:
                        method = serializableMethodCallExpression.Method.DeclaringType.GetMethods().First(m => m.Name == serializableMethodCallExpression.Method.Name && m.GetParameters().Length == 1);
                        baseQuery = AsyncQueryableExtensions.Where(baseQuery, serializableMethodCallExpression.Parameters[1]);
                        break;
                    default:
                        throw new NotImplementedException();
                }
                return baseQuery.RemoveSelectFromSource();
            default:
                throw new NotImplementedException();
        }
    }
        
    private static IEnumerable<ManyT> IncludeOneToMany<OneT, ManyT>(object oneValues, object[] manyValues, MergeOption mergeOption, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
        where OneT : IEntity
        where ManyT : IEntity
    {
        var many = ((IEnumerable<object>)manyValues[0]).Cast<ManyT>();
		if (mergeOption == MergeOption.NoTracking)
		{
			var manyList = many.ToArray();
			var ones = ((IEnumerable<object>)oneValues).Cast<OneT>().ToArray();
			foreach (var one in ones)
			{
				for (int i = 0; i < manyList.Length; i++)
				{
					if (fkTest(one, manyList[i]))
					{
						getTrackableCollection(one).Attach(manyList[i]);
					}
				}
			}
		}

		return many;
    }
        
    public static IAsyncQueryableValue<OneT> IncludeOneOneToMany<OneT, ManyT>(IAsyncQueryableValue<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeOneOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, getTrackableCollection, manyToMany);
    }
        
    public static IAsyncQueryableValue<OneBaseT> IncludeOneOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<OneBaseT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : OneBaseT
        where OneBaseT : IEntity
        where ManyT : IEntity
    {
        return Include<OneBaseT, ManyT>(source, onesQuery =>
        {
            var include = new AsyncQueryableInclude();
            IAsyncQueryableBase subQuery;
            Func<object, object[], MergeOption, object> load;
            subQuery = CreateQuery(qt => CreateOneToOne((IAsyncQueryableValue<OneBaseT>)onesQuery, exp, q => qt == null ? q.Select(e => e.Select(e2 => e2)) : q.Select(qt).Select(e => e.Select(e2 => e2))), ref queryTransform);
            if (queryTransform == null || queryTransform.Body is ParameterExpression)
            {
                string path = ((MemberExpression)exp.Body).Member.Name;
                include.Path = path;
            }
            load = (oneValues, manyValues, mergeOption) => IncludeOneOneToMany(oneValues, manyValues, mergeOption, getTrackableCollection, manyToMany);
            include.Queries = new IAsyncQueryableBase[] { subQuery };
            include.Load = load;
            return include;
        });
    }
        
    public static IAsyncQueryableValue<OneT> IncludeOneOneToMany<OneT, ManyT>(IAsyncQueryableValue<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeOneOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, getTrackableCollection, manyToMany);
    }
        
    public static IAsyncQueryableValue<OneBaseT> IncludeOneOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<OneBaseT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : OneBaseT
        where OneBaseT : IEntity
        where ManyT : IEntity
    {
        return Include<OneBaseT, ManyT>(source, onesQuery =>
        {
            var include = new AsyncQueryableInclude();
            IAsyncQueryableBase subQuery;
            Func<object, object[], MergeOption, object> load;
            subQuery = CreateQuery(qt => CreateOneToOne((IAsyncQueryableValue<OneBaseT>)onesQuery, exp, q => q.Select(qt)), ref queryTransform);
            if (queryTransform == null || queryTransform.Body is ParameterExpression)
            {
                string path = ((MemberExpression)exp.Body).Member.Name;
                include.Path = path;
            }
            load = (oneValues, manyValues, mergeOption) => IncludeOneOneToMany(oneValues, manyValues, mergeOption, getTrackableCollection, manyToMany);
            include.Queries = new IAsyncQueryableBase[] { subQuery };
            include.Load = load;
            return include;
        });
    }
        
    private static object IncludeOneOneToMany<OneT, ManyT>(object oneValues, object[] manyValues, MergeOption mergeOption, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : IEntity
        where ManyT : IEntity
    {
        var one = (OneT)oneValues;
        if (one == null)
            return null;
        var many = ((IEnumerable<object>)manyValues[0]).Cast<ManyT>();
        if (mergeOption == MergeOption.NoTracking || manyToMany)
        {
			var manyList = many.ToArray();
			foreach (var manyElt in manyList)
			{
				getTrackableCollection(one).Attach(manyElt);
			}
		}

        return many;
    }
        
    public static IAsyncQueryableValue<IEnumerable<OneT>> IncludeManyOneToMany<OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeManyOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, fkTest, getTrackableCollection, manyToMany);
    }
        
    public static IAsyncQueryableValue<IEnumerable<OneBaseT>> IncludeManyOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : OneBaseT
        where OneBaseT : IEntity
        where ManyT : IEntity
    {
        return Include<IEnumerable<OneBaseT>, ManyT>(source, onesQuery =>
        {
            var include = new AsyncQueryableInclude();
            IAsyncQueryableBase subQuery;
            Func<object, object[], MergeOption, object> load;
            subQuery = CreateManyOneToMany((IAsyncQueryableValue<IEnumerable<OneBaseT>>)source, exp, ref queryTransform);
            if (queryTransform == null || queryTransform.Body is ParameterExpression)
            {
                string path = ((MemberExpression)exp.Body).Member.Name;
                include.Path = path;
            }
            load = (oneValues, manyValues, mergeOption) => IncludeManyOneToMany(oneValues, manyValues, mergeOption, fkTest, getTrackableCollection);
            include.Queries = new IAsyncQueryableBase[] { subQuery };
            include.Load = load;
            return include;
        });
    }
        
    private static IAsyncQueryableValue<IEnumerable<ManyT>> CreateManyOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, ref Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform)
        where OneT : OneBaseT
    {
        return CreateQuery(qt =>
        {
            var serializableMethodCallExpression = (SerializableMethodCallExpression)source.Expression;
            MethodInfo method;
            var baseQuery = CreateToOne<IEnumerable<OneBaseT>>(source, serializableMethodCallExpression, out method).Select(os => os.OfType<OneT>());
            var selectParameter = Expression.Parameter(typeof(IEnumerable<OneT>), "e" + Guid.NewGuid().ToString("N"));
            if (qt != null)
                exp = Expression.Lambda<Func<OneT, IEnumerable<ManyT>>>(qt.ReplaceBodyParameter(exp.Body), exp.Parameters[0]);
            var manyQuery = baseQuery.Select(Expression.Lambda<Func<IEnumerable<OneT>, IEnumerable<ManyT>>>(Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2).MakeGenericMethod(typeof(OneT), typeof(ManyT)), selectParameter, exp), selectParameter));
            return CreateAsyncQueryableValue<IEnumerable<ManyT>>(source.Context, new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { manyQuery.Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(IEnumerable<ManyT>))), source.ParameterMode);
        }, ref queryTransform);
    }
        
    private static object IncludeManyOneToMany<OneT, ManyT>(object oneValues, object[] manyValues, MergeOption mergeOption, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
        where OneT : IEntity
        where ManyT : IEntity
    {
		var value = ((IEnumerable<object>)manyValues[0]).Cast<ManyT>();
		if (mergeOption == MergeOption.NoTracking)
		{
			object oneValue = ((IEnumerable<object>)oneValues).Cast<OneT>();
			var ones = ((IEnumerable<object>)oneValue).Cast<OneT>().ToArray();
			var manyList = value.ToArray();
			foreach (var one in ones)
			{
				for (int i = 0; i < manyList.Length; i++)
				{
					if (fkTest(one, manyList[i]))
					{
						getTrackableCollection(one).Attach(manyList[i]);
					}
				}
			}
		}

		return value;
    }
        
    public static IAsyncQueryableValue<IEnumerable<OneT>> IncludeManyOneToOneMany<OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeManyOneToOneMany<OneT, OneT, ManyT>(source, exp, queryTransform, fkTest, getTrackableCollection, manyToMany);
    }
        
    public static IAsyncQueryableValue<IEnumerable<OneBaseT>> IncludeManyOneToOneMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : OneBaseT
        where OneBaseT : IEntity
        where ManyT : IEntity
    {
        return Include<IEnumerable<OneBaseT>, ManyT>(source, onesQuery =>
        {
            var include = new AsyncQueryableInclude();
            IAsyncQueryableBase subQuery;
            Func<object, object[], MergeOption, object> load;
            subQuery = CreateManyOneToOneMany((IAsyncQueryableValue<IEnumerable<OneBaseT>>)source, exp, ref queryTransform);
            if (queryTransform == null || queryTransform.Body is ParameterExpression)
            {
                string path = ((MemberExpression)exp.Body).Member.Name;
                include.Path = path;
            }
            load = (oneValues, manyValues, mergeOption) => IncludeManyOneToOneMany(oneValues, manyValues, mergeOption, fkTest, getTrackableCollection);
            include.Queries = new IAsyncQueryableBase[] { subQuery };
            include.Load = load;
            return include;
        });
    }
        
    private static IAsyncQueryableValue<IEnumerable<ManyT>> CreateManyOneToOneMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, ref Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform)
        where OneT : OneBaseT
    {
        return CreateQuery(qt =>
        {
            var serializableMethodCallExpression = (SerializableMethodCallExpression)source.Expression;
            MethodInfo method;
            var baseQuery = CreateToOne<IEnumerable<OneBaseT>>(source, serializableMethodCallExpression, out method).Select(os => os.OfType<OneT>());
            var selectParameter = Expression.Parameter(typeof(IEnumerable<OneT>), "e" + Guid.NewGuid().ToString("N"));
            var expOne = Expression.Lambda<Func<OneT, ManyT>>(qt.ReplaceBodyParameter(exp.Body), exp.Parameters[0]);
            var manyQuery = baseQuery.Select(Expression.Lambda<Func<IEnumerable<OneT>, IEnumerable<ManyT>>>(Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Select" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2).MakeGenericMethod(typeof(OneT), typeof(ManyT)), selectParameter, expOne), selectParameter));
            return CreateAsyncQueryableValue<IEnumerable<ManyT>>(source.Context, new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { manyQuery.Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(IEnumerable<ManyT>))), source.ParameterMode);
        }, ref queryTransform);
    }
        
    private static object IncludeManyOneToOneMany<OneT, ManyT>(object oneValues, object[] manyValues, MergeOption mergeOption, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
        where OneT : IEntity
        where ManyT : IEntity
    {
		var many = ((IEnumerable<object>)manyValues).Cast<ManyT>();
		if (mergeOption == MergeOption.NoTracking)
		{
			var ones = ((IEnumerable<object>)oneValues).Cast<OneT>().ToArray();
			var manyList = many.ToArray();
			foreach (var one in ones)
			{
				for (int i = 0; i < manyList.Length; i++)
				{
					if (fkTest(one, manyList[i]))
					{
						getTrackableCollection(one).Attach(manyList[0]);
					}
				}
			}
		}

		return many;
    }
        
    public static IAsyncQueryable<ManyT> IncludeManyToOne<ManyT, OneT>(IAsyncQueryable<ManyT> source, IAsyncQueryable<OneT> onesEntitySet, Expression<Func<ManyT, OneT>> exp, Expression<Func<ManyT, OneT, bool>> anyExp, Expression<Func<OneT, OneT>> queryTransform, Func<ManyT, OneT, bool> fkTest, Action<ManyT, OneT> setOne)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeManyToOne<ManyT, ManyT, OneT>(source, onesEntitySet, exp, anyExp, queryTransform, fkTest, setOne);
    }
        
    public static IAsyncQueryable<ManyBaseT> IncludeManyToOne<ManyBaseT, ManyT, OneT>(IAsyncQueryable<ManyBaseT> source, IAsyncQueryable<OneT> onesEntitySet, Expression<Func<ManyT, OneT>> exp, Expression<Func<ManyT, OneT, bool>> anyExp, Expression<Func<OneT, OneT>> queryTransform, Func<ManyT, OneT, bool> fkTest, Action<ManyT, OneT> setOne)
        where ManyBaseT : IEntity
        where ManyT : ManyBaseT
        where OneT : IEntity
    {
        return Include<ManyBaseT, OneT>(source, manyQuery =>
        {
            var include = new AsyncQueryableInclude();
            var manyQueryAsAsyncQueryable = manyQuery as IAsyncQueryable<ManyBaseT>;
            IAsyncQueryableBase subQuery;
            Func<object, object[], MergeOption, object> load;
            if (manyQueryAsAsyncQueryable == null)
            {
                subQuery = CreateQuery(qt => CreateOneToOne(((IAsyncQueryableValue<ManyBaseT>)manyQuery), exp, q => q), queryTransform);
                load = (manyValues, oneValues, mergeOption) => IncludeOneManyToOne(manyValues, oneValues, mergeOption, setOne);
            }
            else
            {
                subQuery = CreateManyToOneQuery(manyQueryAsAsyncQueryable.OfType<ManyT>(), onesEntitySet, anyExp, ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                load = (manyValues, oneValues, mergeOption) => IncludeManyToOne(manyValues, oneValues, mergeOption, fkTest, setOne);
            }
            include.Queries = new IAsyncQueryableBase[] { subQuery };
            include.Load = load;
            return include;
        });
    }
        
    private static IAsyncQueryable<OneT> CreateManyToOneQuery<ManyT, OneT>(IAsyncQueryable<ManyT> source, IAsyncQueryable<OneT> onesEntitySet, Expression<Func<ManyT, OneT, bool>> exp, ref Expression<Func<OneT, OneT>> queryTransform)
    {
        var oParameter = new SerializableParameterExpression { Name = "o" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(OneT)) };
        var mParameter = new SerializableParameterExpression { Name = "m" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(ManyT)) };
        var serializableExpReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableExpReference, source.ParameterMode, source.Context).Visit(exp);
        var anyLambda = (SerializableLambdaExpression)serializableExpReference.Value;
        var serializableExp = Where(onesEntitySet, new SerializableLambdaExpression(new List<SerializableParameterExpression>() { oParameter }, new SerializableType(typeof(bool)), Any(source, new SerializableUnaryExpression(new SerializableLambdaExpression(new List<SerializableParameterExpression>() { mParameter }, new SerializableType(typeof(bool)), anyLambda.Body.ReplaceParameter(spe =>
            {
                switch (anyLambda.Parameters.IndexOf(spe))
                {
                    case 0:
                        return mParameter;
                    case 1:
                        return oParameter;
                    default:
                        throw new InvalidOperationException();
                }
            })), ExpressionType.Quote, typeof(Expression<Func<ManyT, bool>>))).Expression));
        return CreateQuery(qt => AddTransformExp<OneT>(source, (LambdaExpression)qt, serializableExp.Expression), queryTransform);
    }
        
    private static object IncludeManyToOne<ManyT, OneT>(object manyValues, object[] oneValues, MergeOption mergeOption, Func<ManyT, OneT, bool> fkTest, Action<ManyT, OneT> setOne)
        where OneT : IEntity
        where ManyT : IEntity
    {
		var ones = ((IEnumerable<object>)oneValues[0]).Cast<OneT>();
		if (mergeOption == MergeOption.NoTracking)
		{
			var onesArray = ones.Where(e => e != null).ToArray();
			var many = ((IEnumerable<object>)manyValues).Cast<ManyT>().ToArray();
			for (int i = 0; i < many.Length; i++)
			{
				var one = onesArray.FirstOrDefault(e => fkTest(many[i], e));
				if (one != null)
				{
					many[i].IsInitializingRelationships = true;
					setOne(many[i], one);
					many[i].IsInitializingRelationships = false;
				}
			}

		}

		return ones;
    }
        
    private static object IncludeOneManyToOne<ManyT, OneT>(object manyValues, object[] oneValues, MergeOption mergeOption, Action<ManyT, OneT> setOne)
        where OneT : IEntity
        where ManyT : IEntity
    {
        OneT one = (OneT)oneValues[0];
        if (mergeOption == MergeOption.NoTracking)
        {
            if (manyValues == null)
                return null;
            ManyT many = (ManyT)manyValues;
            if (one != null)
            {
                many.IsInitializingRelationships = true;
                setOne(many, one);
                many.IsInitializingRelationships = false;
            }
        }
        return one;
    }
        
    public static IAsyncQueryableValue<ManyT> IncludeOneManyToOne<ManyT, OneT>(IAsyncQueryableValue<ManyT> source, Expression<Func<ManyT, OneT>> exp, Expression<Func<OneT, OneT>> queryTransform, Action<ManyT, OneT> setOne)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeOneManyToOne<ManyT, ManyT, OneT>(source, exp, queryTransform, setOne);
    }
        
    public static IAsyncQueryableValue<ManyBaseT> IncludeOneManyToOne<ManyBaseT, ManyT, OneT>(IAsyncQueryableValue<ManyBaseT> source, Expression<Func<ManyT, OneT>> exp, Expression<Func<OneT, OneT>> queryTransform, Action<ManyT, OneT> setOne)
        where OneT : IEntity
        where ManyT : ManyBaseT
        where ManyBaseT : IEntity
    {
        return Include<ManyBaseT, OneT>(source, manyQuery =>
        {
            var include = new AsyncQueryableInclude();
            IAsyncQueryableBase subQuery;
            Func<object, object[], MergeOption, object> load;
            subQuery = CreateQuery(qt => CreateOneToOne((IAsyncQueryableValue<ManyBaseT>)manyQuery, exp, q => q), ref queryTransform);
            if (queryTransform == null || queryTransform.Body is ParameterExpression)
            {
                string path = ((MemberExpression)exp.Body).Member.Name;
                include.Path = path;
            }
            load = (manyValues, oneValues, mergeOption) => IncludeOneManyToOne(manyValues, oneValues, mergeOption, setOne);
            include.Queries = new IAsyncQueryableBase[] { subQuery };
            include.Load = load;
            return include;
        });
    }
        
    public static IAsyncQueryable<FromT> IncludeManyToMany<FromT, ToT, KeysT>(IAsyncQueryable<FromT> source, IAsyncQueryable<ToT> toEntitySet, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<FromT, TrackableCollectionBase<ToT>>> getCollectionExp, Expression<Func<TrackableCollectionBase<ToT>, ToT, bool>> anyExp, Expression<Func<IEnumerable<ToT>, IEnumerable<ToT>>> queryTransform, Func<IAsyncQueryable<FromT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : IEntity
        where ToT : IEntity
    {
        return IncludeManyToMany<FromT, FromT, ToT, KeysT>(source, toEntitySet, exp, getCollectionExp, anyExp, queryTransform, getKeysQuery, fromFkTest, toFkTest, getTrackableCollection);
    }
        
    public static IAsyncQueryable<FromBaseT> IncludeManyToMany<FromBaseT, FromT, ToT, KeysT>(IAsyncQueryable<FromBaseT> source, IAsyncQueryable<ToT> toEntitySet, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<FromT, TrackableCollectionBase<ToT>>> getCollectionExp, Expression<Func<TrackableCollectionBase<ToT>, ToT, bool>> anyExp, Expression<Func<IEnumerable<ToT>, IEnumerable<ToT>>> queryTransform, Func<IAsyncQueryable<FromT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : FromBaseT
        where FromBaseT : IEntity
        where ToT : IEntity
    {
        return Include<FromBaseT, ToT>(source, fromQuery =>
            {
                var include = new AsyncQueryableInclude();
                var fromBaseQueryAsAsyncQueryable = fromQuery as IAsyncQueryable<FromBaseT>;
                IAsyncQueryableBase toQuery;
                Func<object, object[], MergeOption, object> load;
                if (fromBaseQueryAsAsyncQueryable == null)
                {
                    toQuery = CreateQuery(qt => CreateOneToOne(((IAsyncQueryableValue<FromBaseT>)fromQuery).RemoveSelectFromSource(), exp, q => qt == null ? q.Select(e => e.Select(e2 => e2)) : q.Select(qt).Select(e => e.Select(e2 => e2))), queryTransform);
                    load = (fromValues, toValues, mergeOption) => IncludeOneOneToMany(fromValues, toValues, mergeOption, getTrackableCollection, true);
                    return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery }, Load = load };
                }
                var fromQueryAsAsyncQueryable = fromBaseQueryAsAsyncQueryable.RemoveSelectFromSource().OfType<FromT>();
                toQuery = CreateManyToManyQuery(fromQueryAsAsyncQueryable, toEntitySet, exp, getCollectionExp, anyExp, ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                var keysQuery = getKeysQuery(fromQueryAsAsyncQueryable);
                if (queryTransform != null)
                {
                    var selectManyCollectionSelectorExpression = (SerializableLambdaExpression)((SerializableMethodCallExpression)keysQuery.Expression).Parameters[1];
                    var serializableCollectionSelectorReferenceTransform = new Reference<SerializableExpression>();
                    new SerializableExpressionBuilder(serializableCollectionSelectorReferenceTransform, source.ParameterMode, source.Context).Visit(queryTransform);
                    var queryTransformLambda = (SerializableLambdaExpression)serializableCollectionSelectorReferenceTransform.Value;
                    selectManyCollectionSelectorExpression.Body = queryTransformLambda.ReplaceBodyParameter(selectManyCollectionSelectorExpression.Body);
                }
                load = (fromValues, toValues, mergeOption) => IncludeManyToMany(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                include.Queries = new IAsyncQueryableBase[] { toQuery, keysQuery.RemoveSelectFromSource() };
                include.Load = load;
                return include;
            });
    }
        
    private static IAsyncQueryable<ToT> CreateManyToManyQuery<FromT, ToT>(IAsyncQueryable<FromT> source, IAsyncQueryable<ToT> toEntitySet, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<FromT, TrackableCollectionBase<ToT>>> getCollectionExp, Expression<Func<TrackableCollectionBase<ToT>, ToT, bool>> anyExp, ref Expression<Func<IEnumerable<ToT>, IEnumerable<ToT>>> queryTransform)
        where FromT : IEntity
        where ToT : IEntity
    {
        return CreateQuery(qt =>
            {
                var toParameter = new SerializableParameterExpression { Name = "t" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(ToT)) };
                IAsyncQueryable<ToT> toQuery;
                if (qt == null)
                {
                    var fromParameter = new SerializableParameterExpression { Name = "f" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(FromT)) };
                    var serializableExpReference = new Reference<SerializableExpression>();
                    new SerializableExpressionBuilder(serializableExpReference, source.ParameterMode, source.Context).Visit(anyExp);
                    var anyLambda = (SerializableLambdaExpression)serializableExpReference.Value;
                    toQuery = Where(toEntitySet, new SerializableLambdaExpression(new List<SerializableParameterExpression>() { toParameter }, new SerializableType(typeof(bool)), Any(source, new SerializableUnaryExpression(new SerializableLambdaExpression(new List<SerializableParameterExpression>() { fromParameter }, new SerializableType(typeof(bool)), anyLambda.Body.ReplaceParameter(spe =>
                    {
                        switch (anyLambda.Parameters.IndexOf(spe))
                        {
                            case 0:
                                var serializablegetCollectionExpReference = new Reference<SerializableExpression>();
                                new SerializableExpressionBuilder(serializablegetCollectionExpReference, source.ParameterMode, source.Context).Visit(getCollectionExp);
                                var getSerializableCollectionExp = (SerializableLambdaExpression)serializablegetCollectionExpReference.Value;
                                return getSerializableCollectionExp.ReplaceBodyParameter(fromParameter);
                            case 1:
                                return toParameter;
                            default:
                                throw new InvalidOperationException();
                        }
                    })), ExpressionType.Quote, typeof(Expression<Func<ToT, bool>>))).Expression));
                }
                else
                    toQuery = Where(toEntitySet, new SerializableLambdaExpression(new List<SerializableParameterExpression>() { toParameter }, new SerializableType(typeof(bool)), Contains<ToT>(source.Select(exp).Select(qt).SelectMany(e => e).Expression, toParameter)));
                return CreateAsyncQueryable<ToT>(source.Context, toQuery.Expression, source.ParameterMode);
            }, ref queryTransform);
    }
        
    public static IAsyncQueryable<FromT> IncludeManyToOneMany<FromT, ToT, KeysT>(IAsyncQueryable<FromT> source, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<IEnumerable<ToT>, ToT>> queryTransform, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, ToT> getTo, Func<KeysT, FromT, bool> getFromKey, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : IEntity
        where ToT : class, IEntity
    {
        return IncludeManyToOneMany<FromT, FromT, ToT, KeysT>(source, exp, queryTransform, getKeysQuery, getTo, getFromKey, getTrackableCollection);
    }
        
    public static IAsyncQueryable<FromBaseT> IncludeManyToOneMany<FromBaseT, FromT, ToT, KeysT>(IAsyncQueryable<FromBaseT> source, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<IEnumerable<ToT>, ToT>> queryTransform, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, ToT> getTo, Func<KeysT, FromT, bool> getFromKey, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : FromBaseT
        where FromBaseT : IEntity
        where ToT : class, IEntity
    {
        return Include<FromBaseT, ToT>(source, fromQuery =>
        {
            var include = new AsyncQueryableInclude();
            var fromBaseQueryAsAsyncQueryable = fromQuery as IAsyncQueryable<FromBaseT>;
            IAsyncQueryableBase toQuery;
            Func<object, object[], MergeOption, object> load;
            if (fromBaseQueryAsAsyncQueryable == null)
            {
                toQuery = CreateQuery(qt => CreateOneToOne(((IAsyncQueryableValue<FromBaseT>)fromQuery).RemoveSelectFromSource(), exp, q => q.Select(qt)), queryTransform);
                load = (fromValues, toValues, mergeOption) => IncludeOneOneToMany(fromValues, toValues, mergeOption, getTrackableCollection, true);
                return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery }, Load = load };
            }
            var fromQueryAsAsyncQueryable = fromBaseQueryAsAsyncQueryable.RemoveSelectFromSource().OfType<FromT>();
            toQuery = CreateQuery(qt => CreateAsyncQueryable<ToT>(source.Context, fromQueryAsAsyncQueryable.Select(exp).Select(qt).Expression, source.ParameterMode), ref queryTransform);
            if (queryTransform == null || queryTransform.Body is ParameterExpression)
            {
                string path = ((MemberExpression)exp.Body).Member.Name;
                include.Path = path;
            }
            ToT toT = null;
            var keysQuery = getKeysQuery(fromQueryAsAsyncQueryable, toT);
            var select = (SerializableMethodCallExpression)keysQuery.Expression;
            var selectLambda = (SerializableLambdaExpression)select.Parameters[1];
            var keysCtor = (SerializableConstructorExpression)((SerializableLambdaExpression)select.Parameters[1]).Body;
            var keysCtorToArg = keysCtor.Arguments.Last();
            var expSerializableExpressionReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(expSerializableExpressionReference, source.ParameterMode, source.Context).Visit(exp);
            var expLambda = (SerializableLambdaExpression)expSerializableExpressionReference.Value;
            var queryTransformSerializableExpressionReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(queryTransformSerializableExpressionReference, source.ParameterMode, source.Context).Visit(queryTransform);
            var queryTransformLambdaSerializableExpression = (SerializableLambdaExpression)queryTransformSerializableExpressionReference.Value;
            keysCtorToArg = queryTransformLambdaSerializableExpression.ReplaceBodyParameter(expLambda.ReplaceBodyParameter(selectLambda.Parameters[0]));
            keysCtor.Arguments[keysCtor.Arguments.Count - 1] = keysCtorToArg;
        
            keysQuery = CreateAsyncQueryable<KeysT>(keysQuery.Context, keysQuery.Expression, keysQuery.ParameterMode, toQuery.Includes);
        
            load = (fromValues, toValues, mergeOption) => IncludeManyToOneMany<FromT, ToT, KeysT>(fromValues, toValues, getTo, getFromKey, getTrackableCollection);
            include.Queries = new IAsyncQueryableBase[] { keysQuery };
            include.Load = load;
            return include;
        });
    }
        
    private static object IncludeManyToOneMany<FromT, ToT, KeysT>(object fromValues, object[] toValues, Func<KeysT, ToT> getTo, Func<KeysT, FromT, bool> getFromKey, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
    {
        var keys = ((IEnumerable<object>)toValues[0]).Cast<KeysT>().ToList();
        var froms = ((IEnumerable<object>)fromValues).Cast<FromT>().ToList();
        var tos = new List<ToT>();
        foreach (var key in keys)
        {
            var to = getTo(key);
            if (to != null)
            {
                getTrackableCollection(froms.FirstOrDefault(f => getFromKey(key, f))).Attach(getTo(key));
                tos.Add(to);
            }
        }
        return tos;
    }
        
    public static IAsyncQueryable<FromT> IncludeManyToMany<FromT, ToT, KeysT>(IAsyncQueryable<FromT> source, IAsyncQueryable<ToT> toQuery, Func<IAsyncQueryable<FromT>, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<FromT, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQueryForOne, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : class, IEntity
        where ToT : IEntity
    {
        return IncludeManyToMany<FromT, FromT, ToT, KeysT>(source, toQuery, getKeysQuery, getKeysQueryForOne, fromFkTest, toFkTest, getTrackableCollection);
    }
        
    public static IAsyncQueryable<FromBaseT> IncludeManyToMany<FromBaseT, FromT, ToT, KeysT>(IAsyncQueryable<FromBaseT> source, IAsyncQueryable<ToT> toQuery, Func<IAsyncQueryable<FromT>, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<FromT, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQueryForOne, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : class, FromBaseT
        where FromBaseT : class, IEntity
        where ToT : IEntity
    {
        if (source.Context != toQuery.Context)
            throw new InvalidOperationException();
        return Include<FromBaseT, ToT>(source, fromQuery =>
        {
            var fromBaseQueryAsAsyncQueryable = fromQuery as IAsyncQueryable<FromBaseT>;
            Func<object, object[], MergeOption, object> load;
            IAsyncQueryable<KeysT> keysQuery;
            if (fromBaseQueryAsAsyncQueryable == null)
            {
                keysQuery = CreateOneManyToManyKeysQuery(((IAsyncQueryableValue<FromBaseT>)fromQuery).RemoveSelectFromSource(), toQuery.RemoveSelectFromSource(), getKeysQueryForOne);
                load = (fromValues, toValues, mergeOption) => IncludeOneManyToMany<FromT, ToT, KeysT>(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
            }
            keysQuery = getKeysQuery(fromBaseQueryAsAsyncQueryable.RemoveSelectFromSource().OfType<FromT>(), toQuery.RemoveSelectFromSource());
            load = (fromValues, toValues, mergeOption) => IncludeManyToMany<FromT, ToT, KeysT>(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
            return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
        });
    }
        
    public static IAsyncQueryable<FromT> IncludeManyToOneMany<FromT, ToT, KeysT>(IAsyncQueryable<FromT> source, IAsyncQueryableValue<ToT> toQuery, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : class, IEntity
        where ToT : class, IEntity
    {
        if (source.Context != toQuery.Context)
            throw new InvalidOperationException();
        return Include<FromT, ToT>(source, fromQuery =>
        {
            Func<object, object[], MergeOption, object> load;
            IAsyncQueryableBase keysQuery;
            var fromQueryAsAsyncQueryable = fromQuery as IAsyncQueryable<FromT>;
            if (fromQueryAsAsyncQueryable == null)
            {
                keysQuery = CreateOneManyToOneManyKeysQuery(((IAsyncQueryableValue<FromT>)fromQuery).RemoveSelectFromSource(), toQuery, getKeysQuery);
                load = (fromValues, toValues, mergeOption) => IncludeOneManyToOneMany(fromValues, toValues, getTrackableCollection);
                return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery }, Load = load };
            }
            keysQuery = CreateManyToOneManyKeysQuery(fromQueryAsAsyncQueryable.RemoveSelectFromSource(), toQuery.RemoveSelectFromSource(), getKeysQuery);
            load = (fromValues, toValues, mergeOption) => IncludeOneManyToMany(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
            return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
        });
    }
        
    public static IAsyncQueryableValue<FromT> IncludeOneManyToMany<FromT, ToT, KeysT>(IAsyncQueryableValue<FromT> source, IAsyncQueryable<ToT> toQuery, Func<FromT, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : class, IEntity
        where ToT : IEntity
    {
        if (source.Context != toQuery.Context)
            throw new InvalidOperationException();
        return Include<FromT, ToT>(source, fromQuery =>
            {
                var keysQuery = CreateOneManyToManyKeysQuery(source.RemoveSelectFromSource(), toQuery.RemoveSelectFromSource(), getKeysQuery);
                Func<object, object[], MergeOption, object> load = (fromValues, toValues, mergeOption) => IncludeOneManyToMany(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
            });
    }
        
    public static IAsyncQueryableValue<FromT> IncludeOneManyToOneMany<FromT, ToT, KeysT>(IAsyncQueryableValue<FromT> source, IAsyncQueryableValue<ToT> toQuery, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : class, IEntity
        where ToT : class, IEntity
    {
        if (source.Context != toQuery.Context)
            throw new InvalidOperationException();
        return Include<FromT, ToT>(source, fromQuery =>
            {
                var keysQuery = CreateOneManyToOneManyKeysQuery(source.RemoveSelectFromSource(), toQuery.RemoveSelectFromSource(), getKeysQuery);
                Func<object, object[], MergeOption, object> load = (fromValues, toValues, mergeOption) => IncludeOneManyToOneMany(fromValues, toValues, getTrackableCollection);
                return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
            });
    }
        
    private static IAsyncQueryable<KeysT> CreateOneManyToManyKeysQuery<FromBaseT, FromT, ToT, KeysT>(IAsyncQueryableValue<FromBaseT> fromQuery, IAsyncQueryable<ToT> toQuery, Func<FromT, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQuery)
        where FromT : class, FromBaseT
        where FromBaseT : class, IEntity
        where ToT : IEntity
    {
        FromT fromT = null;
        var keysQuery = getKeysQuery(fromT, toQuery);
        var keysQueryExpression = keysQuery.Expression.ReplaceConstant(constant =>
        {
            if (constant.Value == fromT)
                return new RemoveSelect().Visit(AddOfType<FromBaseT, FromT>(fromQuery));
            return constant;
        });
        return CreateAsyncQueryable<KeysT>(keysQuery.Context, keysQueryExpression, keysQuery.ParameterMode);
    }
        
    private static IAsyncQueryable<KeysT> CreateManyToOneManyKeysQuery<FromT, ToT, KeysT>(IAsyncQueryable<FromT> fromQuery, IAsyncQueryableValue<ToT> toQuery, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery)
        where FromT : IEntity
        where ToT : class, IEntity
    {
        ToT toT = null;
        var keysQuery = getKeysQuery(fromQuery.RemoveSelectFromSource(), toT);
        var keysQueryExpression = keysQuery.Expression.ReplaceConstant(constant =>
        {
            if (constant.Value == toT)
                return toQuery.Expression;
            return constant;
        });
        keysQuery = CreateAsyncQueryable<KeysT>(keysQuery.Context, keysQueryExpression, keysQuery.ParameterMode);
        return keysQuery;
    }
        
    private static IAsyncQueryableValue<KeysT> CreateOneManyToOneManyKeysQuery<FromT, ToT, KeysT>(IAsyncQueryableValue<FromT> fromQuery, IAsyncQueryableValue<ToT> toQuery, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery)
        where FromT : class, IEntity
        where ToT : class, IEntity
    {
        fromQuery = fromQuery.RemoveSelectFromSource();
        MethodInfo method;
        var fromQueryAsAsyncQueryable = CreateToOne<FromT>(fromQuery, (SerializableMethodCallExpression)fromQuery.Expression, out method);
        ToT toT = null;
        var keysQuery = getKeysQuery(CreateAsyncQueryable<FromT>(fromQuery.Context, fromQueryAsAsyncQueryable.Expression, fromQuery.ParameterMode), toT);
        var keysQueryExpression = keysQuery.Expression.ReplaceConstant(constant =>
        {
            if (constant.Value == toT)
                return toQuery.Expression;
            return constant;
        });
        return CreateAsyncQueryableValue<KeysT>(keysQuery.Context, new SerializableMethodCallExpression(null, new[] { keysQueryExpression }, method.MakeGenericMethod(typeof(KeysT))), keysQuery.ParameterMode);
    }
        
    private static object IncludeManyToMany<FromT, ToT, KeysT>(object fromValues, object[] toValues, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
    {
        var froms = ((IEnumerable<object>)fromValues).Cast<FromT>().ToList();
        var tos = ((IEnumerable<object>)toValues[0]).Cast<ToT>().ToList();
        var keys = ((IEnumerable<object>)toValues[1]).Cast<KeysT>();
        foreach (var key in keys)
        {
            FromT fromValue = froms.FirstOrDefault(f => fromFkTest(key, f));
            ToT toValue;
            if (fromValue != null && (toValue = tos.FirstOrDefault(t => toFkTest(key, t))) != null)
                getTrackableCollection(fromValue).Attach(toValue);
        }
        return tos;
    }
        
    private static object IncludeManyToOneManyTask<FromT, ToT, KeysT>(object fromValues, object[] toValues, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
    {
        var froms = ((IEnumerable<object>)fromValues).Cast<FromT>().ToList();
        var to = (ToT)toValues[0];
        var keys = ((IEnumerable<object>)toValues[1]).Cast<KeysT>();
        foreach (var key in keys)
        {
            var @from = froms.FirstOrDefault(f => fromFkTest(key, f));
            if (@from != null && toFkTest(key, to))
                getTrackableCollection(@from).Attach(to);
        }
        return to;
    }
        
    private static object IncludeOneManyToMany<FromT, ToT, KeysT>(object fromValues, object[] toValues, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
    {
        var @from = (FromT)fromValues;
        var tos = ((IEnumerable<object>)toValues[0]).Cast<ToT>().ToList();
        var keys = ((IEnumerable<object>)toValues[1]).Cast<KeysT>();
        foreach (var key in keys)
        {
            var toValue = tos.FirstOrDefault(t => toFkTest(key, t));
            if (toValue != null && fromFkTest(key, @from))
                getTrackableCollection(@from).Attach(toValue);
        }
        return tos;
    }
        
    private static object IncludeOneManyToOneMany<FromT, ToT>(object fromValues, object[] toValues, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
    {
        var fromValue = (FromT)fromValues;
        var toValue = (ToT)toValues[0];
        getTrackableCollection(fromValue).Attach(toValue);
        return toValue;
    }
        
    public static IAsyncQueryableValue<IEnumerable<FromT>> IncludeManyOneToOne<FromT, ToT>(IAsyncQueryableValue<IEnumerable<FromT>> source, Expression<Func<FromT, ToT>> exp, Expression<Func<ToT, ToT>> queryTransform, Func<FromT, ToT, bool> fkTest, Action<FromT, ToT> setTo)
        where FromT : IEntity
        where ToT : IEntity
    {
        return IncludeManyOneToOne<FromT, FromT, ToT>(source, exp, queryTransform, fkTest, setTo);
    }
        
    public static IAsyncQueryableValue<IEnumerable<FromBaseT>> IncludeManyOneToOne<FromBaseT, FromT, ToT>(IAsyncQueryableValue<IEnumerable<FromBaseT>> source, Expression<Func<FromT, ToT>> exp, Expression<Func<ToT, ToT>> queryTransform, Func<FromT, ToT, bool> fkTest, Action<FromT, ToT> setTo)
        where FromT : FromBaseT
        where FromBaseT : IEntity
        where ToT : IEntity
    {
        return Include<IEnumerable<FromBaseT>, ToT>(source, fromQuery =>
        {
            var include = new AsyncQueryableInclude();
            var toQuery = CreateManyOneToOne(((IAsyncQueryableValue<IEnumerable<FromBaseT>>)source).RemoveSelectFromSource(), exp, ref queryTransform);
            if (queryTransform == null || queryTransform.Body is ParameterExpression)
            {
                string path = ((MemberExpression)exp.Body).Member.Name;
                include.Path = path;
            }
            Func<object, object[], MergeOption, object> load = (fromValues, toValues, mergeOption) => IncludeManyOneToOne(fromValues, toValues, mergeOption, fkTest, setTo);
            include.Queries = new IAsyncQueryableBase[] { toQuery };
            include.Load = load;
            return include;
        });
    }
        
    private static IAsyncQueryableValue<IEnumerable<ToT>> CreateManyOneToOne<FromBaseT, FromT, ToT>(IAsyncQueryableValue<IEnumerable<FromBaseT>> source, Expression<Func<FromT, ToT>> exp, ref Expression<Func<ToT, ToT>> queryTransform)
        where FromT : FromBaseT
    {
        source = source.RemoveSelectFromSource();
        return CreateQuery(qt =>
        {
            if (qt == null)
                qt = e => e;
            var serializableMethodCallExpression = (SerializableMethodCallExpression)source.Expression;
            MethodInfo method;
            var baseQuery = CreateToOne<IEnumerable<FromBaseT>>(source, serializableMethodCallExpression, out method).Select(fs => fs.OfType<FromT>());
            var selectParameter = Expression.Parameter(typeof(IEnumerable<FromT>), "e" + Guid.NewGuid().ToString("N"));
            var expTo = Expression.Lambda<Func<FromT, ToT>>(qt.ReplaceBodyParameter(exp.Body), exp.Parameters[0]);
            var manyQuery = baseQuery.Select(Expression.Lambda<Func<IEnumerable<FromT>, IEnumerable<ToT>>>(Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Distinct" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(ToT)), Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Select" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2).MakeGenericMethod(typeof(FromT), typeof(ToT)), selectParameter, expTo)), selectParameter));
            return CreateAsyncQueryableValue<IEnumerable<ToT>>(source.Context, new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { manyQuery.Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(IEnumerable<ToT>))), source.ParameterMode);
        }, ref queryTransform);
    }
        
    private static object IncludeManyOneToOne<FromT, ToT>(object fromValues, object[] toValues, MergeOption mergeOption, Func<FromT, ToT, bool> fkTest, Action<FromT, ToT> setTo)
        where FromT : IEntity
        where ToT : IEntity
    {
		var tos = ((IEnumerable<object>)toValues).Cast<ToT>();
		var froms = ((IEnumerable<object>)fromValues).Cast<FromT>();
		if (mergeOption == MergeOption.NoTracking)
		{
			var fromsArray = froms.ToArray();
			var tosArray = ((IEnumerable<object>)toValues[0]).Cast<ToT>().ToArray();
			foreach (var from in fromsArray)
			{
				for (int i = 0; i < tosArray.Length; i++)
				{
					if (tosArray[i] != null && fkTest(from, tosArray[i]))
					{
						tosArray[i].IsInitializingRelationships = true;
						setTo(from, tosArray[i]);
						tosArray[i].IsInitializingRelationships = false;
					}
				}
			}
		}

		return tos;
    }
        
    private static IAsyncQueryable<T> RemoveSelectFromSource<T>(this IAsyncQueryable<T> source)
    {
        if (source == null)
            return null;
        return CreateAsyncQueryable<T>(source.Context, new RemoveSelect().Visit(source.Expression), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    private static IAsyncQueryableValue<T> RemoveSelectFromSource<T>(this IAsyncQueryableValue<T> source)
    {
        if (source == null)
            return null;
        return CreateAsyncQueryableValue<T>(source.Context, new RemoveSelect().Visit(source.Expression), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> CreateAsyncQueryable<TSource>(IClientContextBase context, SerializableExpression expression, ParameterMode parameterMode, IEnumerable<Func<IAsyncQueryableBase, AsyncQueryableInclude>> includes = null, IEnumerable<string> withSpecificationsProperties = null, IEnumerable<string> selectedProperties = null)
    {
        return new AsyncQueryable<TSource>(context, expression, parameterMode, includes, withSpecificationsProperties, selectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> CreateAsyncQueryableValue<TSource>(IClientContextBase context, SerializableExpression expression, ParameterMode parameterMode, IEnumerable<Func<IAsyncQueryableBase, AsyncQueryableInclude>> includes = null, IEnumerable<string> withSpecificationsProperties = null, IEnumerable<string> selectedProperties = null)
    {
        return new AsyncQueryableValue<TSource>(context, expression, parameterMode, includes, withSpecificationsProperties, selectedProperties);
    }
        
    public static IAsyncQueryable<QueryT> ReplaceType<QueryT, OldT, NewT>(this IAsyncQueryable<QueryT> query)
    {
        return ReplaceType<QueryT, QueryT, OldT, NewT>(query);
    }
        
    public static IAsyncQueryable<NewT> ReplaceType<OldT, NewT>(this IAsyncQueryable<OldT> query)
    {
        return ReplaceType<OldT, NewT, OldT, NewT>(query);
    }
        
    public static IAsyncQueryable<NewT> ReplaceType<OldT, NewT>(this IAsyncQueryable<NewT> query)
    {
        return ReplaceType<NewT, NewT, OldT, NewT>(query);
    }
        
    private static IAsyncQueryable<NewQueryT> ReplaceType<OldQueryT, NewQueryT, OldT, NewT>(IAsyncQueryable<OldQueryT> query)
    {
        return CreateAsyncQueryable<NewQueryT>(query.Context, new ReplaceTypeRewriter<OldT, NewT>().Visit(query.Expression), query.ParameterMode, query.Includes, query.WithSpecificationsProperties, query.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<QueryT> ReplaceType<QueryT, OldT, NewT>(this IAsyncQueryableValue<QueryT> query)
    {
        return ReplaceType<QueryT, QueryT, OldT, NewT>(query);
    }
        
    public static IAsyncQueryableValue<NewT> ReplaceType<OldT, NewT>(this IAsyncQueryableValue<OldT> query)
    {
        return ReplaceType<OldT, NewT, OldT, NewT>(query);
    }
        
    public static IAsyncQueryableValue<NewT> ReplaceType<OldT, NewT>(this IAsyncQueryableValue<NewT> query)
    {
        return ReplaceType<NewT, NewT, OldT, NewT>(query);
    }
        
    private static IAsyncQueryableValue<NewQueryT> ReplaceType<OldQueryT, NewQueryT, OldT, NewT>(IAsyncQueryableValue<OldQueryT> query)
    {
        return CreateAsyncQueryableValue<NewQueryT>(query.Context, new ReplaceTypeRewriter<OldT, NewT>().Visit(query.Expression), query.ParameterMode, query.Includes, query.WithSpecificationsProperties, query.SelectedProperties);
    }
        
    public static T AsObject<T>(this IAsyncQueryableValue<T> asyncQueryableValue)
    {
        throw new InvalidOperationException("This method could only be used inside a LINQ To WAQS expression");
    }
        
    private class RemoveSelect : SerializableExpressionRewriter
    {
        protected internal override SerializableExpression VisitMethodCall(SerializableMethodCallExpression expression)
        {
            if (expression.MemberName == "Select" && expression.GenericArguments.Count == 2 && expression.GenericArguments[0].Type == expression.GenericArguments[1].Type && new[] { typeof(Queryable), typeof(Enumerable) }.Contains(expression.Method.DeclaringType))
            {
                var lambda = (SerializableLambdaExpression)expression.Parameters[1];
                var serializableMemberInit = lambda.Body as SerializableMemberInitExpression;
                if (serializableMemberInit != null && serializableMemberInit.Setters.All(s =>
                    {
                        var propGet = s.Value as SerializablePropertyGetterExpression;
                        return propGet != null && propGet.Source == lambda.Parameters[0] && propGet.MemberName == s.MemberName;
                    }))
                    return expression.Parameters[0];
            }
            return base.VisitMethodCall(expression);
        }
    }
}
<#+
WriteFooter(expressionNamespace);

fileManager.StartNewFile("AsyncQueryableBase.cs");
WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Linq", "System.Threading.Tasks", expressionNamespace, clientFxClientContextInterfacesNamespace);
#>
internal abstract class AsyncQueryableBase : IAsyncQueryableBase
{
    public AsyncQueryableBase(IClientContextBase context, SerializableExpression expression, ParameterMode parameterMode, IEnumerable<Func<IAsyncQueryableBase, AsyncQueryableInclude>> includes, IEnumerable<string> withSpecificationsProperties, IEnumerable<string> selectedProperties)
    {
        Context = context;
        Expression = expression;
        ParameterMode = parameterMode;
        Includes = includes ?? Enumerable.Empty<Func<IAsyncQueryableBase, AsyncQueryableInclude>>();
        WithSpecificationsProperties = withSpecificationsProperties ?? Enumerable.Empty<string>();
        SelectedProperties = selectedProperties ?? Enumerable.Empty<string>();
    }
    
    public IClientContextBase Context { get; private set; }
    public SerializableExpression Expression { get; private set; }
    public ParameterMode ParameterMode { get; private set; }
    public abstract Type Type { get; }
    public IEnumerable<Func<IAsyncQueryableBase, AsyncQueryableInclude>> Includes { get; private set; }
    public IEnumerable<string> WithSpecificationsProperties { get; private set; }
    public IEnumerable<string> SelectedProperties { get; private set; }
}
<#+
WriteFooter(namespaceName);

fileManager.StartNewFile("AsyncQueryable.cs");
WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Threading.Tasks", expressionNamespace, clientFxClientContextInterfacesNamespace, clientFxClientContextInterfacesNamespace + ".Querying");
#>
internal class AsyncQueryable<T> : AsyncQueryableBase, IAsyncQueryable<T>
{
    public AsyncQueryable(IClientContextBase context, SerializableExpression expression, ParameterMode parameterMode, IEnumerable<Func<IAsyncQueryableBase, AsyncQueryableInclude>> includes = null, IEnumerable<string> withSpecificationsProperties = null, IEnumerable<string> selectedProperties = null)
        : base(context, expression, parameterMode, includes, withSpecificationsProperties, selectedProperties)
    {
    }

    public async Task<IEnumerable<T>> Execute<#=asyncSuffix#>(MergeOption? mergeOption = null, Func<bool> cancel = null)
    {
        return await Context.ExecuteQuery<#=asyncSuffix#><T>(this, mergeOption, cancel);
    }

    public async Task<QueryPage<T>> LoadPage<#=asyncSuffix#>(int pageSize, params LoadPageParameter[] identifiers)
    {
        return await LoadPageInternal<#=asyncSuffix#>(pageSize, null, identifiers, null);
    }

    public async Task<QueryPage<T>> LoadPage<#=asyncSuffix#>(int pageSize, Func<bool> cancel, params LoadPageParameter[] identifiers)
    {
        return await LoadPageInternal<#=asyncSuffix#>(pageSize, null, identifiers, cancel);
    }

    public async Task<QueryPage<T>> LoadPage<#=asyncSuffix#>(int pageSize, MergeOption? mergeOption, params LoadPageParameter[] identifiers)
    {
        return await LoadPageInternal<#=asyncSuffix#>(pageSize, mergeOption, identifiers, null);
    }

    public async Task<QueryPage<T>> LoadPage<#=asyncSuffix#>(int pageSize, MergeOption? mergeOption, Func<bool> cancel, params LoadPageParameter[] identifiers)
    {
        return await LoadPageInternal<#=asyncSuffix#>(pageSize, mergeOption, identifiers, cancel);
    }

    private async Task<QueryPage<T>> LoadPageInternal<#=asyncSuffix#>(int pageSize, MergeOption? mergeOption, LoadPageParameter[] identifiers, Func<bool> cancel)
    {
        return await Context.LoadPage<#=asyncSuffix#><T>(pageSize, this, identifiers, mergeOption, cancel);
    }

    public async Task<IEnumerable<T>> LoadPage<#=asyncSuffix#>(int pageSize, int pageIndex, MergeOption? mergeOption, Func<bool> cancel = null)
    {
        return await Context.LoadPage<#=asyncSuffix#>(pageSize, this.Skip(pageIndex * pageSize).Take(pageSize), null, mergeOption, cancel);
    }

    public override Type Type
    {
        get { return typeof(T); }
    }
}
<#+
WriteFooter(namespaceName);

fileManager.StartNewFile("AsyncQueryableValue.cs");
WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Threading.Tasks", expressionNamespace, clientFxClientContextInterfacesNamespace);
#>
internal class AsyncQueryableValue<T> : AsyncQueryableBase, IAsyncQueryableValue<T>
{
    public AsyncQueryableValue(IClientContextBase context, SerializableExpression expression, ParameterMode parameterMode, IEnumerable<Func<IAsyncQueryableBase, AsyncQueryableInclude>> includes = null, IEnumerable<string> withSpecificationsProperties = null, IEnumerable<string> selectedProperties = null)
        : base(context, expression, parameterMode, includes, withSpecificationsProperties, selectedProperties)
    {
    }

    public async Task<T> Execute<#=asyncSuffix#>(MergeOption? mergeOption = null, Func<bool> cancel = null)
    {
        return await Context.ExecuteQuery<#=asyncSuffix#><T>(this, mergeOption, cancel);
    }

    public override Type Type
    {
        get { return typeof(T); }
    }
}
<#+
WriteFooter(namespaceName);

fileManager.StartNewFile("RefreshMode.cs");
WriteHeader(namespaceName, code);
#>
public enum RefreshMode
{
    Client,
    Server
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("ClientEntitySetExtensions.cs");
    var usings = new List<string>() { "System", "System.Collections.Generic", "System.Linq", clientFxEntitiesTrackingNamespace, expressionNamespace, clientFxClientContextInterfacesNamespace };
    AddClientEntitySetExtensionsUsings(usings);
    WriteHeader(namespaceName, code, usings.ToArray());
    string concurrentDictionary = GetConcurrentDictionary();
    bool concurrentDictionaryTry = GetConcurrentDictionaryTry();
#>
public static partial class ClientEntitySetExtensions
{
    public static IAsyncQueryable<TSource> AsAsyncQueryable<TContext, TSource>(this IClientEntitySet<TContext, TSource> entitySet)
        where TContext : class, IClientContext
        where TSource : IObjectWithChangeTracker
    {
        return AsAsyncQueryable(entitySet, ParameterMode.OnDefinition);
    }
    public static IAsyncQueryable<TSource> AsAsyncQueryable<TContext, TSource>(this IClientEntitySet<TContext, TSource> entitySet, ParameterMode parameterMode)
        where TContext : class, IClientContext
        where TSource : IObjectWithChangeTracker
    {
        return new AsyncQueryable<TSource>(entitySet.Context, entitySet.Expression, parameterMode);
    }

    private static <#=concurrentDictionary#><Type, <#=concurrentDictionary#><int, WeakReference>> _entitySetPerEntity = new <#=concurrentDictionary#><Type, <#=concurrentDictionary#><int, WeakReference>>();
        
    public static bool AddEntityInDico(IClientEntitySet entitySet, IObjectWithChangeTracker entity)
    {
        if (entity == null)
            return false;
        int entityHashCode = entity.GetHashCode();
        <#=concurrentDictionary#><int, WeakReference> entitySetPerEntityForEntityType;
        var entityType = entity.GetType();
        if (!_entitySetPerEntity.TryGetValue(entityType, out entitySetPerEntityForEntityType))
        {
            entitySetPerEntityForEntityType = new <#=concurrentDictionary#><int, WeakReference>();
            entitySetPerEntityForEntityType.<#=concurrentDictionaryTry ? "Try" : ""#>Add(entityHashCode, new WeakReference(entitySet));
            _entitySetPerEntity.<#=concurrentDictionaryTry ? "Try" : ""#>Add(entityType, entitySetPerEntityForEntityType);
            return true;
        }
        WeakReference entitySetInDico = null;
        if (entitySetPerEntityForEntityType.TryGetValue(entityHashCode, out entitySetInDico))
        {
            if (!entitySetInDico.IsAlive)
            {
<#+
        if (concurrentDictionaryTry)
        {
#>
                WeakReference _;
<#+
        }
#>
                entitySetPerEntityForEntityType.<#=concurrentDictionaryTry ? "Try" : ""#>Remove(entityHashCode<#=concurrentDictionaryTry ? ", out _" : ""#>);
            }
            else
            {
                if (entitySetInDico.Target != entitySet)
                    throw new InvalidOperationException("An entity can be attached only on one context");
                return false;
            }
        }
        entitySetPerEntityForEntityType.<#=concurrentDictionaryTry ? "Try" : ""#>Add(entityHashCode, new WeakReference(entitySet));
        return true;
    }
        
    public static IClientEntitySet GetClientEntitySet(IObjectWithChangeTracker entity)
    {
        <#=concurrentDictionary#><int, WeakReference> entitySetPerEntityForEntityType;
        if (!_entitySetPerEntity.TryGetValue(entity.GetType(), out entitySetPerEntityForEntityType))
            return null;
        WeakReference value = null;
        if (entitySetPerEntityForEntityType.TryGetValue(entity.GetHashCode(), out value) && value.IsAlive)
            return (IClientEntitySet)value.Target;
        return null;
    }
        
    public static void RemoveEntityInDico(IObjectWithChangeTracker entity)
    {
        <#=concurrentDictionary#><int, WeakReference> entitySetPerEntityForEntityType;
        if (!_entitySetPerEntity.TryGetValue(entity.GetType(), out entitySetPerEntityForEntityType))
            return;
<#+
        if (concurrentDictionaryTry)
        {
#>
        WeakReference _;
<#+
        }
#>
        entitySetPerEntityForEntityType.<#=concurrentDictionaryTry ? "Try" : ""#>Remove(entity.GetHashCode()<#=concurrentDictionaryTry ? ", out _" : ""#>);
    }
        
    public static void ClearDico(IClientContext context)
    {
        foreach (var entitySetPerEntityForEntityType in _entitySetPerEntity.Values)
            foreach (var e in entitySetPerEntityForEntityType.Where(kv => !kv.Value.IsAlive || ((IClientEntitySet)kv.Value.Target).Context == context).Select(kv => kv.Key).ToList())
            {
<#+
        if (concurrentDictionaryTry)
        {
#>
                WeakReference _;
<#+
        }
#>
                entitySetPerEntityForEntityType.<#=concurrentDictionaryTry ? "Try" : ""#>Remove(e<#=concurrentDictionaryTry ? ", out _" : ""#>);
            }
    }
    
    public static bool Contains<ClientContext, EntityType>(ClientEntitySet<ClientContext, EntityType> entitySet, EntityType entity)
        where ClientContext : class, IClientContext
        where EntityType : class, IObjectWithChangeTracker
    {
        return entitySet.EntitiesContains(entity);
    }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("QueryResult.cs");
    string queryResultNamespace = namespaceName + ".QueryResult";
    WriteHeader(queryResultNamespace, code, "System.Collections.Generic", "System.Runtime.Serialization");
#>
[DataContract(Namespace = "http://WAQS/QueryResult")]
public class QueryResult
{
    [DataMember]
    public List<QueryResultRecord> Records { get; set; }

    [DataMember]
    public QueryResultRecord Record { get; set; }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("QueryResultRecord.cs");
    WriteHeader(queryResultNamespace, code, "System.Collections.Generic", "System.Runtime.Serialization");
#>
[DataContract(Namespace = "http://WAQS/QueryResult")]
public class QueryResultRecord
{
    [DataMember]
    public List<QueryResultProperty> Properties { get; set; }
    
    [DataMember]
    public string SerializedValue { get; set; }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("QueryResultProperty.cs");
    WriteHeader(queryResultNamespace, code, "System.Collections.Generic", "System.Runtime.Serialization");
#>
[DataContract(Namespace = "http://WAQS/QueryResult")]
public class QueryResultProperty
{
    [DataMember]
    public string PropertyName { get; set; }

    [DataMember]
    public string SerializedValue { get; set; }

    [DataMember]
    public QueryResultRecord Value { get; set; }

    [DataMember]
    public List<QueryResultRecord> Values { get; set; } 
}
<#+
    WriteFooter(queryResultNamespace);

    fileManager.StartNewFile("QueryPage.cs");
    WriteHeader(namespaceName, code, "System.Collections", "System.Collections.Generic");
#>
public class QueryPage<T> : IEnumerable<T>
{
    private IEnumerable<T> _enumerable;

    public QueryPage(int pageIndex, IEnumerable<T> enumerable)
    {
        PageIndex = pageIndex;
        _enumerable = enumerable;
    }

    public int PageIndex { get; private set; }

    public IEnumerator<T> GetEnumerator()
    {
        return _enumerable.GetEnumerator();
    }
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
<#+
    WriteFooter(namespaceName);

    string faultNamespace = namespaceName + ".Fault";
    fileManager.StartNewFile("FaultDetail.cs");
    WriteHeader(faultNamespace, code, "System.Runtime.Serialization", "System.ServiceModel");
#>
[DataContract(Namespace = "http://WAQS/Fault")]
public partial class FaultDetail
{
    [DataMember]
    public string ErrorType { get; set; }

    [DataMember]
    public string ErrorMessage { get; set; }
}
<#+
    WriteFooter(faultNamespace);

    fileManager.StartNewFile("ErrorCollection.cs");
    WriteHeader(faultNamespace, code, "System.Runtime.Serialization", clientFxClientContextInterfacesNamespace + ".Errors");
#>
[DataContract(Namespace = "http://WAQS/Fault")]
public class ErrorCollection
{
    [DataMember]
    public Error[] Errors { get; set; }
}
<#+
    WriteFooter(faultNamespace);

    fileManager.StartNewFile("ParameterMode.cs");
    WriteHeader(namespaceName, code);
#>
public enum ParameterMode
{
    OnDefinition,
    OnExecution
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("Grouping.cs");
    WriteHeader(namespaceName, code, "System.Collections", "System.Collections.Generic", "System.Linq");
#>
public class Grouping<TKey, TElement> : IGrouping<TKey, TElement>
{
    public Grouping(TKey key, List<TElement> elements)
    {
        Key = key;
        _elements = elements;
    }

    private List<TElement> _elements;
    private List<TElement> Elements
    {
        get { return _elements ?? (_elements = new List<TElement>()); }
    }

    public TKey Key { get; set; }

    public IEnumerator<TElement> GetEnumerator()
    {
        return Elements.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("IncludeMethodAttribute.cs");
    WriteHeader(namespaceName, code, "System");
#>
public class IncludeMethodAttribute : Attribute
{
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("Reference.cs");
    WriteHeader(namespaceName, code);
#>
public class Reference<T>
{
    public Reference()
    {
    }
    public Reference(T value)
    {
        Value = value;
    }
    public T Value { get; set; }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("IncludeExpressionVisitor.cs");
    WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Linq", "System.Linq.Expressions", "System.Reflection", clientFxEntitiesTrackingNamespace, clientFxClientContextInterfacesNamespace);
#>
public class IncludeExpressionVisitor<QueryType> : <#=expressionVisitorNamespace == null ? "" : expressionVisitorNamespace + "."#>ExpressionVisitor
{
    private List<Func<IAsyncQueryableBase, QueryType>> _includeActions = new List<Func<IAsyncQueryableBase, QueryType>>();
        
    public IEnumerable<Func<IAsyncQueryableBase, QueryType>> IncludeActions
    {
        get { return _includeActions; }
    }
        
    protected override Expression VisitMethodCall(MethodCallExpression node)
    {
        if (node.Method.GetCustomAttributes(false).OfType<IncludeMethodAttribute>().Any())
        {
            MethodInfo method = node.Method;
            List<Expression> parameters = null;
            var queryParameter = Expression.Parameter(typeof(IAsyncQueryableBase), "p" + Guid.NewGuid().ToString());

            var includeMethod = method.DeclaringType.GetMethods(BindingFlags.Public | BindingFlags.Static).FirstOrDefault(m =>
                {
                    var parametersLoop = new List<Expression>();
                    if (m.Name != method.Name)
                        return false;
                    var methodParametersEnumerator = method.GetParameters().Cast<ParameterInfo>().GetEnumerator();
                    var mParametersEnumerator = m.GetParameters().Cast<ParameterInfo>().GetEnumerator();
                    var nodeArgumentsEnumerator = node.Arguments.GetEnumerator();
                    int parameterIndex = 0;
                    while (methodParametersEnumerator.MoveNext())
                    {
                        nodeArgumentsEnumerator.MoveNext();
                        if (!mParametersEnumerator.MoveNext())
                            return false;
                        var methodParameterType = methodParametersEnumerator.Current.ParameterType;
                        var mParameterType = mParametersEnumerator.Current.ParameterType;
                        if (parameterIndex == 0)
                        {
                            parameterIndex++;
                            if (methodParameterType.IsGenericType && methodParameterType.GetGenericTypeDefinition() == typeof(IEnumerable<>) || !methodParameterType.IsGenericType && typeof(IEntity).IsAssignableFrom(methodParameterType))
                            {
                                if (mParameterType == typeof(QueryType))
                                    parametersLoop.Add(Expression.Convert(queryParameter, typeof(QueryType)));
                                else
                                    return false;
                            }
                            else
                                return false;
                        }
                        else if (methodParameterType == mParameterType)
                            parametersLoop.Add(nodeArgumentsEnumerator.Current);
                        else
                            return false;
                    }
                    if (mParametersEnumerator.MoveNext())
                        return false;
                    parameters = parametersLoop;
                    return true;
                });

            if (includeMethod == null)
            {
                if (typeof(IAsyncQueryableValue).IsAssignableFrom(typeof(QueryType)))
                    throw new NotImplementedException("Not implemented yet. Use Take(1) instead of First or Single");
                throw new NotImplementedException();
            }
        
            _includeActions.Add(Expression.Lambda<Func<IAsyncQueryableBase, QueryType>>(
                <#=ExpressionCall("includeMethod", "parameters")#>, queryParameter).Compile());
            return Visit(node.Arguments[0]);
        }
        return base.VisitMethodCall(node);
    }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("SerializableExpressionExtension.cs");
    WriteHeader(namespaceName, code, "System", expressionNamespace, clientFxClientContextInterfacesNamespace);
#>
public static class SerializableExpressionExtension
{
    public static SerializableExpression ReplaceParameter(this SerializableExpression expression, SerializableParameterExpression parameter, SerializableExpression replace)
    {
        return ReplaceParameter(expression, n => n == parameter ? replace : n);
    }

    public static SerializableExpression ReplaceParameter(this SerializableExpression expression, Func<SerializableParameterExpression, SerializableExpression> replace)
    {
        return new SerializableExpressionReplaceRewriter { ReplaceParameterFunc = replace }.Visit(expression);
    }

    public static SerializableExpression ReplaceBodyParameter(this SerializableLambdaExpression expression, SerializableExpression replace)
    {
        return ReplaceParameter(expression.Body, n => n == expression.Parameters[0] ? replace : n);
    }

    public static SerializableExpression ReplaceConstant(this SerializableExpression expression, SerializableConstantExpression constant, SerializableExpression replace)
    {
        return ReplaceConstant(expression, n => n == constant ? replace : n);
    }

    public static SerializableExpression ReplaceConstant(this SerializableExpression expression, Func<SerializableConstantExpression, SerializableExpression> replace)
    {
        return new SerializableExpressionReplaceRewriter { ReplaceConstantFunc = replace }.Visit(expression);
    }
                
    public class SerializableExpressionReplaceRewriter : SerializableExpressionRewriter
    {
        internal Func<SerializableParameterExpression, SerializableExpression> ReplaceParameterFunc { get; set; }
        protected internal override SerializableExpression VisitParameter(SerializableParameterExpression node)
        {
            if (ReplaceParameterFunc != null)
            {
                var value = ReplaceParameterFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitParameter(node);
        }

        internal Func<SerializableConstantExpression, SerializableExpression> ReplaceConstantFunc { get; set; }
        protected internal override SerializableExpression VisitConstant(SerializableConstantExpression node)
        {
            if (ReplaceConstantFunc != null)
            {
                var value = ReplaceConstantFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitConstant(node);
        }
    }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("ReplaceTypeRewriter.cs");
    WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Linq", "System.Reflection", expressionNamespace);
#>
public class ReplaceTypeRewriter<OldT, NewT> : SerializableExpressionRewriter
{
    protected internal override SerializableExpression VisitConditional(SerializableConditionalExpression expression)
    {
        Type newType = ReplaceType(expression.Type.Type);
        if (newType != expression.Type.Type)
            return new SerializableConditionalExpression(Visit(expression.TestExpression), Visit(expression.IfTrueExpression), Visit(expression.IfFalseExpression), new SerializableType(newType));
        return base.VisitConditional(expression);
    }

    protected internal override SerializableExpression VisitConstant(SerializableConstantExpression expression)
    {
        Type newType = ReplaceType(expression.Type.Type);
        if (newType != expression.Type.Type)
        {
            if (expression.Delegate != null)
                return new SerializableConstantExpression(expression.Delegate, newType);
            return new SerializableConstantExpression(expression.Value, newType);
        }
        return base.VisitConstant(expression);
    }

    protected internal override SerializableExpression VisitConstructor(SerializableConstructorExpression expression)
    {
        bool argumentTypeChanged = false;
        var argumentTypes = new List<SerializableType>(expression.ArgumentTypes);
        Type newType;
        for (int argumentTypeIndex = 0; argumentTypeIndex < argumentTypes.Count; argumentTypeIndex++)
            if ((newType = ReplaceType(argumentTypes[argumentTypeIndex].Type)) != argumentTypes[argumentTypeIndex].Type)
            {
                argumentTypes[argumentTypeIndex] = new SerializableType(newType);
                argumentTypeChanged = true;
            }
        if ((newType = ReplaceType(expression.Type.Type)) != expression.Type.Type || argumentTypeChanged)
            return new SerializableConstructorExpression(new SerializableType(newType), argumentTypes, expression.Arguments.Select(a => Visit(a)).ToList());
        return base.VisitConstructor(expression);
    }

    protected internal override SerializableExpression VisitLambda(SerializableLambdaExpression expression)
    {
        Type newType = ReplaceType(expression.ReturnType.Type);
        if (newType != expression.ReturnType.Type)
            return new SerializableLambdaExpression(expression.Parameters.Select(p => (SerializableParameterExpression)Visit(p)).ToList(), new SerializableType(newType), Visit(expression.Body));
        return base.VisitLambda(expression);
    }

    protected internal override SerializableExpression VisitPropertyGetter(SerializablePropertyGetterExpression expression)
    {
        Type newType = ReplaceType(expression.MemberDeclaringType.Type);
        if (newType != expression.MemberDeclaringType.Type)
            return new SerializablePropertyGetterExpression(Visit(expression.Source), newType.GetProperty(expression.Property.Name));
        return base.VisitPropertyGetter(expression);
    }

    protected internal override SerializableExpression VisitPropertySetter(SerializablePropertySetterExpression expression)
    {
        Type newType = ReplaceType(expression.MemberDeclaringType.Type);
        if (newType != expression.MemberDeclaringType.Type)
            return new SerializablePropertySetterExpression(Visit(expression.Source), newType.GetProperty(expression.Property.Name), Visit(expression.Value));
        return base.VisitPropertySetter(expression);
    }

    protected internal override SerializableExpression VisitMethodCall(SerializableMethodCallExpression expression)
    {
        Type newType = ReplaceType(expression.MemberDeclaringType.Type);
        MethodInfo method;
        if (newType == expression.MemberDeclaringType.Type)
        {
            method = expression.Method;
            if (!method.IsGenericMethod)
                return base.VisitMethodCall(expression);
            method = method.GetGenericMethodDefinition();
        }
        else
            method = newType.GetMethod(expression.Method.Name, expression.Method.GetParameters().Select(p => ReplaceType(p.ParameterType)).ToArray());
        if (method.IsGenericMethod)
            method = method.MakeGenericMethod(expression.GenericArguments.Select(ga => ReplaceType(ga.Type)).ToArray());
        return new SerializableMethodCallExpression(Visit(expression.Source), expression.Parameters.Select(p => Visit(p)), method);
    }

    protected internal override SerializableExpression VisitParameter(SerializableParameterExpression expression)
    {
        Type newType = ReplaceType(expression.Type.Type);
        if (newType != expression.Type.Type)
            return new SerializableParameterExpression { Name = expression.Name, Type = new SerializableType(newType) };
        return base.VisitParameter(expression);
    }

    protected internal override SerializableExpression VisitUnary(SerializableUnaryExpression expression)
    {
        Type newType = ReplaceType(expression.Type.Type);
        if (newType != expression.Type.Type)
            return new SerializableUnaryExpression(expression.Operand, expression.NodeType, new SerializableType(newType));
        return base.VisitUnary(expression);
    }

    protected internal override SerializableExpression VisitTypeBinary(SerializableTypeBinaryExpression expression)
    {
        Type newType = ReplaceType(expression.TypeOperand.Type);
        if (newType != expression.TypeOperand.Type)
            return new SerializableTypeBinaryExpression(expression.Expression, expression.NodeType, new SerializableType(newType));
        return base.VisitTypeBinary(expression);
    }

    private static Type ReplaceType(Type type)
    {
        if (type == typeof(OldT))
            return typeof(NewT);
        if (type.IsGenericType)
            return type.GetGenericTypeDefinition().MakeGenericType(type.GetGenericArguments().Select(t => ReplaceType(t)).ToArray());
        return type;
    }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("PaginatedQuery.cs");
    WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Collections.ObjectModel", "System.Threading.Tasks", "System.Windows", clientFxComponentModelNamespace, clientFxClientContextInterfacesNamespace, clientFxClientContextInterfacesNamespace + ".Querying");
#>
public class PaginatedQuery : BindableObject
{
    public const int DefaultPageSizeConst = 20;
    private static int? _defaultPageSize;
    public static int DefaultPageSize
    {
        get { return _defaultPageSize ?? DefaultPageSizeConst; }
        set { _defaultPageSize = value; }
    }
}
        
public class PaginatedQuery<T> : PaginatedQuery, IPaginatedQuery
{
    private IAsyncQueryable<T> _query;
    private MergeOption? _mergeOption;
    private Action<int, IEnumerable<T>> _getValues;
    private Action _callBack;
    
    public PaginatedQuery(IAsyncQueryable<T> query, int? pageSize = null, MergeOption? mergeOption = null, Action<int, IEnumerable<T>> getValues = null, Action callBack = null)
    {
        _query = query;
        PageSize = pageSize ?? DefaultPageSize;
        _mergeOption = mergeOption;
        _callBack = callBack;
        _getValues = getValues ?? ((pageIndex, values) =>
            {
                if (pageIndex != PageIndex)
                    return;
                Items.Clear();
                foreach (T value in values)
                    Items.Add(value);
                if (_callBack != null)
                    _callBack();
            });
    }
        
    public int PageSize { get; private set; }
        
    private int _pageIndex = 1;
    public int PageIndex
    {
        get { return _load ? _pageIndex : 0; }
        set
        {
            _pageIndex = value;
            NotifyPropertyChanged.RaisePropertyChanged(() => PageIndex);
            if (PageIndexChanged != null)
                PageIndexChanged();
            LoadPage(value);
        }
    }
        
    public event Action PageIndexChanged;
        
    private int? _count;
    private bool _isCounting = false;
    public int? Count
    {
        get
        {
            if (_load && _count == null && !_isCounting)
            {
                _isCounting = true;
                InitCount<#=asyncSuffix#>().ConfigureAwait(true);
            }
            return _count;
        }
        private set
        {
            _count = value;
            _isCounting = false;
            NotifyPropertyChanged.RaisePropertyChanged(() => Count);
            NotifyPropertyChanged.RaisePropertyChanged(() => MaxPage);
        }
    }
        
    public async Task InitCount<#=asyncSuffix#>()
    {
        Count = await _query.Count().Execute<#=asyncSuffix#>();
    }
        
    public int MaxPage
    {
        get { return (((Count ?? 1) - 1) / PageSize) + 1; }
    }
        
    private ObservableCollection<T> _items;
    public ObservableCollection<T> Items
    {
        get { return _items ?? (_items = new ObservableCollection<T>()); }
    }
    
    private bool _load;
    public PaginatedQuery<T> LoadPage(int? pageIndex = null, Action callBack = null)
    {
        _load = true;
        LoadPageBody<#=asyncSuffix#>(pageIndex, callBack).ConfigureAwait(true);
        return this;
    }
    private async Task LoadPageBody<#=asyncSuffix#>(int? pageIndex, Action callBack)
    {
        Items.Clear();
        int pageIndexValue = pageIndex ?? PageIndex;
        _getValues(pageIndexValue, await _query.Skip((pageIndexValue - 1) * PageSize).Take(PageSize).Execute<#=asyncSuffix#>(_mergeOption));
    }
        
    private LoadPageParameter[] _identifiers;
    public PaginatedQuery<T> LoadPage(params LoadPageParameter[] identifiers)
    {
        _load = true;
        Items.Clear();
        _identifiers = identifiers;
        LoadPageInternal<#=asyncSuffix#>(identifiers).ConfigureAwait(true);
        return this;
    }
    private async Task LoadPageInternal<#=asyncSuffix#>(params LoadPageParameter[] identifiers)
    {
        var result = await _query.LoadPage<#=asyncSuffix#>(PageSize, _mergeOption, identifiers);
        if (_identifiers == identifiers)
        {
            _pageIndex = result.PageIndex + 1;
            NotifyPropertyChanged.RaisePropertyChanged(() => PageIndex);
            if (PageIndexChanged != null)
                PageIndexChanged();
            Items.Clear();
            foreach (T value in result)
                Items.Add(value);
            if (_callBack != null)
                _callBack();
        }
    }
}
        
public static class PaginatedQueryExtension
{
    public static PaginatedQuery<T> ToPaginatedQuery<T>(this IAsyncQueryable<T> query, int? pageSize = null, MergeOption? mergeOption = null, Action<int, IEnumerable<T>> getValues = null, Action callBack = null)
    {
        return new PaginatedQuery<T>(query, pageSize, mergeOption, getValues, callBack);
    }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("ProxyHelper.cs");
    WriteHeader(namespaceName, code, "System", "System.ServiceModel", "System.Threading.Tasks");
#>
public static class ProxyHelper
{
    public static async Task<TResult> ExecuteFunc<#=asyncSuffix#><T, TResult>(Func<T> factory, Func<T, Task<TResult>> action, int nbRetryOnTimeout = 0)
        where T : ICommunicationObject, IDisposable
    {
        for (int tryIndex = 1; ; tryIndex++)
            using (var service = factory())
            {
                try
                {
                    var value = await action(service);
                    service.Close();
                    return value;
                }
                catch (TimeoutException te)
                {
                    service.Abort();
                    if (tryIndex > nbRetryOnTimeout)
                        throw te;
                }
                catch (Exception e)
                {
                    service.Abort();
                    throw e;
                }
            }
    }

    public static async Task ExecuteAction<#=asyncSuffix#><T>(Func<T> factory, Func<T, Task> action, int nbRetryOnTimeout = 0)
        where T : ICommunicationObject, IDisposable
    {
        for (int tryIndex = 1; ; tryIndex++)
            using (var service = factory())
            {
                try
                {
                    await action(service);
                    service.Close();
                    return;
                }
                catch (TimeoutException te)
                {
                    service.Abort();
                    if (tryIndex > nbRetryOnTimeout)
                        throw te;
                }
                catch (Exception e)
                {
                    service.Abort();
                    throw e;
                }
            }
    }
}
<#+
    WriteFooter(namespaceName);

    WriteSpecificClasses(fileManager, code, clientFxComponentModelNamespace, clientFxEntitiesTrackingNamespace, clientFxClientContextInterfacesNamespace, namespaceName, asyncSuffix);

    fileManager.Process();
}
#>
